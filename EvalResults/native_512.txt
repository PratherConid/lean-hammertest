Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = native, logFile := evalOut.txt}

Testing || CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {D : Type uâ‚}
  [inst_2 : CategoryTheory.Category.{vâ‚, uâ‚} D] (R : CategoryTheory.Functor C D) [inst : R.IsRightAdjoint],
  CategoryTheory.IsFilteredOrEmpty D
Result.exception ::
Duper saturated

Testing || IsCoprime.of_mul_add_right_left : âˆ€ {R : Type u} [inst : CommSemiring R] {x y z : R}, IsCoprime (z * y + x) y â†’ IsCoprime x y
Result.success

Testing || CategoryTheory.evaluation_obj_obj : âˆ€ (C : Type uâ‚) [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] (D : Type uâ‚‚) [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  (X : C) (F : CategoryTheory.Functor C D), ((CategoryTheory.evaluation C D).obj X).obj F = F.obj X
Result.success

Testing || add_le_of_le_tsub_right_of_le : âˆ€ {Î± : Type u_1} [inst : AddCommSemigroup Î±] [inst_1 : PartialOrder Î±] [inst_2 : ExistsAddOfLE Î±]
  [inst_3 : AddLeftMono Î±] [inst_4 : Sub Î±] [inst_5 : OrderedSub Î±] {a b c : Î±}, b â‰¤ c â†’ a â‰¤ c - b â†’ a + b â‰¤ c
Result.success

Testing || Matrix.Nondegenerate.exists_not_ortho_of_ne_zero : âˆ€ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},
  M.Nondegenerate â†’ âˆ€ {v : m â†’ R}, v â‰  0 â†’ âˆƒ w, Matrix.dotProduct v (M.mulVec w) â‰  0
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : (#1 â†’ #2), (âˆ€ x2 : #1, ((!4 (Î»x3 : #1, (x0 x2 x3)) x1) = (!5 x0 x1 x2))))) is not type correct

Testing || NonUnitalSubring.closure_eq_of_le : âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] {s : Set R} {t : NonUnitalSubring R},
  s âŠ† â†‘t â†’ t â‰¤ NonUnitalSubring.closure s â†’ NonUnitalSubring.closure s = t
Result.success

Testing || UInt32.intCast_def : âˆ€ (z : â„¤), â†‘z = { toBitVec := â†‘z }
Result.success

Testing || MeasureTheory.SignedMeasure.rnDeriv_sub : âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (s t : MeasureTheory.SignedMeasure Î±) (Î¼ : MeasureTheory.Measure Î±)
  [inst : s.HaveLebesgueDecomposition Î¼] [inst : t.HaveLebesgueDecomposition Î¼]
  [hst : (s - t).HaveLebesgueDecomposition Î¼], (s - t).rnDeriv Î¼ =áµ[Î¼] s.rnDeriv Î¼ - t.rnDeriv Î¼
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.foldlIdx_eq_foldlIdxSpec : âˆ€ {Î± : Type u} {Î² : Type v} (f : â„• â†’ Î± â†’ Î² â†’ Î±) (a : Î±) (bs : List Î²) (start : â„•),
  List.foldlIdx f a bs start = List.foldlIdxSpec f a bs start
Result.exception ::
Duper saturated

Testing || Subring.coe_zero : âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), â†‘0 = 0
Result.success

Testing || Std.DHashMap.Internal.Rawâ‚€.getKey?_eq_getKey?â‚˜ : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : BEq Î±] [inst_1 : Hashable Î±] (m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²) (a : Î±),
  m.getKey? a = m.getKey?â‚˜ a
Result.success

Testing || Multiset.map_univ_coeEmbedding : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (m : Multiset Î±), Finset.map m.coeEmbedding Finset.univ = m.toEnumFinset
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.univ`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Ring.multichoose_zero_right' : âˆ€ {R : Type u_1} [inst : AddCommMonoid R] [inst_1 : Pow R â„•] [inst_2 : BinomialRing R] (r : R),
  Ring.multichoose r 0 = r ^ 0
Result.exception ::
Duper saturated

Testing || Filter.EventuallyEq.gradient : âˆ€ {ğ•œ : Type u_1} {F : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace ğ•œ F]
  [inst_3 : CompleteSpace F] {f : F â†’ ğ•œ} {x : F} {fâ‚ : F â†’ ğ•œ}, fâ‚ =á¶ [nhds x] f â†’ gradient fâ‚ =á¶ [nhds x] gradient f
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Matrix.PosSemidef.eq_of_sq_eq_sq : âˆ€ {n : Type u_2} {ğ•œ : Type u_4} [inst : Fintype n] [inst_1 : RCLike ğ•œ] [inst_2 : DecidableEq n] {A : Matrix n n ğ•œ},
  A.PosSemidef â†’ âˆ€ {B : Matrix n n ğ•œ}, B.PosSemidef â†’ A ^ 2 = B ^ 2 â†’ A = B
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || minpoly.coeff_zero_ne_zero : âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},
  IsIntegral A x â†’ x â‰  0 â†’ (minpoly A x).coeff 0 â‰  0
Result.success

Testing || List.cons_subperm_of_not_mem_of_mem : âˆ€ {Î± : Type u_1} {a : Î±} {lâ‚ lâ‚‚ : List Î±}, a âˆ‰ lâ‚ â†’ a âˆˆ lâ‚‚ â†’ lâ‚.Subperm lâ‚‚ â†’ (a :: lâ‚).Subperm lâ‚‚
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.BilinForm.IsSymm.eq : âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {B : LinearMap.BilinForm R M}, B.IsSymm â†’ âˆ€ (x y : M), (B x) y = (B y) x
Result.exception ::
Duper saturated

Testing || CategoryTheory.Limits.IsImage.isoExt_inv_m : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}
  {F F' : CategoryTheory.Limits.MonoFactorisation f} (hF : CategoryTheory.Limits.IsImage F)
  (hF' : CategoryTheory.Limits.IsImage F'), CategoryTheory.CategoryStruct.comp (hF.isoExt hF').inv F.m = F'.m
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.lift x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Equiv.curry_apply : âˆ€ (Î± : Type u_9) (Î² : Type u_10) (Î³ : Sort u_11), â‡‘(Equiv.curry Î± Î² Î³) = Function.curry
Result.exception ::
Duper saturated

Testing || dif_neg : âˆ€ {c : Prop} {h : Decidable c} (hnc : Â¬c) {Î± : Sort u} {t : c â†’ Î±} {e : Â¬c â†’ Î±}, dite c t e = e hnc
Result.exception ::
Duper saturated

Testing || Ordinal.one_CNF : âˆ€ {o : Ordinal.{u_1}}, o â‰  0 â†’ Ordinal.CNF 1 o = [(0, o)]
Result.exception ::
Duper saturated

Testing || ContinuousAffineMap.sub_contLinear : âˆ€ {R : Type u_2} {V : Type u_3} {W : Type u_4} {P : Type u_6} [inst : NormedAddCommGroup V] [inst_1 : MetricSpace P]
  [inst_2 : NormedAddTorsor V P] [inst_3 : NormedAddCommGroup W] [inst_4 : NormedField R] [inst_5 : NormedSpace R V]
  [inst_6 : NormedSpace R W] (f g : P â†’á´¬[R] W), (f - g).contLinear = f.contLinear - g.contLinear
Result.success

Testing || AddEquiv.instEquivLike.proof_2 : âˆ€ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : M â‰ƒ+ N), Function.RightInverse f.invFun f.toFun
Result.success

Testing || List.mapIdx_set : âˆ€ {Î± : Type u_1} {Î±_1 : Type u_2} {f : â„• â†’ Î± â†’ Î±_1} {l : List Î±} {i : â„•} {a : Î±},
  List.mapIdx f (l.set i a) = (List.mapIdx f l).set i (f i a)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || SetTheory.PGame.insertRight_le : âˆ€ (x x' : SetTheory.PGame), x.insertRight x' â‰¤ x
Result.exception ::
Duper saturated

Testing || nhdsAdjoint_nhds : âˆ€ {Î± : Type u} (a : Î±) (f : Filter Î±), nhds a = pure a âŠ” f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `nhdsAdjoint x_0 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || instUniqueAddUnitsOfSubsingleton.proof_1 : âˆ€ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Subsingleton M] (x : AddUnits M), x = 0
Result.exception ::
Duper saturated

Testing || Cardinal.mk_coe_finset : âˆ€ {Î± : Type u} {s : Finset Î±}, Cardinal.mk { x // x âˆˆ s } = â†‘s.card
Result.exception ::
Duper saturated

Testing || CategoryTheory.Sieve.pullback_ofObjects_eq_top : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {I : Type u_1} (Y : I â†’ C) {X : C} {i : I},
  (X âŸ¶ Y i) â†’ CategoryTheory.Sieve.ofObjects Y X = âŠ¤
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.Presieve X is not a `âˆ€`

Testing || Set.iUnion_option : âˆ€ {Î± : Type u_1} {Î¹ : Type u_11} (s : Option Î¹ â†’ Set Î±), â‹ƒ o, s o = s none âˆª â‹ƒ i, s (some i)
Result.success

Testing || Ergodic.ae_empty_or_univ_of_preimage_ae_le' : âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {s : Set Î±} {f : Î± â†’ Î±} {Î¼ : MeasureTheory.Measure Î±},
  Ergodic f Î¼ â†’ MeasureTheory.NullMeasurableSet s Î¼ â†’ f â»Â¹' s â‰¤áµ[Î¼] s â†’ Î¼ s â‰  âŠ¤ â†’ s =áµ[Î¼] âˆ… âˆ¨ s =áµ[Î¼] Set.univ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (!5 (!6 !2) (!7 !1 !4) !4) is not type correct

Testing || MeasureTheory.Measure.rnDeriv_smul_right_of_ne_top : âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î½ Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î½]
  [inst : Î½.HaveLebesgueDecomposition Î¼] {r : ENNReal}, r â‰  0 â†’ r â‰  âŠ¤ â†’ Î½.rnDeriv (r â€¢ Î¼) =áµ[Î¼] râ»Â¹ â€¢ Î½.rnDeriv Î¼
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || PartialHomeomorph.coe_trans_symm : âˆ€ {X : Type u_1} {Y : Type u_3} {Z : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] (e : PartialHomeomorph X Y) (e' : PartialHomeomorph Y Z),
  â†‘(e.trans e').symm = â†‘e.symm âˆ˜ â†‘e'.symm
Result.exception ::
Duper saturated

Testing || Set.bounded_lt_Iic : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : NoMaxOrder Î±] (a : Î±), Set.Bounded (fun x1 x2 => x1 < x2) (Set.Iic a)
Result.success

Testing || MeasureTheory.eLpNorm_const_smul_le : âˆ€ {Î± : Type u_1} {F : Type u_3} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}
  [inst : NormedAddCommGroup F] {ğ•œ : Type u_5} [inst_1 : NormedRing ğ•œ] [inst_2 : MulActionWithZero ğ•œ F]
  [inst_3 : BoundedSMul ğ•œ F] {c : ğ•œ} {f : Î± â†’ F}, MeasureTheory.eLpNorm (c â€¢ f) p Î¼ â‰¤ â€–câ€–â‚Š â€¢ MeasureTheory.eLpNorm f p Î¼
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulZeroClass.toSMul`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Iso.isIso_inv : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (e : X â‰… Y), CategoryTheory.IsIso e.inv
Result.exception ::
Duper saturated

Testing || IntermediateField.adjoin_univ : âˆ€ (F : Type u_3) (E : Type u_4) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E],
  IntermediateField.adjoin F Set.univ = âŠ¤
Result.exception ::
Duper saturated

Testing || NonemptyInterval.snd_add : âˆ€ {Î± : Type u_2} [inst : Preorder Î±] [inst_1 : Add Î±] [inst_2 : AddLeftMono Î±] [inst_3 : AddRightMono Î±]
  (s t : NonemptyInterval Î±), (s + t).toProd.2 = s.toProd.2 + t.toProd.2
Result.success

Testing || CategoryTheory.Bicategory.RightExtension.w_assoc : âˆ€ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b c : B} {f : a âŸ¶ b} {g : a âŸ¶ c}
  {s t : CategoryTheory.Bicategory.RightExtension f g} (Î· : s âŸ¶ t) {Z : a âŸ¶ c} (h : g âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f Î·.left)
      (CategoryTheory.CategoryStruct.comp t.counit h) =
    CategoryTheory.CategoryStruct.comp s.counit h
Result.exception ::
(deterministic) timeout at `printProof`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Disjoint.subset_compl_left : âˆ€ {Î± : Type u} {s t : Set Î±}, Disjoint t s â†’ s âŠ† tá¶œ
Result.success

Testing || IsAntichain.flip : âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±}, IsAntichain r s â†’ IsAntichain (flip r) s
Result.exception ::
Duper saturated

Testing || LowerAdjoint.closure_iUnion_closure : âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} {Î² : Type u_4} [inst : SetLike Î± Î²] (l : LowerAdjoint SetLike.coe) (f : Î¹ â†’ Î±),
  l.toFun (â‹ƒ i, â†‘(l.toFun â†‘(f i))) = l.toFun (â‹ƒ i, â†‘(f i))
Result.exception ::
Duper saturated

Testing || Subsemiring.mem_closure_iff : âˆ€ {R : Type u} [inst : NonAssocSemiring R] {s : Set R} {x : R},
  x âˆˆ Subsemiring.closure s â†” x âˆˆ AddSubmonoid.closure â†‘(Submonoid.closure s)
Result.success

Testing || Real.deriv_cos : âˆ€ {x : â„}, deriv Real.cos x = -Real.sin x
Result.success

Testing || Pell.IsFundamental.mul_inv_x_lt_x : âˆ€ {d : â„¤} {aâ‚ : Pell.Solutionâ‚ d},
  Pell.IsFundamental aâ‚ â†’ âˆ€ {a : Pell.Solutionâ‚ d}, 1 < a.x â†’ 0 < a.y â†’ (a * aâ‚â»Â¹).x < a.x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Complex.cos_conj : âˆ€ (x : â„‚), Complex.cos ((starRingEnd â„‚) x) = (starRingEnd â„‚) (Complex.cos x)
Result.success

Testing || MeasureTheory.Supermartingale.set_integral_le : âˆ€ {Î© : Type u_1} {Î¹ : Type u_3} [inst : Preorder Î¹] {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©}
  {â„± : MeasureTheory.Filtration Î¹ m0} [inst_1 : MeasureTheory.SigmaFiniteFiltration Î¼ â„±] {f : Î¹ â†’ Î© â†’ â„},
  MeasureTheory.Supermartingale f â„± Î¼ â†’
    âˆ€ {i j : Î¹}, i â‰¤ j â†’ âˆ€ {s : Set Î©}, MeasurableSet s â†’ âˆ« (Ï‰ : Î©) in s, f j Ï‰ âˆ‚Î¼ â‰¤ âˆ« (Ï‰ : Î©) in s, f i Ï‰ âˆ‚Î¼
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `â†‘x_1 i`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddAction.pretransitive_iff_unique_quotient_of_nonempty : âˆ€ (G : Type u_1) (Î± : Type u_2) [inst : AddGroup G] [inst_1 : AddAction G Î±] [inst_2 : Nonempty Î±],
  AddAction.IsPretransitive G Î± â†” Nonempty (Unique (AddAction.orbitRel.Quotient G Î±))
Result.exception ::
Duper saturated

Testing || InnerProductGeometry.norm_sub_eq_add_norm_of_angle_eq_pi : âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},
  InnerProductGeometry.angle x y = Real.pi â†’ â€–x - yâ€– = â€–xâ€– + â€–yâ€–
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.union_sdiff_cancel_left : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {s t : Finset Î±}, Disjoint s t â†’ (s âˆª t) \ s = t
Result.success

Testing || Module.Presentation.finite : âˆ€ {A : Type u} [inst : Ring A] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module A M]
  (pres : Module.Presentation A M) [inst_3 : Finite pres.G], Module.Finite A M
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.toSolution`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LowerSet.mem_iInfâ‚‚_iff : âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Îº : Î¹ â†’ Sort u_5} [inst : LE Î±] {a : Î±} {f : (i : Î¹) â†’ Îº i â†’ LowerSet Î±},
  a âˆˆ â¨… i, â¨… j, f i j â†” âˆ€ (i : Î¹) (j : Îº i), a âˆˆ f i j
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Îº iâœ of Î» binder contains bound variables

Testing || Finsupp.smul_single' : âˆ€ {Î± : Type u_1} {R : Type u_11} {x : Semiring R} (c : R) (a : Î±) (b : R), (c â€¢ funâ‚€ | a => b) = funâ‚€ | a => c * b
Result.success

Testing || Commute.inv : âˆ€ {G : Type u_1} [inst : DivisionMonoid G] {a b : G}, Commute a b â†’ (a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹
Result.success

Testing || Finset.Nonempty.piFinset_const : âˆ€ {Î² : Type u_2} {Î¹ : Type u_5} [inst : Fintype Î¹] [inst_1 : DecidableEq Î¹] {s : Finset Î²},
  s.Nonempty â†’ (Fintype.piFinset fun x => s).Nonempty
Result.success

Testing || List.cons_sublist_cons' : âˆ€ {Î± : Type u} {lâ‚ lâ‚‚ : List Î±} {a b : Î±}, (a :: lâ‚).Sublist (b :: lâ‚‚) â†” (a :: lâ‚).Sublist lâ‚‚ âˆ¨ a = b âˆ§ lâ‚.Sublist lâ‚‚
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.image_subset_sups_right : âˆ€ {Î± : Type u_2} [inst : SemilatticeSup Î±] {s t : Set Î±} {a : Î±}, a âˆˆ s â†’ (fun x1 x2 => x1 âŠ” x2) a '' t âŠ† s âŠ» t
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!9 (!11 (!4 (Î»x0 : #1, (!5 !2 x0)) !6)) (!7 !1 !6)) = (!3 (!4 (Î»x0 : #1, (!5 !2 x0)) !6) (!7 !1 !6))) is not type correct

Testing || FractionalIdeal.mem_extended_iff : âˆ€ {A : Type u_1} [inst : CommRing A] {B : Type u_2} [inst_1 : CommRing B] {f : A â†’+* B} {K : Type u_3} {M : Submonoid A}
  [inst_2 : CommRing K] [inst_3 : Algebra A K] [inst_4 : IsLocalization M K] (L : Type u_4) {N : Submonoid B}
  [inst_5 : CommRing L] [inst_6 : Algebra B L] [inst_7 : IsLocalization N L] (hf : M â‰¤ Submonoid.comap f N)
  (I : FractionalIdeal M K) (x : L),
  x âˆˆ FractionalIdeal.extended L hf I â†” x âˆˆ Submodule.span B (â‡‘(IsLocalization.map L f hf) '' â†‘I)
Result.success

Testing || Bimod.regular_actRight : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] (A : Mon_ C),
  (Bimod.regular A).actRight = A.mul
Result.success

Testing || TrivSqZeroExt.map_comp_map : âˆ€ {R' : Type u} {M : Type v} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R' M]
  [inst_3 : _root_.Module R'áµáµ’áµ– M] [inst_4 : IsCentralScalar R' M] {N : Type u_3} {P : Type u_4}
  [inst_5 : AddCommMonoid N] [inst_6 : _root_.Module R' N] [inst_7 : _root_.Module R'áµáµ’áµ– N]
  [inst_8 : IsCentralScalar R' N] [inst_9 : AddCommMonoid P] [inst_10 : _root_.Module R' P]
  [inst_11 : _root_.Module R'áµáµ’áµ– P] [inst_12 : IsCentralScalar R' P] (f : M â†’â‚—[R'] N) (g : N â†’â‚—[R'] P),
  TrivSqZeroExt.map (g âˆ˜â‚— f) = (TrivSqZeroExt.map g).comp (TrivSqZeroExt.map f)
Result.exception ::
Duper saturated

Testing || StrictConvexOn.slope_lt_of_hasDerivAt : âˆ€ {S : Set â„} {f : â„ â†’ â„} {x y f' : â„},
  StrictConvexOn â„ S f â†’ x âˆˆ S â†’ y âˆˆ S â†’ x < y â†’ HasDerivAt f f' y â†’ slope f x y < f'
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!3 (!12 !4) !5) = (!6 !4 !5)) is not type correct

Testing || AddUnits.min_val : âˆ€ {Î± : Type u_1} [inst : AddMonoid Î±] [inst_1 : LinearOrder Î±] {a b : AddUnits Î±}, â†‘(a âŠ“ b) = â†‘a âŠ“ â†‘b
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || FreeCommRing.isSupported_add : âˆ€ {Î± : Type u} {x y : FreeCommRing Î±} {s : Set Î±}, x.IsSupported s â†’ y.IsSupported s â†’ (x + y).IsSupported s
Result.success

Testing || IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point : âˆ€ {p : â„•} {G : Type u_1} [inst : Group G],
  IsPGroup p G â†’
    âˆ€ [hp : Fact (Nat.Prime p)] (Î± : Type u_2) [inst_1 : MulAction G Î±] [inst_2 : Finite Î±],
      p âˆ£ Nat.card Î± â†’ âˆ€ {a : Î±}, a âˆˆ MulAction.fixedPoints G Î± â†’ âˆƒ b âˆˆ MulAction.fixedPoints G Î±, a â‰  b
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #2, (âˆ€ x1 : #2, ((!8 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || ContDiffBump.neg : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : HasContDiffBump E]
  (f : ContDiffBump 0) (x : E), â†‘f (-x) = â†‘f x
Result.success

Testing || IsAddSubgroup.normalizer_isAddSubgroup : âˆ€ {G : Type u_1} [inst : AddGroup G] (s : Set G), IsAddSubgroup (IsAddSubgroup.addNormalizer s)
Result.exception ::
Duper saturated

Testing || SubmonoidClass.finsupp_prod_mem : âˆ€ {Î± : Type u_1} {M : Type u_8} {N : Type u_10} [inst : _root_.Zero M] [inst_1 : CommMonoid N] {S : Type u_16}
  [inst_2 : SetLike S N] [inst_3 : SubmonoidClass S N] (s : S) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N),
  (âˆ€ (c : Î±), f c â‰  0 â†’ g c (f c) âˆˆ s) â†’ f.prod g âˆˆ s
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.sub_add_bmod_cancel : âˆ€ {w : â„•} {x y : BitVec w}, (â†‘(2 ^ w) - â†‘y.toNat + â†‘x.toNat).bmod (2 ^ w) = (â†‘x.toNat - â†‘y.toNat).bmod (2 ^ w)
Result.exception ::
(deterministic) timeout at `printProof`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.einfsep_iUnion_mem_option : âˆ€ {Î± : Type u_1} [inst : EDist Î±] {Î¹ : Type u_3} (o : Option Î¹) (s : Î¹ â†’ Set Î±),
  (â‹ƒ i âˆˆ o, s i).einfsep = â¨… i âˆˆ o, (s i).einfsep
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type iâœ âˆˆ o of Î» binder contains bound variables

Testing || bddAbove_neg : âˆ€ {G : Type u_2} [inst : AddGroup G] [inst_1 : Preorder G] [inst_2 : AddLeftMono G] [inst_3 : AddRightMono G]
  {s : Set G}, BddAbove (-s) â†” BddBelow s
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Sat.Fmla.subsumes_left : âˆ€ (f fâ‚ fâ‚‚ : Sat.Fmla), f.subsumes (fâ‚.and fâ‚‚) â†’ f.subsumes fâ‚
Result.exception ::
Duper saturated

Testing || OrderHom.snd_coe : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] (self : Î± Ã— Î²), OrderHom.snd self = self.2
Result.success

Testing || Quaternion.imK_snd_dualNumberEquiv : âˆ€ {R : Type u_1} [inst : CommRing R] (q : Quaternion (DualNumber R)),
  (TrivSqZeroExt.snd (Quaternion.dualNumberEquiv q)).imK = TrivSqZeroExt.snd q.imK
Result.success

Testing || AddCommMagma.IsRightCancelAdd.toIsCancelAdd : âˆ€ (G : Type u) [inst : AddCommMagma G] [inst_1 : IsRightCancelAdd G], IsCancelAdd G
Result.exception ::
Duper saturated

Testing || Finset.sum_smul_vsub_const_eq_affineCombination_vsub : âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [S : AddTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ : P),
  âˆ‘ i âˆˆ s, w i = 1 â†’ âˆ‘ i âˆˆ s, w i â€¢ (pâ‚ i -áµ¥ pâ‚‚) = (Finset.affineCombination k s pâ‚) w -áµ¥ pâ‚‚
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Limits.hasTerminalChangeUniverse : âˆ€ (C : Type uâ‚) [inst : CategoryTheory.Category.{vâ‚, uâ‚} C]
  [h : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w + 1}) C],
  CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w' + 1}) C
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Algebra.IsStandardSmooth.localization_away : âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] (r : R)
  [inst_3 : IsLocalization.Away r S], Algebra.IsStandardSmooth R S
Result.exception ::
Duper saturated

Testing || IsCoprime.dvd_of_dvd_mul_right : âˆ€ {R : Type u} [inst : CommSemiring R] {x y z : R}, IsCoprime x z â†’ x âˆ£ y * z â†’ x âˆ£ y
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || UInt32.toUInt16_toNat : âˆ€ (x : UInt32), x.toUInt16.toNat = x.toNat % 2 ^ 16
Result.success

Testing || Std.Tactic.BVDecide.Normalize.Bool.or_elim : âˆ€ (a b : Bool), (a || b) = !(!a && !b)
Result.success

Testing || MeasureTheory.SimpleFunc.pair_apply : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : MeasurableSpace Î±] (f : MeasureTheory.SimpleFunc Î± Î²)
  (g : MeasureTheory.SimpleFunc Î± Î³) (a : Î±), (f.pair g) a = (f a, g a)
Result.success

Testing || _private.Mathlib.NumberTheory.FermatPsp.0.Nat.b_id_helper : âˆ€ {a b : â„•}, 2 â‰¤ a â†’ 2 < b â†’ 2 â‰¤ (a ^ b + 1) / (a + 1)
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ofLex_inj : âˆ€ {Î± : Type u_1} {a b : Lex Î±}, ofLex a = ofLex b â†” a = b
Result.success

Testing || compactlySupported_eq_top : âˆ€ {Î± : Type u_1} {Î³ : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : NonUnitalNormedRing Î³] [inst_2 : CompactSpace Î±],
  compactlySupported Î± Î³ = âŠ¤
Result.success

Testing || LinearIsometry.map_orthogonalProjection' : âˆ€ {ğ•œ : Type u_1} [inst : RCLike ğ•œ] {E : Type u_4} {E' : Type u_5} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedAddCommGroup E'] [inst_3 : InnerProductSpace ğ•œ E] [inst_4 : InnerProductSpace ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E')
  (p : Submodule ğ•œ E) [inst_5 : HasOrthogonalProjection p] [inst_6 : HasOrthogonalProjection (Submodule.map f p)]
  (x : E), f â†‘((orthogonalProjection p) x) = â†‘((orthogonalProjection (Submodule.map f p)) (f x))
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ProbabilityTheory.Kernel.iIndepSets.ae_isProbabilityMeasure : âˆ€ {Î± : Type u_1} {Î© : Type u_2} {Î¹ : Type u_3} {_mÎ± : MeasurableSpace Î±} {_mÎ© : MeasurableSpace Î©}
  {Îº : ProbabilityTheory.Kernel Î± Î©} {Î¼ : MeasureTheory.Measure Î±} {Ï€ : Î¹ â†’ Set (Set Î©)},
  ProbabilityTheory.Kernel.iIndepSets Ï€ Îº Î¼ â†’ âˆ€áµ (a : Î±) âˆ‚Î¼, MeasureTheory.IsProbabilityMeasure (Îº a)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type iâœ âˆˆ s of Î» binder contains bound variables

Testing || Real.exp_ne_zero : âˆ€ (x : â„), Real.exp x â‰  0
Result.success

Testing || Profinite.NobelingProof.GoodProducts.maxToGood_injective : âˆ€ {I : Type u} (C : Set (I â†’ Bool)) [inst : LinearOrder I] [inst_1 : WellFoundedLT I] {o : Ordinal.{u}}
  (hC : IsClosed C) (hsC : Profinite.NobelingProof.contained C (Order.succ o))
  (ho : o < Ordinal.type fun x1 x2 => x1 < x2)
  (hâ‚ :
    âŠ¤ â‰¤
      Submodule.span â„¤
        (Set.range
          (Profinite.NobelingProof.GoodProducts.eval
            (Profinite.NobelingProof.Ï€ C fun x => Profinite.NobelingProof.ord I x < o)))),
  Function.Injective (Profinite.NobelingProof.GoodProducts.MaxToGood C hC hsC ho hâ‚)
Result.exception ::
Duper saturated

Testing || StrictConvexOn.map_sum_eq_iff' : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]
  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : _root_.Module ğ•œ E] [inst_4 : _root_.Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]
  {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E},
  StrictConvexOn ğ•œ s f â†’
    (âˆ€ i âˆˆ t, 0 â‰¤ w i) â†’
      âˆ‘ i âˆˆ t, w i = 1 â†’
        (âˆ€ i âˆˆ t, p i âˆˆ s) â†’
          (f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i) â†” âˆ€ j âˆˆ t, w j â‰  0 â†’ p j = âˆ‘ i âˆˆ t, w i â€¢ p i)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!25 !26 !27) = !0) is not type correct

Testing || RightCancelSemigroup.ext : âˆ€ {G : Type u} {x y : RightCancelSemigroup G}, Mul.mul = Mul.mul â†’ x = y
Result.exception ::
Duper saturated

Testing || Finset.diffs_union_right : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : GeneralizedBooleanAlgebra Î±] {s tâ‚ tâ‚‚ : Finset Î±},
  s.diffs (tâ‚ âˆª tâ‚‚) = s.diffs tâ‚ âˆª s.diffs tâ‚‚
Result.success

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetryIso_hom : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b âŸ¶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a âŸ¶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful],
  (hf'.symmetryIso hg).hom = hf'.symmetry hg
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `âˆ€`

Testing || Fin.rev_sub : âˆ€ {n : â„•} (a b : Fin n), (a - b).rev = a.rev + b
Result.success

Testing || Std.Tactic.BVDecide.BVBinPred.eval_ult : âˆ€ {w : â„•}, Std.Tactic.BVDecide.BVBinPred.ult.eval = BitVec.ult
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.sum_pos : âˆ€ {M : Type u_3} [inst : OrderedAddCommMonoid M] (l : List M), (âˆ€ x âˆˆ l, 0 < x) â†’ l â‰  [] â†’ 0 < l.sum
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.comp_familyOfBFamily' : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u} (r : Î¹ â†’ Î¹ â†’ Prop) [inst : IsWellOrder Î¹ r] {o : Ordinal.{u}}
  (ho : Ordinal.type r = o) (f : (a : Ordinal.{u}) â†’ a < o â†’ Î±) (g : Î± â†’ Î²),
  g âˆ˜ Ordinal.familyOfBFamily' r ho f = Ordinal.familyOfBFamily' r ho fun i hi => g (f i hi)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i < o of Î» binder contains bound variables

Testing || star_natCast_smul : âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  [inst_3 : StarAddMonoid M] (n : â„•) (x : M), star (â†‘n â€¢ x) = â†‘n â€¢ star x
Result.exception ::
Duper saturated

Testing || SetTheory.PGame.fuzzy_of_fuzzy_of_equiv : âˆ€ {x y z : SetTheory.PGame}, x.Fuzzy y â†’ y â‰ˆ z â†’ x.Fuzzy z
Result.exception ::
Duper saturated

Testing || LocallyConvexSpace.ofBases : âˆ€ (ğ•œ : Type u_1) (E : Type u_2) [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E] [inst_2 : _root_.Module ğ•œ E]
  [inst_3 : TopologicalSpace E] {Î¹ : Type u_3} (b : E â†’ Î¹ â†’ Set E) (p : E â†’ Î¹ â†’ Prop),
  (âˆ€ (x : E), (nhds x).HasBasis (p x) (b x)) â†’ (âˆ€ (x : E) (i : Î¹), p x i â†’ Convex ğ•œ (b x i)) â†’ LocallyConvexSpace ğ•œ E
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #3, ((!6 x0 (Î»x1 : #0, (âˆ€ x2 : #0, ((!9 x0 x2) â†’ (âˆ€ x3 : #4, (âˆ€ x4 : #4, ((!8 !10 x3) â†’ ((!8 !10 x4) â†’ (((!11 x3 x4) = !12) â†’ (!9 x0 (!13 (!14 x3 x1) (!14 x4 x2)))))))))))) = (!4 x0))) is not type correct

Testing || EulerProduct.eulerProduct : âˆ€ {R : Type u_1} [inst : NormedCommRing R] {f : â„• â†’ R} [inst_1 : CompleteSpace R],
  f 1 = 1 â†’
    (âˆ€ {m n : â„•}, m.Coprime n â†’ f (m * n) = f m * f n) â†’
      (Summable fun x => â€–f xâ€–) â†’
        f 0 = 0 â†’
          Filter.Tendsto (fun n => âˆ p âˆˆ n.primesBelow, âˆ‘' (e : â„•), f (p ^ e)) Filter.atTop (nhds (âˆ‘' (n : â„•), f n))
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : Nat, (âˆ€ x1 : Nat, ((!20 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Mathlib.Vector.get_ofFn : âˆ€ {Î± : Type u_1} {n : â„•} (f : Fin n â†’ Î±) (i : Fin n), (Mathlib.Vector.ofFn f).get i = f i
Result.exception ::
Duper saturated

Testing || CategoryTheory.ShortComplex.sub_Ï„â‚ : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {Sâ‚ Sâ‚‚ : CategoryTheory.ShortComplex C} (Ï† Ï†' : Sâ‚ âŸ¶ Sâ‚‚), (Ï† - Ï†').Ï„â‚ = Ï†.Ï„â‚ - Ï†'.Ï„â‚
Result.success

Testing || MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq : âˆ€ {Î© : Type u_1} {E : Type u_2} {m : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : NormedAddCommGroup E]
  [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {Î¹ : Type u_3} [inst_3 : LinearOrder Î¹]
  [inst_4 : TopologicalSpace Î¹] [inst_5 : OrderTopology Î¹] [inst_6 : FirstCountableTopology Î¹]
  {â„± : MeasureTheory.Filtration Î¹ m} [inst_7 : MeasureTheory.SigmaFiniteFiltration Î¼ â„±] {Ï„ : Î© â†’ Î¹} {f : Î¹ â†’ Î© â†’ E}
  {n : Î¹},
  MeasureTheory.Martingale f â„± Î¼ â†’
    âˆ€ (hÏ„ : MeasureTheory.IsStoppingTime â„± Ï„) (hÏ„_le : âˆ€ (x : Î©), Ï„ x â‰¤ n)
      [inst_8 : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)] (i : Î¹),
      MeasureTheory.stoppedValue f Ï„ =áµ[Î¼.restrict {x | Ï„ x = i}] MeasureTheory.condexp hÏ„.measurableSpace Î¼ (f n)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Set (Set Î©) is not a `âˆ€`

Testing || Complex.sameRay_of_arg_eq : âˆ€ {x y : â„‚}, x.arg = y.arg â†’ SameRay â„ x y
Result.success

Testing || CategoryTheory.Limits.initial.to_comp : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Limits.HasInitial C] {P Q : C}
  (f : P âŸ¶ Q),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial.to P) f = CategoryTheory.Limits.initial.to Q
Result.exception ::
Duper saturated

Testing || BoundedLatticeHom.id_comp : âˆ€ {Î± : Type u_3} {Î² : Type u_4} [inst : Lattice Î±] [inst_1 : Lattice Î²] [inst_2 : BoundedOrder Î±]
  [inst_3 : BoundedOrder Î²] (f : BoundedLatticeHom Î± Î²), (BoundedLatticeHom.id Î²).comp f = f
Result.success

Testing || Differentiable.analyticAt : âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},
  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z
Result.success

Testing || CompleteOrthogonalIdempotents.option : âˆ€ {R : Type u_1} [inst : Ring R] {I : Type u_3} {e : I â†’ R} [inst_1 : Fintype I],
  OrthogonalIdempotents e â†’ CompleteOrthogonalIdempotents fun x => x.elim (1 - âˆ‘ i : I, e i) e
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.univ`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || QuaternionAlgebra.neg_mk : âˆ€ {R : Type u_3} {câ‚ câ‚‚ : R} [inst : Neg R] (aâ‚ aâ‚‚ aâ‚ƒ aâ‚„ : R),
  -{ re := aâ‚, imI := aâ‚‚, imJ := aâ‚ƒ, imK := aâ‚„ } = { re := -aâ‚, imI := -aâ‚‚, imJ := -aâ‚ƒ, imK := -aâ‚„ }
Result.success

Testing || Filter.eventually_gt_atTop : âˆ€ {Î± : Type u_3} [inst : Preorder Î±] [inst_1 : NoMaxOrder Î±] (a : Î±), âˆ€á¶  (x : Î±) in Filter.atTop, a < x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #2, ((!1 x1 x0) = (!5 x0 x1)))) is not type correct

Testing || NNReal.iSup_mul_le : âˆ€ {Î¹ : Sort u_2} {a : NNReal} {g : Î¹ â†’ NNReal} {h : NNReal}, (âˆ€ (i : Î¹), g i * h â‰¤ a) â†’ iSup g * h â‰¤ a
Result.success

Testing || Padic.AddValuation.map_add : âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (x y : â„š_[p]), x.addValuationDef âŠ“ y.addValuationDef â‰¤ (x + y).addValuationDef
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderTop.toTop`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || PNat.mod_add_div' : âˆ€ (m k : â„•+), â†‘(m.mod k) + m.div k * â†‘k = â†‘m
Result.success

Testing || CategoryTheory.SingleFunctors.shiftIso_add' : âˆ€ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_7, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_6, u_2} D] {A : Type u_5} [inst_2 : AddMonoid A]
  [inst_3 : CategoryTheory.HasShift D A] (F : CategoryTheory.SingleFunctors C D A) (n m mn : A) (hnm : m + n = mn)
  (a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a''),
  F.shiftIso mn a a'' â‹¯ =
    CategoryTheory.isoWhiskerLeft (F.functor a'') (CategoryTheory.shiftFunctorAdd' D m n mn hnm) â‰ªâ‰«
      ((F.functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm â‰ªâ‰«
        CategoryTheory.isoWhiskerRight (F.shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n) â‰ªâ‰«
          F.shiftIso n a a' ha'
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `rfl`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || imaginaryPart_eq_neg_I_smul_skewAdjointPart : âˆ€ {A : Type u_1} [inst : AddCommGroup A] [inst_1 : _root_.Module â„‚ A] [inst_2 : StarAddMonoid A]
  [inst_3 : StarModule â„‚ A] (x : A), â†‘(imaginaryPart x) = -Complex.I â€¢ â†‘((skewAdjointPart â„) x)
Result.success

Testing || Submodule.toAddSubmonoid_eq : âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {p q : Submodule R M}, p.toAddSubmonoid = q.toAddSubmonoid â†” p = q
Result.success

Testing || DFinsupp.equivFunOnFintype_symm_coe : âˆ€ {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [inst : (i : Î¹) â†’ _root_.Zero (Î² i)] [inst_1 : Fintype Î¹] (f : Î â‚€ (i : Î¹), Î² i),
  DFinsupp.equivFunOnFintype.symm â‡‘f = f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.NumberTheory.Padics.Hensel.0.newton_seq_dist : âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {F : Polynomial â„¤_[p]} {a : â„¤_[p]}
  (hnorm : â€–Polynomial.eval a Fâ€– < â€–Polynomial.eval a (Polynomial.derivative F)â€– ^ 2) {n k : â„•},
  n â‰¤ k â†’
    â€–newton_seq_gen hnorm k - newton_seq_gen hnorm nâ€– â‰¤
      â€–Polynomial.eval a (Polynomial.derivative F)â€– * T_gen p F a ^ 2 ^ n
Result.exception ::
Duper saturated

Testing || Multiset.disjoint_add_right : âˆ€ {Î± : Type u_1} {s t u : Multiset Î±}, Disjoint s (t + u) â†” Disjoint s t âˆ§ Disjoint s u
Result.success

Testing || List.Perm.symm : âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚.Perm lâ‚‚ â†’ lâ‚‚.Perm lâ‚
Result.exception ::
Duper saturated

Testing || CompleteLat.Iso.mk_hom_toFun : âˆ€ {Î± Î² : CompleteLat} (e : â†‘Î± â‰ƒo â†‘Î²) (a : â†‘Î±), (CompleteLat.Iso.mk e).hom.toFun a = e a
Result.success

Testing || PartENat.card_eq_zero_iff_empty : âˆ€ (Î± : Type u_3), PartENat.card Î± = 0 â†” IsEmpty Î±
Result.exception ::
Duper saturated

Testing || NonemptyInterval.pure_fst : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (NonemptyInterval.pure a).toProd.1 = a
Result.success

Testing || AlternatingMap.coe_multilinearMap_injective : âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R N] {Î¹ : Type u_7},
  Function.Injective AlternatingMap.toMultilinearMap
Result.exception ::
Duper saturated

Testing || FreeCommRing.isSupported_sub : âˆ€ {Î± : Type u} {x y : FreeCommRing Î±} {s : Set Î±}, x.IsSupported s â†’ y.IsSupported s â†’ (x - y).IsSupported s
Result.success

Testing || MeasureTheory.ae_of_all : âˆ€ {Î± : Type u_1} {F : Type u_3} [inst : FunLike F (Set Î±) ENNReal] [inst_1 : MeasureTheory.OuterMeasureClass F Î±]
  {p : Î± â†’ Prop} (Î¼ : F), (âˆ€ (a : Î±), p a) â†’ âˆ€áµ (a : Î±) âˆ‚Î¼, p a
Result.success

Testing || CoxeterSystem.not_isRightDescent_iff : âˆ€ {B : Type u_1} {W : Type u_2} [inst : Group W] {M : CoxeterMatrix B} (cs : CoxeterSystem M W) {w : W} {i : B},
  Â¬cs.IsRightDescent w i â†” cs.length (w * cs.simple i) = cs.length w + 1
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || RingHom.liftOfRightInverse_comp_apply : âˆ€ {A : Type u_1} {B : Type u_2} {C : Type u_3} [inst : Ring A] [inst_1 : Ring B] [inst_2 : Ring C] (f : A â†’+* B)
  (f_inv : B â†’ A) (hf : Function.RightInverse f_inv â‡‘f) (g : { g // RingHom.ker f â‰¤ RingHom.ker g }) (x : A),
  ((f.liftOfRightInverse f_inv hf) g) (f x) = â†‘g x
Result.exception ::
Duper saturated

Testing || LinearIndependent.total_ne_of_not_mem_support : âˆ€ {Î¹ : Type u'} {R : Type u_2} {M : Type u_4} {v : Î¹ â†’ M} [inst : Ring R] [inst_1 : AddCommGroup M]
  [inst_2 : _root_.Module R M] [inst_3 : Nontrivial R],
  LinearIndependent R v â†’ âˆ€ {x : Î¹} (f : Î¹ â†’â‚€ R), x âˆ‰ f.support â†’ (Finsupp.linearCombination R v) f â‰  v x
Result.success

Testing || CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso : âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} J] {C : Type uâ‚ƒ} [inst_1 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} C]
  {F G : CategoryTheory.Functor J C} (Î± : G â‰… F),
  (CategoryTheory.Limits.Cocones.precomposeEquivalence Î±).unitIso =
    CategoryTheory.NatIso.ofComponents
      (fun s =>
        CategoryTheory.Limits.Cocones.ext
          (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) â‹¯)
      â‹¯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€
  (naturality :
    autoParam
      (âˆ€ {X Y : CategoryTheory.Limits.Cocone F} (f : X âŸ¶ Y),
        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).map f)
            (CategoryTheory.Limits.Cocones.ext
                (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj Y).pt)
                â‹¯).hom =
          CategoryTheory.CategoryStruct.comp
            (CategoryTheory.Limits.Cocones.ext
                (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj X).pt) â‹¯).hom
            (((CategoryTheory.Limits.Cocones.precompose Î±.hom).comp
                  (CategoryTheory.Limits.Cocones.precompose Î±.inv)).map
              f))
      _autoâœ),
  (CategoryTheory.Limits.Cocones.precomposeEquivalence Î±).unitIso =
    CategoryTheory.NatIso.ofComponents
      (fun s =>
        CategoryTheory.Limits.Cocones.ext
          (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) â‹¯)
      naturality, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || AntivaryOn.of_neg_right : âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : OrderedAddCommGroup Î±] [inst_1 : OrderedAddCommGroup Î²]
  {s : Set Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²}, AntivaryOn f (-g) s â†’ MonovaryOn f g s
Result.exception ::
Duper saturated

Testing || DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul : âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDedekindDomain R] [inst_2 : Field K]
  [inst_3 : Algebra R K] [inst_4 : IsFractionRing R K] {x y : DedekindDomain.ProdAdicCompletions R K},
  x.IsFiniteAdele â†’ y.IsFiniteAdele â†’ (x * y).IsFiniteAdele
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: DedekindDomain.ProdAdicCompletions R K is not a `âˆ€`

Testing || Int.bitwise_or : Int.bitwise or = Int.lor
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.eventuallyLE_congr : âˆ€ {Î± : Type u} {Î² : Type v} [inst : LE Î²] {l : Filter Î±} {f f' g g' : Î± â†’ Î²},
  f =á¶ [l] f' â†’ g =á¶ [l] g' â†’ (f â‰¤á¶ [l] g â†” f' â‰¤á¶ [l] g')
Result.success

Testing || ProbabilityTheory.Kernel.compProd_apply : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Î³ : Type u_3}
  {mÎ³ : MeasurableSpace Î³} {s : Set (Î² Ã— Î³)},
  MeasurableSet s â†’
    âˆ€ (Îº : ProbabilityTheory.Kernel Î± Î²) [inst : ProbabilityTheory.IsSFiniteKernel Îº]
      (Î· : ProbabilityTheory.Kernel (Î± Ã— Î²) Î³) [inst : ProbabilityTheory.IsSFiniteKernel Î·] (a : Î±),
      ((Îº.compProd Î·) a) s = âˆ«â» (b : Î²), (Î· (a, b)) {c | (b, c) âˆˆ s} âˆ‚Îº a
Result.success

Testing || List.cons_head!_tail : âˆ€ {Î± : Type u} [inst : Inhabited Î±] {l : List Î±}, l â‰  [] â†’ l.head! :: l.tail = l
Result.success

Testing || hasSum_geometric_of_abs_lt_one : âˆ€ {r : â„}, |r| < 1 â†’ HasSum (fun n => r ^ n) (1 - r)â»Â¹
Result.success

Testing || PolynomialModule.eval_map' : âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  (f : M â†’â‚—[R] M) (q : PolynomialModule R M) (r : R),
  (PolynomialModule.eval r) ((PolynomialModule.map R f) q) = f ((PolynomialModule.eval r) q)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WittVector.mul_polyOfInterest_aux1 : âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•),
  âˆ‘ i âˆˆ Finset.range (n + 1), â†‘p ^ i * WittVector.wittMul p i ^ p ^ (n - i) = WittVector.wittPolyProd p n
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.Tendsto.inv_tendsto_zero : âˆ€ {ğ•œ : Type u_1} {Î± : Type u_2} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]
  {l : Filter Î±} {f : Î± â†’ ğ•œ}, Filter.Tendsto f l (nhdsWithin 0 (Set.Ioi 0)) â†’ Filter.Tendsto fâ»Â¹ l Filter.atTop
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearOrderedField.toInv`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submodule.convex : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E] [inst_2 : _root_.Module ğ•œ E]
  (K : Submodule ğ•œ E), Convex ğ•œ â†‘K
Result.exception ::
Duper saturated

Testing || Submodule.quotientPi_apply : âˆ€ {Î¹ : Type u_1} {R : Type u_2} [inst : CommRing R] {Ms : Î¹ â†’ Type u_3} [inst_1 : (i : Î¹) â†’ AddCommGroup (Ms i)]
  [inst_2 : (i : Î¹) â†’ _root_.Module R (Ms i)] [inst_3 : Fintype Î¹] [inst_4 : DecidableEq Î¹]
  (p : (i : Î¹) â†’ Submodule R (Ms i)) (a : ((i : Î¹) â†’ Ms i) â§¸ Submodule.pi Set.univ p) (i : Î¹),
  (Submodule.quotientPi p) a i = (Submodule.quotientPiLift p (fun i => (p i).mkQ) â‹¯) a i
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || FirstOrder.Language.Formula.equivSentence_inf : âˆ€ {L : FirstOrder.Language} {Î± : Type u'} (Ï† Ïˆ : L.Formula Î±),
  FirstOrder.Language.Formula.equivSentence (Ï† âŠ“ Ïˆ) =
    FirstOrder.Language.Formula.equivSentence Ï† âŠ“ FirstOrder.Language.Formula.equivSentence Ïˆ
Result.success

Testing || TrivSqZeroExt.isUnit_or_isNilpotent : âˆ€ {R : Type u_1} {M : Type u_2} [inst : DivisionSemiring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  [inst_3 : _root_.Module Ráµáµ’áµ– M] [inst_4 : SMulCommClass R Ráµáµ’áµ– M] (a : TrivSqZeroExt R M), IsUnit a âˆ¨ IsNilpotent a
Result.success

Testing || ZMod.val_add_of_le : âˆ€ {n : â„•} [inst : NeZero n] {a b : ZMod n}, n â‰¤ a.val + b.val â†’ (a + b).val = a.val + b.val - n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `PartialOrder.toPreorder`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MvPowerSeries.order_le : âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : Semiring R] {f : MvPowerSeries Ïƒ R} {d : Ïƒ â†’â‚€ â„•},
  (MvPowerSeries.coeff R d) f â‰  0 â†’ f.order â‰¤ â†‘d.degree
Result.success

Testing || AffineMap.snd_linear : âˆ€ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]
  [inst_1 : AddCommGroup V1] [inst_2 : _root_.Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]
  [inst_5 : _root_.Module k V2] [inst_6 : AddTorsor V2 P2], AffineMap.snd.linear = LinearMap.snd k V1 V2
Result.success

Testing || LinearEquiv.coe_coe : âˆ€ {R : Type u_1} {S : Type u_5} {M : Type u_6} {Mâ‚‚ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] {module_M : _root_.Module R M}
  {module_S_Mâ‚‚ : _root_.Module S Mâ‚‚} {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} {reâ‚ : RingHomInvPair Ïƒ Ïƒ'}
  {reâ‚‚ : RingHomInvPair Ïƒ' Ïƒ} (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚), â‡‘â†‘e = â‡‘e
Result.success

Testing || LinearEquiv.sumArrowLequivProdArrow_symm_apply_inr : âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {Î± : Type u_5}
  {Î² : Type u_6} (f : Î± â†’ M) (g : Î² â†’ M) (b : Î²),
  (LinearEquiv.sumArrowLequivProdArrow Î± Î² R M).symm (f, g) (Sum.inr b) = g b
Result.success

Testing || Finset.Nontrivial.pow : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : CancelMonoid Î±] {s : Finset Î±},
  s.Nontrivial â†’ âˆ€ {n : â„•}, n â‰  0 â†’ (s ^ n).Nontrivial
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Affine.Point.some_add_some_of_Yne : âˆ€ {F : Type u} [inst : Field F] {W : WeierstrassCurve.Affine F} {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : F} {hâ‚ : W.Nonsingular xâ‚ yâ‚}
  {hâ‚‚ : W.Nonsingular xâ‚‚ yâ‚‚} (hy : yâ‚ â‰  W.negY xâ‚‚ yâ‚‚),
  WeierstrassCurve.Affine.Point.some hâ‚ + WeierstrassCurve.Affine.Point.some hâ‚‚ = WeierstrassCurve.Affine.Point.some â‹¯
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || isCoprime_mul_unit_right_left : âˆ€ {R : Type u_1} [inst : CommSemiring R] {x : R}, IsUnit x â†’ âˆ€ (y z : R), IsCoprime (y * x) z â†” IsCoprime y z
Result.success

Testing || ciInf_le_of_le' : âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : ConditionallyCompleteLinearOrderBot Î±] {f : Î¹ â†’ Î±} {a : Î±} (c : Î¹),
  f c â‰¤ a â†’ iInf f â‰¤ a
Result.success

Testing || RingHom.map_mulVec : âˆ€ {m : Type u_2} {n : Type u_3} {R : Type u_7} {S : Type u_8} [inst : Fintype n] [inst_1 : NonAssocSemiring R]
  [inst_2 : NonAssocSemiring S] (f : R â†’+* S) (M : Matrix m n R) (v : n â†’ R) (i : m),
  f (M.mulVec v i) = (M.map â‡‘f).mulVec (â‡‘f âˆ˜ v) i
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n R is not a `âˆ€`

Testing || Ordinal.dvd_of_mod_eq_zero : âˆ€ {a b : Ordinal.{u_4}}, a % b = 0 â†’ b âˆ£ a
Result.exception ::
Duper saturated

Testing || Profinite.projective_of_extrDisc : âˆ€ {X : Profinite}, ExtremallyDisconnected â†‘X.toTop â†’ CategoryTheory.Projective X
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_5
    x_0).topologicalSpace_coe`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FirstOrder.Language.Substructure.mem_inf : âˆ€ {L : FirstOrder.Language} {M : Type w} [inst : L.Structure M] {p p' : L.Substructure M} {x : M},
  x âˆˆ p âŠ“ p' â†” x âˆˆ p âˆ§ x âˆˆ p'
Result.exception ::
Duper saturated

Testing || ModuleCat.ExtendScalars.map'_id : âˆ€ {R : Type uâ‚} {S : Type uâ‚‚} [inst : CommRing R] [inst_1 : CommRing S] (f : R â†’+* S) {M : ModuleCat R},
  ModuleCat.ExtendScalars.map' f (CategoryTheory.CategoryStruct.id M) =
    CategoryTheory.CategoryStruct.id (ModuleCat.ExtendScalars.obj' f M)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Real.sin_zero : Real.sin 0 = 0
Result.exception ::
Duper saturated

Testing || CategoryTheory.Sigma.inclCompMap_inv_app : âˆ€ {I : Type wâ‚} (C : I â†’ Type uâ‚) [inst : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)] {J : Type wâ‚‚} (g : J â†’ I)
  (j : J) (X : C (g j)), (CategoryTheory.Sigma.inclCompMap C g j).inv.app X = CategoryTheory.CategoryStruct.id âŸ¨g j, XâŸ©
Result.success

Testing || div_mul_cancel_left : âˆ€ {G : Type u_3} [inst : CommGroup G] (a b : G), a / (a * b) = bâ»Â¹
Result.success

Testing || AlgebraicGeometry.IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux : âˆ€ {X Y U : AlgebraicGeometry.Scheme} (f : Y âŸ¶ U) (g : U âŸ¶ X) (fg : Y âŸ¶ X),
  fg = CategoryTheory.CategoryStruct.comp f g â†’
    âˆ€ [h : AlgebraicGeometry.IsOpenImmersion g] (V : U.Opens),
      (TopologicalSpace.Opens.map f.base).obj V =
        (TopologicalSpace.Opens.map fg.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor g).obj V)
Result.exception ::
Duper saturated

Testing || MeasureTheory.OuterMeasure.mkMetric_top : âˆ€ {X : Type u_2} [inst : EMetricSpace X], (MeasureTheory.OuterMeasure.mkMetric fun x => âŠ¤) = âŠ¤
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type 0 < râœ of Î» binder contains bound variables

Testing || Std.DHashMap.Internal.Rawâ‚€.getKey?_eq_none : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} (m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²) [inst : BEq Î±] [inst_1 : Hashable Î±]
  [inst_2 : EquivBEq Î±] [inst_3 : LawfulHashable Î±], (â†‘m).WF â†’ âˆ€ {a : Î±}, m.contains a = false â†’ m.getKey? a = none
Result.success

Testing || WithTop.pow_right_strictMono : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : CanonicallyOrderedCommSemiring Î±] [inst_2 : PosMulStrictMono Î±]
  [inst_3 : NoZeroDivisors Î±] [inst_4 : Nontrivial Î±] {n : â„•}, n â‰  0 â†’ StrictMono fun a => a ^ n
Result.exception ::
Duper saturated

Testing || ofBoolRing_symm_eq : âˆ€ {Î± : Type u_1}, ofBoolRing.symm = toBoolRing
Result.success

Testing || MvPolynomial.C_dvd_iff_zmod : âˆ€ {Ïƒ : Type u_1} (n : â„•) (Ï† : MvPolynomial Ïƒ â„¤),
  MvPolynomial.C â†‘n âˆ£ Ï† â†” (MvPolynomial.map (Int.castRingHom (ZMod n))) Ï† = 0
Result.exception ::
Duper saturated

Testing || CategoryTheory.MonoidalCategory.whiskerLeftIso_trans : âˆ€ {C : Type u} [ğ’ : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (W : C) {X Y Z : C}
  (f : X â‰… Y) (g : Y â‰… Z),
  CategoryTheory.MonoidalCategory.whiskerLeftIso W (f â‰ªâ‰« g) =
    CategoryTheory.MonoidalCategory.whiskerLeftIso W f â‰ªâ‰« CategoryTheory.MonoidalCategory.whiskerLeftIso W g
Result.exception ::
Duper saturated

Testing || EReal.coe_ennreal_le_coe_ennreal_iff : âˆ€ {x y : ENNReal}, â†‘x â‰¤ â†‘y â†” x â‰¤ y
Result.success

Testing || NonUnitalSubring.coe_bot : âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R], â†‘âŠ¥ = {0}
Result.success

Testing || innerDualCone_eq_iInter_innerDualCone_singleton : âˆ€ {H : Type u_1} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace â„ H] (s : Set H),
  â†‘s.innerDualCone = â‹‚ i, â†‘{â†‘i}.innerDualCone
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type { x // x âˆˆ x_0 } of Î» binder contains bound variables

Testing || Set.iUnion_sub_left_image : âˆ€ {Î± : Type u_2} [inst : Sub Î±] {s t : Set Î±}, â‹ƒ a âˆˆ s, (fun x => a - x) '' t = s - t
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a âˆˆ s of Î» binder contains bound variables

Testing || SetTheory.PGame.lf_of_lf_of_le : âˆ€ {x y z : SetTheory.PGame}, x.LF y â†’ y â‰¤ z â†’ x.LF z
Result.success

Testing || MeasureTheory.eLpNorm_trim_ae : âˆ€ {Î± : Type u_1} {E : Type u_2} {m m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}
  [inst : NormedAddCommGroup E] (hm : m â‰¤ m0) {f : Î± â†’ E},
  MeasureTheory.AEStronglyMeasurable f (Î¼.trim hm) â†’ MeasureTheory.eLpNorm f p (Î¼.trim hm) = MeasureTheory.eLpNorm f p Î¼
Result.exception ::
Duper saturated

Testing || List.Perm.subset : âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚.Perm lâ‚‚ â†’ lâ‚ âŠ† lâ‚‚
Result.exception ::
Duper saturated

Testing || Complex.differentiableAt_cos : âˆ€ {x : â„‚}, DifferentiableAt â„‚ Complex.cos x
Result.exception ::
Duper saturated

Testing || CategoryTheory.Functor.Iteration.truncFunctor_obj : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {Î¦ : CategoryTheory.Functor C C}
  (Îµ : CategoryTheory.Functor.id C âŸ¶ Î¦) {J : Type u} {j : J} [inst_1 : Preorder J] [inst_2 : OrderBot J]
  [inst_3 : SuccOrder J] {i : J} (hi : i â‰¤ j) (iter : CategoryTheory.Functor.Iteration Îµ j),
  (CategoryTheory.Functor.Iteration.truncFunctor Îµ hi).obj iter = iter.trunc hi
Result.success

Testing || RelEmbedding.map_rel_iff : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} (f : r â†ªr s) {a b : Î±}, s (f a) (f b) â†” r a b
Result.success

Testing || SymAlg.sym_ne_zero_iff : âˆ€ {Î± : Type u_1} [inst : _root_.Zero Î±] (a : Î±), SymAlg.sym a â‰  0 â†” a â‰  0
Result.success

Testing || AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber : âˆ€ {R : Type u_1} [inst : CommRing R] {x y : PrimeSpectrum R} (h : x â¤³ y),
  CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)
      (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) =
    CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R y)
      (let_fun this := PrimeSpectrum.localizationMapOfSpecializes h;
      this)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Complex.abs_im_eq_abs : âˆ€ {z : â„‚}, |z.im| = Complex.abs z â†” z.re = 0
Result.success

Testing || Ordinal.principal_swap_iff : âˆ€ {o : Ordinal.{u}} {op : Ordinal.{u} â†’ Ordinal.{u} â†’ Ordinal.{u}},
  Ordinal.Principal (Function.swap op) o â†” Ordinal.Principal op o
Result.exception ::
Duper saturated

Testing || MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq : âˆ€ {Î© : Type u_1} {E : Type u_2} {m : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : NormedAddCommGroup E]
  [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {Î¹ : Type u_3} [inst_3 : LinearOrder Î¹]
  [inst_4 : TopologicalSpace Î¹] [inst_5 : OrderTopology Î¹] [inst_6 : FirstCountableTopology Î¹]
  {â„± : MeasureTheory.Filtration Î¹ m} [inst_7 : MeasureTheory.SigmaFiniteFiltration Î¼ â„±] {Ï„ : Î© â†’ Î¹} {f : Î¹ â†’ Î© â†’ E}
  {n : Î¹},
  MeasureTheory.Martingale f â„± Î¼ â†’
    âˆ€ (hÏ„ : MeasureTheory.IsStoppingTime â„± Ï„) (hÏ„_le : âˆ€ (x : Î©), Ï„ x â‰¤ n)
      [inst_8 : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)] (i : Î¹),
      MeasureTheory.stoppedValue f Ï„ =áµ[Î¼.restrict {x | Ï„ x = i}] MeasureTheory.condexp hÏ„.measurableSpace Î¼ (f n)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Set (Set Î©) is not a `âˆ€`

Testing || PartialEquiv.restr_univ : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {e : PartialEquiv Î± Î²}, e.restr Set.univ = e
Result.success

Testing || MeasureTheory.AEFinStronglyMeasurable.ae_nonneg_of_forall_setIntegral_nonneg : âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„},
  MeasureTheory.AEFinStronglyMeasurable f Î¼ â†’
    (âˆ€ (s : Set Î±), MeasurableSet s â†’ Î¼ s < âŠ¤ â†’ MeasureTheory.IntegrableOn f s Î¼) â†’
      (âˆ€ (s : Set Î±), MeasurableSet s â†’ Î¼ s < âŠ¤ â†’ 0 â‰¤ âˆ« (x : Î±) in s, f x âˆ‚Î¼) â†’ 0 â‰¤áµ[Î¼] f
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #2, (âˆ€ x1 : #3, (âˆ€ x2 : (#0 â†’ Prop), ((!18 (Î»x3 : #0, (x2 x3)) (!13 (!11 x0 x1))) â†’ ((!18 (Î»x3 : #0, (x2 x3)) (!13 (!11 x0 (!19 x1)))) â†’ (!18 (Î»x3 : #0, (x2 x3)) (!13 x0))))))) is not type correct

Testing || Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.limplies_of_assignmentsInvariant : âˆ€ {n : â„•} (f : Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula n),
  f.AssignmentsInvariant â†’
    Std.Tactic.BVDecide.LRAT.Internal.Limplies (Std.Tactic.BVDecide.LRAT.Internal.PosFin n) f f.assignments
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Square.Hom.comp_Ï„â‚„ : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {sqâ‚ sqâ‚‚ sqâ‚ƒ : CategoryTheory.Square C} (f : sqâ‚.Hom sqâ‚‚)
  (g : sqâ‚‚.Hom sqâ‚ƒ), (f.comp g).Ï„â‚„ = CategoryTheory.CategoryStruct.comp f.Ï„â‚„ g.Ï„â‚„
Result.success

Testing || Eq.congr_left : âˆ€ {Î± : Sort u_1} {x y z : Î±}, x = y â†’ (x = z â†” y = z)
Result.success

Testing || LieAlgebra.exists_isRegular_of_finrank_le_card : âˆ€ (R : Type u_1) (L : Type u_3) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]
  [inst_3 : Module.Finite R L] [inst_4 : Module.Free R L] [inst_5 : IsDomain R],
  â†‘(Module.finrank R L) â‰¤ Cardinal.mk R â†’ âˆƒ x, LieAlgebra.IsRegular R x
Result.exception ::
Duper saturated

Testing || leftInverse_add_left_sub : âˆ€ {G : Type u_3} [inst : AddGroup G] (c : G), Function.LeftInverse (fun x => x + c) fun x => x - c
Result.exception ::
Duper saturated

Testing || MeasurableSpace.generateFrom_measurableSet : âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], MeasurableSpace.generateFrom {s | MeasurableSet s} = inst
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasurableSpace.generateFrom x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure : âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] [inst_5 : LocallyCompactSpace G] (Î¼' Î¼ : MeasureTheory.Measure G)
  [inst_6 : Î¼.IsHaarMeasure] [inst_7 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'] [inst_8 : Î¼'.IsMulLeftInvariant]
  {s : Set G}, IsCompact (closure s) â†’ Î¼' s = Î¼'.haarScalarFactor Î¼ â€¢ Î¼ s
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasurableSet (cifvar_24 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Profinite.NobelingProof.GoodProducts.linearIndependentAux : âˆ€ {I : Type u} [inst : LinearOrder I] [inst_1 : WellFoundedLT I] (Î¼ : Ordinal.{u}), Profinite.NobelingProof.P I Î¼
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BddAbove.isBoundedUnder_of_range : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] {f : Filter Î²} {u : Î² â†’ Î±},
  BddAbove (Set.range u) â†’ Filter.IsBoundedUnder (fun x1 x2 => x1 â‰¤ x2) f u
Result.success

Testing || FractionalIdeal.num_eq_zero_iff : âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]
  [inst_3 : IsFractionRing R K] [inst_4 : Nontrivial R] {I : FractionalIdeal (nonZeroDivisors R) K}, I.num = 0 â†” I = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `FractionalIdeal.instZero x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.ruzsa_covering_mul : âˆ€ {G : Type u_1} [inst : Group G] {K : â„} [inst_1 : DecidableEq G] {A B : Finset G},
  B.Nonempty â†’ â†‘(A * B).card â‰¤ K * â†‘B.card â†’ âˆƒ F âŠ† A, â†‘F.card â‰¤ K âˆ§ A âŠ† F * (B / B)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLT`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matrix.head_cons : âˆ€ {Î± : Type u} {m : â„•} (x : Î±) (u : Fin m â†’ Î±), Matrix.vecHead (Matrix.vecCons x u) = x
Result.success

Testing || Set.image_neg_Ici : âˆ€ {Î± : Type u_1} [inst : OrderedAddCommGroup Î±] (a : Î±), Neg.neg '' Set.Ici a = Set.Iic (-a)
Result.success

Testing || Set.natCard_div_le : âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, Nat.card â†‘(s / t) â‰¤ Nat.card â†‘s * Nat.card â†‘t
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.mem_disjSum : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Finset Î±} {t : Finset Î²} {x : Î± âŠ• Î²},
  x âˆˆ s.disjSum t â†” (âˆƒ a âˆˆ s, Sum.inl a = x) âˆ¨ âˆƒ b âˆˆ t, Sum.inr b = x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.pseudofunctorOfIsLocallyDiscrete_mapComp : âˆ€ {B : Type u_1} {C : Type u_2} [inst : CategoryTheory.Bicategory B]
  [inst_1 : CategoryTheory.Bicategory.IsLocallyDiscrete B] [inst_2 : CategoryTheory.Bicategory C] (obj : B â†’ C)
  (map : {b b' : B} â†’ (b âŸ¶ b') â†’ (obj b âŸ¶ obj b'))
  (mapId : (b : B) â†’ map (CategoryTheory.CategoryStruct.id b) â‰… CategoryTheory.CategoryStruct.id (obj b))
  (mapComp :
    {bâ‚€ bâ‚ bâ‚‚ : B} â†’
      (f : bâ‚€ âŸ¶ bâ‚) â†’
        (g : bâ‚ âŸ¶ bâ‚‚) â†’
          map (CategoryTheory.CategoryStruct.comp f g) â‰… CategoryTheory.CategoryStruct.comp (map f) (map g))
  (mapâ‚‚_associator :
    autoParam
      (âˆ€ {bâ‚€ bâ‚ bâ‚‚ bâ‚ƒ : B} (f : bâ‚€ âŸ¶ bâ‚) (g : bâ‚ âŸ¶ bâ‚‚) (h : bâ‚‚ âŸ¶ bâ‚ƒ),
        CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom
            (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h))
              (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom
                (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv)
                  (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv))) =
          CategoryTheory.eqToHom â‹¯)
      _autoâœ)
  (mapâ‚‚_left_unitor :
    autoParam
      (âˆ€ {bâ‚€ bâ‚ : B} (f : bâ‚€ âŸ¶ bâ‚),
        CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id bâ‚€) f).hom
            (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId bâ‚€).hom (map f))
              (CategoryTheory.Bicategory.leftUnitor (map f)).hom) =
          CategoryTheory.eqToHom â‹¯)
      _autoâœÂ¹)
  (mapâ‚‚_right_unitor :
    autoParam
      (âˆ€ {bâ‚€ bâ‚ : B} (f : bâ‚€ âŸ¶ bâ‚),
        CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id bâ‚)).hom
            (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId bâ‚).hom)
              (CategoryTheory.Bicategory.rightUnitor (map f)).hom) =
          CategoryTheory.eqToHom â‹¯)
      _autoâœÂ²)
  {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c),
  (CategoryTheory.pseudofunctorOfIsLocallyDiscrete obj map mapId mapComp mapâ‚‚_associator mapâ‚‚_left_unitor
          mapâ‚‚_right_unitor).mapComp
      f g =
    mapComp f g
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Bicategory.homCategory
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Std.DHashMap.getKey_insert_self : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {x : BEq Î±} {x_1 : Hashable Î±} {m : Std.DHashMap Î± Î²} [inst : EquivBEq Î±]
  [inst_1 : LawfulHashable Î±] {k : Î±} {v : Î² k}, (m.insert k v).getKey k â‹¯ = k
Result.exception ::
Duper saturated

Testing || map_symmDiff : âˆ€ {F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : FunLike F Î± Î²] [inst_1 : CoheytingAlgebra Î±]
  [inst_2 : CoheytingAlgebra Î²] [inst_3 : CoheytingHomClass F Î± Î²] (f : F) (a b : Î±),
  f (symmDiff a b) = symmDiff (f a) (f b)
Result.success

Testing || BoundedContinuousFunction.norm_lt_iff_of_compact : âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : SeminormedAddCommGroup Î²] [inst_2 : CompactSpace Î±]
  {f : BoundedContinuousFunction Î± Î²} {M : â„}, 0 < M â†’ (â€–fâ€– < M â†” âˆ€ (x : Î±), â€–f xâ€– < M)
Result.exception ::
Duper saturated

Testing || WithTop.sum_eq_top_iff : âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : AddCommMonoid Î±] {s : Finset Î¹} {f : Î¹ â†’ WithTop Î±},
  âˆ‘ i âˆˆ s, f i = âŠ¤ â†” âˆƒ i âˆˆ s, f i = âŠ¤
Result.success

Testing || Real.le_sSup_iff : âˆ€ {s : Set â„} {a : â„}, BddAbove s â†’ s.Nonempty â†’ (a â‰¤ sSup s â†” âˆ€ Îµ < 0, âˆƒ x âˆˆ s, a + Îµ < x)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Associated.prod : âˆ€ {M : Type u_5} [inst : CommMonoid M] {Î¹ : Type u_6} (s : Finset Î¹) (f g : Î¹ â†’ M),
  (âˆ€ i âˆˆ s, Associated (f i) (g i)) â†’ Associated (âˆ i âˆˆ s, f i) (âˆ i âˆˆ s, g i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.instInsert`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Fin.cycleRange_zero : âˆ€ (n : â„•), Fin.cycleRange 0 = 1
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HolorIndex.cast_type : âˆ€ {dsâ‚ dsâ‚‚ : List â„•} (is : List â„•) (eq : dsâ‚ = dsâ‚‚) (h : List.Forallâ‚‚ (fun x1 x2 => x1 < x2) is dsâ‚),
  â†‘(cast â‹¯ âŸ¨is, hâŸ©) = is
Result.exception ::
Duper saturated

Testing || UpperHalfPlane.coe_mk : âˆ€ (z : â„‚) (h : 0 < z.im), â†‘(UpperHalfPlane.mk z h) = z
Result.success

Testing || Nat.one_lt_pow_iff : âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ {a : â„•}, 1 < a ^ n â†” 1 < a
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.FiniteMeasure.null_iff_toMeasure_null : âˆ€ {Î© : Type u_1} [inst : MeasurableSpace Î©] (Î½ : MeasureTheory.FiniteMeasure Î©) (s : Set Î©), Î½ s = 0 â†” â†‘Î½ s = 0
Result.exception ::
Duper saturated

Testing || min_mul_min_le_min_mul_mul' : âˆ€ {Î± : Type u_1} [inst : Mul Î±] [inst_1 : LinearOrder Î±] [inst_2 : MulLeftMono Î±] [inst_3 : MulRightMono Î±]
  {a b c d : Î±}, (a âŠ“ c) * (b âŠ“ d) â‰¤ a * b âŠ“ c * d
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.smul_sum : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddMonoid Î²] [inst_1 : DistribSMul Î± Î²] {r : Î±} {l : List Î²},
  r â€¢ l.sum = (List.map (fun x => r â€¢ x) l).sum
Result.exception ::
Duper saturated

Testing || LinearMap.compQuadraticMap_polar : âˆ€ {S : Type u_1} {R : Type u_3} {M : Type u_4} {N : Type u_5} [inst : CommRing R] [inst_1 : AddCommGroup M]
  [inst_2 : AddCommGroup N] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R N] {N' : Type u_8}
  [inst_5 : AddCommGroup N'] [inst_6 : CommSemiring S] [inst_7 : Algebra S R] [inst_8 : _root_.Module S N]
  [inst_9 : _root_.Module S N'] [inst_10 : IsScalarTower S R N] [inst_11 : _root_.Module S M]
  [inst_12 : IsScalarTower S R M] (f : N â†’â‚—[S] N') (Q : QuadraticMap R M N) (x y : M),
  QuadraticMap.polar (â‡‘(f.compQuadraticMap' Q)) x y = f (QuadraticMap.polar (â‡‘Q) x y)
Result.exception ::
Duper saturated

Testing || lowerBounds_infClosure : âˆ€ {Î± : Type u_2} [inst : SemilatticeInf Î±] (s : Set Î±), lowerBounds (infClosure s) = lowerBounds s
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.lsub_le : âˆ€ {Î¹ : Type u_4} {f : Î¹ â†’ Ordinal.{max u_5 u_4}} {a : Ordinal.{max u_5 u_4}}, (âˆ€ (i : Î¹), f i < a) â†’ Ordinal.lsub f â‰¤ a
Result.success

Testing || Subsemigroup.comap_top : âˆ€ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M â†’â‚™* N), Subsemigroup.comap f âŠ¤ = âŠ¤
Result.success

Testing || CofiniteTopology.continuous_of : âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], Continuous â‡‘CofiniteTopology.of
Result.success

Testing || LE.le.add_eq_left : âˆ€ {Î± : Type u_1} [inst : IdemSemiring Î±] {a b : Î±}, b â‰¤ a â†’ a + b = a
Result.success

Testing || ContMDiffAt.clm_comp : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {Fâ‚ : Type u_8} [inst_6 : NormedAddCommGroup Fâ‚]
  [inst_7 : NormedSpace ğ•œ Fâ‚] {Fâ‚‚ : Type u_9} [inst_8 : NormedAddCommGroup Fâ‚‚] [inst_9 : NormedSpace ğ•œ Fâ‚‚]
  {Fâ‚ƒ : Type u_10} [inst_10 : NormedAddCommGroup Fâ‚ƒ] [inst_11 : NormedSpace ğ•œ Fâ‚ƒ] {n : â„•âˆ} {g : M â†’ Fâ‚ â†’L[ğ•œ] Fâ‚ƒ}
  {f : M â†’ Fâ‚‚ â†’L[ğ•œ] Fâ‚} {x : M},
  ContMDiffAt I (modelWithCornersSelf ğ•œ (Fâ‚ â†’L[ğ•œ] Fâ‚ƒ)) n g x â†’
    ContMDiffAt I (modelWithCornersSelf ğ•œ (Fâ‚‚ â†’L[ğ•œ] Fâ‚)) n f x â†’
      ContMDiffAt I (modelWithCornersSelf ğ•œ (Fâ‚‚ â†’L[ğ•œ] Fâ‚ƒ)) n (fun x => (g x).comp (f x)) x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.regularTopology.isSheafFor_regular_of_projective : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_5, u_1} C] {X : C} (S : CategoryTheory.Presieve X)
  [inst_1 : S.regular] [inst_2 : CategoryTheory.Projective X] (F : CategoryTheory.Functor Cáµ’áµ– (Type u_4)),
  CategoryTheory.Presieve.IsSheafFor F S
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Y âŸ¶ X of Î» binder contains bound variables

Testing || QuotSMulTop.map_comp : âˆ€ {R : Type u_2} [inst : CommRing R] (r : R) {M : Type u_1} {M' : Type u_3} {M'' : Type u_4} [inst_1 : AddCommGroup M]
  [inst_2 : _root_.Module R M] [inst_3 : AddCommGroup M'] [inst_4 : _root_.Module R M'] [inst_5 : AddCommGroup M'']
  [inst_6 : _root_.Module R M''] (g : M' â†’â‚—[R] M'') (f : M â†’â‚—[R] M'),
  (QuotSMulTop.map r) (g âˆ˜â‚— f) = (QuotSMulTop.map r) g âˆ˜â‚— (QuotSMulTop.map r) f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Submodule.Quotient.addCommGroup
  x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.IntegrableOn.union : âˆ€ {Î± : Type u_1} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s t : Set Î±}
  {Î¼ : MeasureTheory.Measure Î±},
  MeasureTheory.IntegrableOn f s Î¼ â†’ MeasureTheory.IntegrableOn f t Î¼ â†’ MeasureTheory.IntegrableOn f (s âˆª t) Î¼
Result.success

Testing || Int.lt_mul_of_ediv_lt : âˆ€ {a b c : â„¤}, 0 < c â†’ a / c < b â†’ a < b * c
Result.success

Testing || MeasureTheory.SimpleFunc.GCongr.mk_le_mk : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : Preorder Î²] {f g : Î± â†’ Î²}
  {hf : âˆ€ (x : Î²), MeasurableSet (f â»Â¹' {x})} {hg : âˆ€ (x : Î²), MeasurableSet (g â»Â¹' {x})} {hf' : (Set.range f).Finite}
  {hg' : (Set.range g).Finite},
  f â‰¤ g â†’
    { toFun := f, measurableSet_fiber' := hf, finite_range' := hf' } â‰¤
      { toFun := g, measurableSet_fiber' := hg, finite_range' := hg' }
Result.success

Testing || cfcâ‚™HomSuperset_id' : âˆ€ {R : Type u_1} {A : Type u_2} {p : A â†’ Prop} [inst : CommSemiring R] [inst_1 : Nontrivial R] [inst_2 : StarRing R]
  [inst_3 : MetricSpace R] [inst_4 : TopologicalSemiring R] [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A]
  [inst_7 : StarRing A] [inst_8 : TopologicalSpace A] [inst_9 : _root_.Module R A] [inst_10 : IsScalarTower R A A]
  [inst_11 : SMulCommClass R A A] [instCFCâ‚™ : NonUnitalContinuousFunctionalCalculus R p] {a : A} (ha : p a) {s : Set R}
  (hs : quasispectrum R a âŠ† s), (cfcâ‚™HomSuperset ha hs) (ContinuousMapZero.id â‹¯) = a
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: quasispectrum R a âŠ† s is not a `âˆ€`

Testing || ContinuousMap.sup_mem_subalgebra_closure : âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (A : Subalgebra â„ C(X, â„)) (f g : â†¥A),
  â†‘f âŠ” â†‘g âˆˆ A.topologicalClosure
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsFractionRing.associated_num_den_inv : âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A] {K : Type u_2}
  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] (x : K),
  x â‰  0 â†’ Associated (IsFractionRing.num A x) â†‘(IsFractionRing.den A xâ»Â¹)
Result.success

Testing || Con.le_comap_conGen : âˆ€ {M : Type u_4} {N : Type u_5} [inst : Mul M] [inst_1 : Mul N] (f : M â†’ N) (H : âˆ€ (x y : M), f (x * y) = f x * f y)
  (rel : N â†’ N â†’ Prop), (conGen fun x y => rel (f x) (f y)) â‰¤ Con.comap f H (conGen rel)
Result.exception ::
Duper saturated

Testing || TopologicalSpace.CompactOpens.coe_mk : âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (s : TopologicalSpace.Compacts Î±) (h : IsOpen s.carrier),
  â†‘{ toCompacts := s, isOpen' := h } = â†‘s
Result.success

Testing || Metric.cthickening_thickening_subset : âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {Îµ : â„},
  0 â‰¤ Îµ â†’ âˆ€ (Î´ : â„) (s : Set Î±), Metric.cthickening Îµ (Metric.thickening Î´ s) âŠ† Metric.cthickening (Îµ + Î´) s
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instHAdd`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || mul_right_eq_selfâ‚€ : âˆ€ {Mâ‚€ : Type u_1} [inst : CancelMonoidWithZero Mâ‚€] {a b : Mâ‚€}, a * b = a â†” b = 1 âˆ¨ a = 0
Result.success

Testing || AlgHom.ker_rangeRestrict : âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  [inst_3 : Semiring B] [inst_4 : Algebra R B] (f : A â†’â‚[R] B), RingHom.ker f.rangeRestrict = RingHom.ker f
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AlgHom.map_smul_of_tower : âˆ€ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]
  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (Ï† : A â†’â‚[R] B) {R' : Type u_1} [inst_5 : SMul R' A]
  [inst_6 : SMul R' B] [inst_7 : LinearMap.CompatibleSMul A B R' R] (r : R') (x : A), Ï† (r â€¢ x) = r â€¢ Ï† x
Result.exception ::
Duper saturated

Testing || wellFoundedGT_antisymmetrization_iff : âˆ€ {Î± : Type u_1} [inst : Preorder Î±], WellFoundedGT (Antisymmetrization Î± fun x1 x2 => x1 â‰¤ x2) â†” WellFoundedGT Î±
Result.exception ::
Duper saturated

Testing || frontier_Icc : âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]
  [inst_3 : DenselyOrdered Î±] [inst_4 : NoMinOrder Î±] [inst_5 : NoMaxOrder Î±] {a b : Î±},
  a â‰¤ b â†’ frontier (Set.Icc a b) = {a, b}
Result.success

Testing || Set.compl_singleton_eq : âˆ€ {Î± : Type u} (a : Î±), {a}á¶œ = {x | x â‰  a}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, ((!3 (!1 x0)) = (!1 x0))) is not type correct

Testing || ContinuousMap.dist_le_iff_of_nonempty : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]
  {f g : C(Î±, Î²)} {C : â„} [inst_3 : Nonempty Î±], dist f g â‰¤ C â†” âˆ€ (x : Î±), dist (f x) (g x) â‰¤ C
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.IsFundamentalDomain.measure_ne_zero : âˆ€ {G : Type u_1} {Î± : Type u_3} [inst : Group G] [inst_1 : MulAction G Î±] [inst_2 : MeasurableSpace Î±] {s : Set Î±}
  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : Countable G] [inst_4 : MeasureTheory.SMulInvariantMeasure G Î± Î¼],
  Î¼ â‰  0 â†’ MeasureTheory.IsFundamentalDomain G s Î¼ â†’ Î¼ s â‰  0
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #2, (âˆ€ x1 : #1, ((!5 x0 x1) â†’ (!12 (!13 x1) (!14 (Î»x2 : #6, (!15 x2 x0))) !10)))) is not type correct

Testing || AffineSubspace.sOppSide_lineMap_right : âˆ€ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : LinearOrderedField R] [inst_1 : AddCommGroup V]
  [inst_2 : _root_.Module R V] [inst_3 : AddTorsor V P] {s : AffineSubspace R P} {x y : P},
  x âˆˆ s â†’ y âˆ‰ s â†’ âˆ€ {t : R}, t < 0 â†’ s.SOppSide y ((AffineMap.lineMap x y) t)
Result.success

Testing || Projectivization.map_injective : âˆ€ {K : Type u_1} {V : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]
  {L : Type u_3} {W : Type u_4} [inst_3 : DivisionRing L] [inst_4 : AddCommGroup W] [inst_5 : _root_.Module L W]
  {Ïƒ : K â†’+* L} {Ï„ : L â†’+* K} [inst_6 : RingHomInvPair Ïƒ Ï„] (f : V â†’â‚›â‚—[Ïƒ] W) (hf : Function.Injective â‡‘f),
  Function.Injective (Projectivization.map f hf)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Submodule.le_comap_single_pi : âˆ€ {R : Type u} {Î¹ : Type x} [inst : Semiring R] {Ï† : Î¹ â†’ Type u_1} [inst_1 : (i : Î¹) â†’ AddCommMonoid (Ï† i)]
  [inst_2 : (i : Î¹) â†’ _root_.Module R (Ï† i)] [inst_3 : DecidableEq Î¹] (p : (i : Î¹) â†’ Submodule R (Ï† i)) {i : Î¹},
  p i â‰¤ Submodule.comap (LinearMap.single R Ï† i) (Submodule.pi Set.univ p)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1 x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || deriv_update : âˆ€ {ğ•œ : Type u_1} {Î¹ : Type u_2} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] [inst_2 : NontriviallyNormedField ğ•œ]
  (x : Î¹ â†’ ğ•œ) (i : Î¹) (y : ğ•œ), deriv (Function.update x i) y = Pi.single i 1
Result.success

Testing || Submonoid.map_iInf : âˆ€ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_4} [inst_2 : FunLike F M N]
  [mc : MonoidHomClass F M N] {Î¹ : Sort u_5} [inst_3 : Nonempty Î¹] (f : F),
  Function.Injective â‡‘f â†’ âˆ€ (s : Î¹ â†’ Submonoid M), Submonoid.map f (iInf s) = â¨… i, Submonoid.map f (s i)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Combinatorics.Subspace.coe_apply : âˆ€ {Î· : Type u_5} {Î± : Type u_6} {Î¹ : Type u_7} (l : Combinatorics.Subspace Î· Î± Î¹) (x : Î· â†’ Î±) (i : Î¹),
  â†‘l x i = Sum.elim id x (l.idxFun i)
Result.success

Testing || FreeSemigroup.ext : âˆ€ {Î± : Type u} {x y : FreeSemigroup Î±}, x.head = y.head â†’ x.tail = y.tail â†’ x = y
Result.exception ::
Duper saturated

Testing || SetTheory.PGame.one_leftMoves : SetTheory.PGame.LeftMoves 1 = PUnit.{u_1 + 1}
Result.success

Testing || OrderIso.equivalence_unitIso : âˆ€ {X : Type u} {Y : Type v} [inst : Preorder X] [inst_1 : Preorder Y] (e : X â‰ƒo Y),
  e.equivalence.unitIso = CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso â‹¯) â‹¯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€
  (naturality :
    autoParam
      (âˆ€ {X_1 Y_1 : X} (f : X_1 âŸ¶ Y_1),
        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.id X).map f) (CategoryTheory.eqToIso â‹¯).hom =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToIso â‹¯).hom ((â‹¯.functor.comp â‹¯.functor).map f))
      _autoâœ),
  e.equivalence.unitIso =
    CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso â‹¯)
      naturality, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || Module.reflection_apply : âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {x : M}
  {f : Module.Dual R M} (y : M) (h : f x = 2), (Module.reflection h) y = y - f y â€¢ x
Result.success

Testing || CategoryTheory.ComonadHom.ext' : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {Tâ‚ Tâ‚‚ : CategoryTheory.Comonad C} (f g : Tâ‚ âŸ¶ Tâ‚‚),
  f.app = g.app â†’ f = g
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_5 x_0).app`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NumberField.InfinitePlace.comap_surjective : âˆ€ {k : Type u_1} [inst : Field k] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra k K]
  [inst_3 : Algebra.IsAlgebraic k K], Function.Surjective fun x => x.comap (algebraMap k K)
Result.exception ::
Duper saturated

Testing || Substring.ValidFor.drop : âˆ€ {l m r : List Char} {s : Substring},
  Substring.ValidFor l m r s â†’ âˆ€ (n : â„•), Substring.ValidFor (l ++ List.take n m) (List.drop n m) r (s.drop n)
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ZMod.pow_div_two_eq_neg_one_or_one : âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CauchyFilter.denseRange_pureCauchy : âˆ€ {Î± : Type u} [inst : UniformSpace Î±], DenseRange CauchyFilter.pureCauchy
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || mem_tangentCone_of_openSegment_subset : âˆ€ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {s : Set G} {x y : G},
  openSegment â„ x y âŠ† s â†’ y - x âˆˆ tangentConeAt â„ s x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Î¨â‚‚Sq_eq : âˆ€ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R), W.Î¨â‚‚Sq = W.twoTorsionPolynomial.toPoly
Result.success

Testing || Monoid.exponent_pos : âˆ€ {G : Type u} [inst : Monoid G], 0 < Monoid.exponent G â†” Monoid.ExponentExists G
Result.success

Testing || Nat.clog_of_two_le : âˆ€ {b n : â„•}, 1 < b â†’ 2 â‰¤ n â†’ Nat.clog b n = Nat.clog b ((n + b - 1) / b) + 1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_1.decLt x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NonemptyInterval.fst_nsmul : âˆ€ {Î± : Type u_2} [inst : AddMonoid Î±] [inst_1 : Preorder Î±] [inst_2 : AddLeftMono Î±] [inst_3 : AddRightMono Î±]
  (s : NonemptyInterval Î±) (n : â„•), (n â€¢ s).toProd.1 = n â€¢ s.toProd.1
Result.success

Testing || AddSubgroup.comap.proof_1 : âˆ€ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N], AddMonoidHomClass (G â†’+ N) G N
Result.exception ::
Duper saturated

Testing || Order.pred_iterate_le : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : PredOrder Î±] (k : â„•) (x : Î±), Order.pred^[k] x â‰¤ x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Order.pred`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || OrderHom.map_lfp_comp : âˆ€ {Î± : Type u} {Î² : Type v} [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (f : Î² â†’o Î±) (g : Î± â†’o Î²),
  f (OrderHom.lfp (g.comp f)) = OrderHom.lfp (f.comp g)
Result.exception ::
Duper saturated

Testing || Subgroup.le_topologicalClosure : âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (s : Subgroup G),
  s â‰¤ s.topologicalClosure
Result.success

Testing || CategoryTheory.Functor.mapHomotopyCategory_obj : âˆ€ {Î¹ : Type u_2} {V : Type u} [inst : CategoryTheory.Category.{v, u} V] [inst_1 : CategoryTheory.Preadditive V]
  {W : Type u_3} [inst_2 : CategoryTheory.Category.{u_4, u_3} W] [inst_3 : CategoryTheory.Preadditive W]
  (F : CategoryTheory.Functor V W) [inst_4 : F.Additive] (c : ComplexShape Î¹)
  (a : CategoryTheory.Quotient (homotopic V c)),
  (F.mapHomotopyCategory c).obj a = (HomotopyCategory.quotient W c).obj ((F.mapHomologicalComplex c).obj a.as)
Result.success

Testing || list_sum_mem : âˆ€ {M : Type u_1} {B : Type u_3} [inst : AddMonoid M] [inst_1 : SetLike B M] [inst_2 : AddSubmonoidClass B M] {S : B}
  {l : List M}, (âˆ€ x âˆˆ l, x âˆˆ S) â†’ l.sum âˆˆ S
Result.exception ::
Duper saturated

Testing || Codisjoint.symm : âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] â¦ƒa b : Î±â¦„, Codisjoint a b â†’ Codisjoint b a
Result.success

Testing || Nat.succ_iterate : âˆ€ (a n : â„•), Nat.succ^[n] a = a + n
Result.success

Testing || Lean.Omega.Int.lt_of_not_le : âˆ€ {x y : â„¤}, Â¬x â‰¤ y â†’ y < x
Result.success

Testing || Matrix.mul_submatrix_one : âˆ€ {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Î± : Type v} [inst : Fintype n] [inst_1 : Finite o]
  [inst_2 : NonAssocSemiring Î±] [inst_3 : DecidableEq o] (eâ‚ : n â‰ƒ o) (eâ‚‚ : l â†’ o) (M : Matrix m n Î±),
  M * Matrix.submatrix 1 (â‡‘eâ‚) eâ‚‚ = M.submatrix id (â‡‘eâ‚.symm âˆ˜ eâ‚‚)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n Î± is not a `âˆ€`

Testing || QuadraticModuleCat.toIsometry_id : âˆ€ {R : Type u} [inst : CommRing R] {M : QuadraticModuleCat R},
  (CategoryTheory.CategoryStruct.id M).toIsometry = QuadraticMap.Isometry.id M.form
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€
  (map_app' : âˆ€ (m : â†‘M.toModuleCat), M.form (LinearMap.id.toFun m) = M.form m),
  QuadraticMap.Isometry.id M.form =
    { toLinearMap := LinearMap.id, map_app' := map_app' }, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || InnerProductSpace.Core.inner_sub_left : âˆ€ {ğ•œ : Type u_1} {F : Type u_3} [inst : RCLike ğ•œ] [inst_1 : AddCommGroup F] [inst_2 : _root_.Module ğ•œ F]
  [c : PreInnerProductSpace.Core ğ•œ F] (x y z : F), inner (x - y) z = inner x z - inner y z
Result.success

Testing || Nat.mul_lt_mul_of_lt_of_le' : âˆ€ {a c b d : â„•}, a < c â†’ b â‰¤ d â†’ 0 < b â†’ a * b < c * d
Result.success

Testing || SmoothPartitionOfUnity.toPartitionOfUnity_toFun : âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners â„ E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : Set M} (f : SmoothPartitionOfUnity Î¹ I M s) (i : Î¹), f.toPartitionOfUnity i = â†‘(f i)
Result.success

Testing || Submodule.quotDualCoannihilatorToDual_apply : âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  (W : Submodule R (Module.Dual R M)) (m : M) (w : â†¥W),
  (W.quotDualCoannihilatorToDual (Submodule.Quotient.mk m)) w = â†‘w m
Result.success

Testing || IsCompact.nhdsSet_inf_eq_biSup : âˆ€ {X : Type u} [inst : TopologicalSpace X] {K : Set X},
  IsCompact K â†’ âˆ€ (l : Filter X), nhdsSet K âŠ“ l = â¨† x âˆˆ K, nhds x âŠ“ l
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x âˆˆ K of Î» binder contains bound variables

Testing || exists_disjoint_smul_of_isCompact : âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]
  {K L : Set G}, IsCompact K â†’ IsCompact L â†’ âˆƒ g, Disjoint K (g â€¢ L)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.inv`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || exists_setIndependent_of_sSup_atoms_eq_top : âˆ€ {Î± : Type u_2} [inst : CompleteLattice Î±] [inst_1 : IsModularLattice Î±] [inst_2 : IsCompactlyGenerated Î±],
  sSup {a | IsAtom a} = âŠ¤ â†’ âˆƒ s, sSupIndep s âˆ§ sSup s = âŠ¤ âˆ§ âˆ€ â¦ƒa : Î±â¦„, a âˆˆ s â†’ IsAtom a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : #0, ((!7 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || NNReal.mk_one : âŸ¨1, â‹¯âŸ© = 1
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (property : 0 â‰¤ 1),
  1 = âŸ¨1, propertyâŸ©, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || leOnePart_le_one' : âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : Group Î±] {a : Î±}, aâ»áµ â‰¤ 1 â†” aâ»Â¹ â‰¤ 1
Result.success

Testing || Functor.mapEquiv_symm_apply : âˆ€ {Î± Î² : Type u} (f : Type u â†’ Type v) [inst : Functor f] [inst_1 : LawfulFunctor f] (h : Î± â‰ƒ Î²) (y : f Î²),
  (Functor.mapEquiv f h).symm y = â‡‘h.symm <$> y
Result.success

Testing || OrderEmbedding.preimage_Ioi : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] (e : Î± â†ªo Î²) (x : Î±),
  â‡‘e â»Â¹' Set.Ioi (e x) = Set.Ioi x
Result.exception ::
Duper saturated

Testing || CentroidHom.toEnd_pow : âˆ€ {Î± : Type u_5} [inst : NonUnitalNonAssocSemiring Î±] (x : CentroidHom Î±) (n : â„•), (x ^ n).toEnd = x.toEnd ^ n
Result.success

Testing || List.ofFn_mul' : âˆ€ {Î± : Type u} {m n : â„•} (f : Fin (m * n) â†’ Î±),
  List.ofFn f = (List.ofFn fun i => List.ofFn fun j => f âŸ¨m * â†‘i + â†‘j, â‹¯âŸ©).flatten
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Fin.prop j`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.iUnion_nonempty_self : âˆ€ {Î± : Type u_1} (s : Set Î±), â‹ƒ (_ : s.Nonempty), s = s
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x âˆˆ s of Î» binder contains bound variables

Testing || CategoryTheory.ShortComplex.RightHomologyMapData.smul_Ï†H : âˆ€ {R : Type u_1} {C : Type u_2} [inst : Semiring R] [inst_1 : CategoryTheory.Category.{u_3, u_2} C]
  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Linear R C] {Sâ‚ Sâ‚‚ : CategoryTheory.ShortComplex C}
  {Ï† : Sâ‚ âŸ¶ Sâ‚‚} {hâ‚ : Sâ‚.RightHomologyData} {hâ‚‚ : Sâ‚‚.RightHomologyData}
  (Î³ : CategoryTheory.ShortComplex.RightHomologyMapData Ï† hâ‚ hâ‚‚) (a : R), (Î³.smul a).Ï†H = a â€¢ Î³.Ï†H
Result.success

Testing || EMetric.ball_mem_nhds : âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] (x : Î±) {Îµ : ENNReal}, 0 < Îµ â†’ EMetric.ball x Îµ âˆˆ nhds x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `EMetric.ball x_1 x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SymplecticGroup.symplectic_det : âˆ€ {l : Type u_1} {R : Type u_2} [inst : DecidableEq l] [inst_1 : Fintype l] [inst_2 : CommRing R]
  {A : Matrix (l âŠ• l) (l âŠ• l) R}, A âˆˆ Matrix.symplecticGroup l R â†’ IsUnit A.det
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix (l âŠ• l) (l âŠ• l) R is not a `âˆ€`

Testing || tendsto_ceil_left_pure_ceil : âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : FloorRing Î±] [inst_2 : TopologicalSpace Î±]
  [inst_3 : OrderClosedTopology Î±] (x : Î±), Filter.Tendsto Int.ceil (nhdsWithin x (Set.Iic x)) (pure âŒˆxâŒ‰)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instDistribLatticeOfLinearOrder`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.cons_induction : âˆ€ {Î± : Type u_3} {p : Finset Î± â†’ Prop},
  p âˆ… â†’ (âˆ€ (a : Î±) (s : Finset Î±) (h : a âˆ‰ s), p s â†’ p (Finset.cons a s h)) â†’ âˆ€ (s : Finset Î±), p s
Result.exception ::
Duper saturated

Testing || MvPolynomial.coe_eq_zero_iff : âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] {Ï† : MvPolynomial Ïƒ R}, â†‘Ï† = 0 â†” Ï† = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MvPolynomial.commSemiring`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Comma.toIdPUnitEquiv_counitIso_hom_app : âˆ€ {B : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B]
  (L : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1}))
  (R : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})) (X : B),
  (CategoryTheory.Comma.toIdPUnitEquiv L R).counitIso.hom.app X = CategoryTheory.CategoryStruct.id X
Result.exception ::
Duper saturated

Testing || aeSeq.prop_of_mem_aeSeqSet : âˆ€ {Î¹ : Sort u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {f : Î¹ â†’ Î± â†’ Î²}
  {Î¼ : MeasureTheory.Measure Î±} {p : Î± â†’ (Î¹ â†’ Î²) â†’ Prop} (hf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼) {x : Î±},
  x âˆˆ aeSeqSet hf p â†’ p x fun n => aeSeq hf p n x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AEMeasurable.mk (cifvar_1 i) â‹¯ x`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Nodup.isCycleOn_formPerm : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] {l : List Î±}, l.Nodup â†’ l.formPerm.IsCycleOn {a | a âˆˆ l}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #3, (âˆ€ x1 : (#3 â†’ Prop), ((!6 (!4 (Î»x2 : #3, (x1 x2))) x0) â†” (x1 x0)))) is not type correct

Testing || CategoryTheory.Limits.image.Î¹_zero' : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}
  {f : X âŸ¶ Y}, f = 0 â†’ âˆ€ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.Î¹ f = 0
Result.exception ::
Duper saturated

Testing || Bornology.IsCobounded.closedBall_compl_subset : âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},
  Bornology.IsCobounded s â†’ âˆ€ (c : Î±), âˆƒ r, (Metric.closedBall c r)á¶œ âŠ† s
Result.success

Testing || Complex.abs_im_lt_abs : âˆ€ {z : â„‚}, |z.im| < Complex.abs z â†” z.re â‰  0
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Trivialization.Prod.continuous_to_fun : âˆ€ {B : Type u_1} [inst : TopologicalSpace B] {Fâ‚ : Type u_2} [inst_1 : TopologicalSpace Fâ‚] {Eâ‚ : B â†’ Type u_3}
  [inst_2 : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)] {Fâ‚‚ : Type u_4} [inst_3 : TopologicalSpace Fâ‚‚]
  {Eâ‚‚ : B â†’ Type u_5} [inst_4 : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)]
  {eâ‚ : Trivialization Fâ‚ Bundle.TotalSpace.proj} {eâ‚‚ : Trivialization Fâ‚‚ Bundle.TotalSpace.proj},
  ContinuousOn (Trivialization.Prod.toFun' eâ‚ eâ‚‚) (Bundle.TotalSpace.proj â»Â¹' (eâ‚.baseSet âˆ© eâ‚‚.baseSet))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `p.snd`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IsGLB.sInf_eq : âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {s : Set Î±} {a : Î±}, IsGLB s a â†’ sInf s = a
Result.success

Testing || le_of_forall_pos_sub_le : âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] [inst_1 : LinearOrder Î±] [inst_2 : AddLeftMono Î±] [inst_3 : DenselyOrdered Î±]
  {a b : Î±}, (âˆ€ (Îµ : Î±), 0 < Îµ â†’ a - Îµ â‰¤ b) â†’ a â‰¤ b
Result.success

Testing || TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : TopCat}
  {â„± ğ’¢ : TopCat.Presheaf C X} [inst_2 : CategoryTheory.Limits.HasColimits C]
  [inst_3 : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] (T : â„± âŸ¶ ğ’¢),
  TopCat.Presheaf.IsLocallySurjective T â†” âˆ€ (x : â†‘X), Function.Surjective â‡‘((TopCat.Presheaf.stalkFunctor C x).map T)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.variableChange_Î” : âˆ€ {R : Type u} [inst : CommRing R] (W : WeierstrassCurve R) (C : WeierstrassCurve.VariableChange R),
  (W.variableChange C).Î” = â†‘C.uâ»Â¹ ^ 12 * W.Î”
Result.exception ::
Duper saturated

Testing || AlgEquiv.toRingEquiv_symm : âˆ€ {R : Type uR} {Aâ‚ : Type uAâ‚} [inst : CommSemiring R] [inst_1 : Semiring Aâ‚] [inst_2 : Algebra R Aâ‚]
  (f : Aâ‚ â‰ƒâ‚[R] Aâ‚), (â†‘f).symm = â†‘f.symm
Result.success

Testing || GenContFract.zeroth_cont_eq_h_one : âˆ€ {K : Type u_1} {g : GenContFract K} [inst : DivisionRing K], g.conts 0 = { a := g.h, b := 1 }
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Stream' (GenContFract.Pair K) is not a `âˆ€`

Testing || List.getElem_drop : âˆ€ {Î± : Type u_1} (L : List Î±) {i j : â„•} {h : j < (List.drop i L).length}, (List.drop i L)[j] = L[i + j]
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (h : i + j < L.length),
  hâœÂ² = â‹¯, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || ContinuousOn.mono_rng : âˆ€ {Î± : Type u_5} {Î² : Type u_6} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},
  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s
Result.exception ::
Duper saturated

Testing || Set.image_mulSingle_uIcc_left : âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î± i)] [inst_1 : DecidableEq Î¹]
  [inst_2 : (i : Î¹) â†’ _root_.One (Î± i)] (i : Î¹) (a : Î± i),
  Pi.mulSingle i '' Set.uIcc a 1 = Set.uIcc (Pi.mulSingle i a) 1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.update x_0 cifvar_5`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || StarAlgebra.elemental.self_mem : âˆ€ (R : Type u_1) {A : Type u_2} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : TopologicalSpace A]
  [inst_3 : Semiring A] [inst_4 : StarRing A] [inst_5 : TopologicalSemiring A] [inst_6 : ContinuousStar A]
  [inst_7 : Algebra R A] [inst_8 : StarModule R A] (x : A), x âˆˆ StarAlgebra.elemental R x
Result.exception ::
Duper saturated

Testing || Ordinal.sub_le_self : âˆ€ (a b : Ordinal.{u_4}), a - b â‰¤ a
Result.exception ::
Duper saturated

Testing || SemiconjBy.pow_right : âˆ€ {M : Type u_2} [inst : Monoid M] {a x y : M}, SemiconjBy a x y â†’ âˆ€ (n : â„•), SemiconjBy a (x ^ n) (y ^ n)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AddSubgroup.quotientEquivSumOfLE'.proof_4 : âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] {s t : AddSubgroup Î±} (f : Î± â§¸ t â†’ Î±) (a : (Î± â§¸ t) Ã— â†¥t â§¸ s.addSubgroupOf t)
  (b c : â†¥t),
  (QuotientAddGroup.leftRel (s.addSubgroupOf t)) b c â†’
    (QuotientAddGroup.leftRel s) ((fun b => f a.1 + â†‘b) b) ((fun b => f a.1 + â†‘b) c)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Order.krullDim_nat : Order.krullDim â„• = âŠ¤
Result.success

Testing || PNat.gcd_comm : âˆ€ {m n : â„•+}, m.gcd n = n.gcd m
Result.exception ::
Duper saturated

Testing || TrivSqZeroExt.map_comp_inlAlgHom : âˆ€ {R' : Type u} {M : Type v} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R' M]
  [inst_3 : _root_.Module R'áµáµ’áµ– M] [inst_4 : IsCentralScalar R' M] {N : Type u_3} [inst_5 : AddCommMonoid N]
  [inst_6 : _root_.Module R' N] [inst_7 : _root_.Module R'áµáµ’áµ– N] [inst_8 : IsCentralScalar R' N] (f : M â†’â‚—[R'] N),
  (TrivSqZeroExt.map f).comp (TrivSqZeroExt.inlAlgHom R' R' M) = TrivSqZeroExt.inlAlgHom R' R' N
Result.exception ::
Duper saturated

Testing || Matrix.toLinearMapâ‚›â‚—â‚‚'_symm : âˆ€ {R : Type u_1} {Râ‚ : Type u_2} {Sâ‚ : Type u_3} {Râ‚‚ : Type u_4} {Sâ‚‚ : Type u_5} {Nâ‚‚ : Type u_10} {n : Type u_11}
  {m : Type u_12} [inst : CommSemiring R] [inst_1 : AddCommMonoid Nâ‚‚] [inst_2 : _root_.Module R Nâ‚‚]
  [inst_3 : Semiring Râ‚] [inst_4 : Semiring Râ‚‚] [inst_5 : Semiring Sâ‚] [inst_6 : Semiring Sâ‚‚]
  [inst_7 : _root_.Module Sâ‚ Nâ‚‚] [inst_8 : _root_.Module Sâ‚‚ Nâ‚‚] [inst_9 : SMulCommClass Sâ‚ R Nâ‚‚]
  [inst_10 : SMulCommClass Sâ‚‚ R Nâ‚‚] [inst_11 : SMulCommClass Sâ‚‚ Sâ‚ Nâ‚‚] (Ïƒâ‚ : Râ‚ â†’+* Sâ‚) (Ïƒâ‚‚ : Râ‚‚ â†’+* Sâ‚‚)
  [inst_12 : Fintype n] [inst_13 : Fintype m] [inst_14 : DecidableEq n] [inst_15 : DecidableEq m],
  (Matrix.toLinearMapâ‚›â‚—â‚‚' R Ïƒâ‚ Ïƒâ‚‚).symm = LinearMap.toMatrixâ‚›â‚—â‚‚' R
Result.success

Testing || AlgebraicGeometry.PresheafedSpace.Hom.ext : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {X Y : AlgebraicGeometry.PresheafedSpace C}
  (Î± Î² : X.Hom Y) (w : Î±.base = Î².base),
  CategoryTheory.CategoryStruct.comp Î±.c (CategoryTheory.whiskerRight (CategoryTheory.eqToHom â‹¯) X.presheaf) = Î².c â†’
    Î± = Î²
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.CategoryStruct.id
  x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DiscreteQuotient.leComap_id_iff : âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {A A' : DiscreteQuotient X},
  DiscreteQuotient.LEComap (ContinuousMap.id X) A A' â†” A â‰¤ A'
Result.success

Testing || String.Pos.mk_le_mk : âˆ€ {iâ‚ iâ‚‚ : â„•}, { byteIdx := iâ‚ } â‰¤ { byteIdx := iâ‚‚ } â†” iâ‚ â‰¤ iâ‚‚
Result.success

Testing || one_div_mul_add_mul_one_div_eq_one_div_add_one_div : âˆ€ {K : Type u_1} [inst : DivisionSemiring K] {a b : K}, a â‰  0 â†’ b â‰  0 â†’ 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b
Result.success

Testing || MeasureTheory.Measure.restrict_add_restrict_compl : âˆ€ {Î± : Type u_2} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},
  MeasurableSet s â†’ Î¼.restrict s + Î¼.restrict sá¶œ = Î¼
Result.success

Testing || SupClosed.preimage : âˆ€ {F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : SemilatticeSup Î±] [inst_1 : SemilatticeSup Î²] {s : Set Î±}
  [inst_2 : FunLike F Î² Î±] [inst_3 : SupHomClass F Î² Î±], SupClosed s â†’ âˆ€ (f : F), SupClosed (â‡‘f â»Â¹' s)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #3, (âˆ€ x1 : #3, ((!8 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || ContMDiffAt.neg : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] {I : ModelWithCorners ğ•œ E H} {G : Type u_4}
  [inst_4 : TopologicalSpace G] [inst_5 : ChartedSpace H G] [inst_6 : AddGroup G] [inst_7 : LieAddGroup I G]
  {E' : Type u_5} [inst_8 : NormedAddCommGroup E'] [inst_9 : NormedSpace ğ•œ E'] {H' : Type u_6}
  [inst_10 : TopologicalSpace H'] {I' : ModelWithCorners ğ•œ E' H'} {M : Type u_7} [inst_11 : TopologicalSpace M]
  [inst_12 : ChartedSpace H' M] {n : â„•âˆ} {f : M â†’ G} {xâ‚€ : M},
  ContMDiffAt I' I n f xâ‚€ â†’ ContMDiffAt I' I n (fun x => -f x) xâ‚€
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Cardinal.lift_umax : Cardinal.lift.{max u v, u} = Cardinal.lift.{v, u}
Result.exception ::
Duper saturated

Testing || TypeVec.fst_diag : âˆ€ {n : â„•} {Î± : TypeVec.{u_1} n}, TypeVec.comp TypeVec.prod.fst TypeVec.prod.diag = TypeVec.id
Result.exception ::
Duper saturated

Testing || Real.zero_rpow_le_one : âˆ€ (x : â„), 0 ^ x â‰¤ 1
Result.success

Testing || LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad : âˆ€ {R : Type u} [inst : CommRing R] {L : Type v} [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] (K : LieSubalgebra R L)
  {x : â†¥K}, IsNilpotent ((LieAlgebra.ad R L) â†‘x) â†’ IsNilpotent ((LieAlgebra.ad R â†¥K) x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_inv_app_fiber : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (G : CategoryTheory.Functor C (Type w))
  (X : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)),
  ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).unitIso.inv.app X).fiber = CategoryTheory.eqToHom â‹¯
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: G.obj X.base âŸ¶ G.obj X.base is not a `âˆ€`

Testing || MvPolynomial.sum_eval_eq_zero : âˆ€ {K : Type u_1} {Ïƒ : Type u_2} [inst : Fintype K] [inst_1 : Field K] [inst_2 : Fintype Ïƒ] [inst_3 : DecidableEq Ïƒ]
  (f : MvPolynomial Ïƒ K),
  f.totalDegree < (Fintype.card K - 1) * Fintype.card Ïƒ â†’ âˆ‘ x : Ïƒ â†’ K, (MvPolynomial.eval x) f = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.univ`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || convex_halfSpace_re_le : âˆ€ (r : â„), Convex â„ {c | c.re â‰¤ r}
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || interior_halfspace : âˆ€ {n : â„•} (p : ENNReal) (a : â„) (i : Fin n), interior {y | a â‰¤ y i} = {y | a < y i}
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Î± â†’
  Prop, type of âˆ€ bound variable is not of sort `Prop`, and depends on bound variables

Testing || Pi.negPart_apply : âˆ€ {Î¹ : Type u_2} {Î± : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ Lattice (Î± i)] [inst_1 : (i : Î¹) â†’ AddGroup (Î± i)]
  (f : (i : Î¹) â†’ Î± i) (i : Î¹), fâ» i = (f i)â»
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, ((!2 (x0 !4)) = (!0 x0))) is not type correct

Testing || AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing_map_apply : âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (ğ’œ : â„• â†’ Submodule R A)
  [inst_3 : GradedAlgebra ğ’œ] {X Y : (TopologicalSpace.Opens â†‘(ProjectiveSpectrum.top ğ’œ))áµ’áµ–} (i : X âŸ¶ Y)
  (a : (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType ğ’œ).val.obj X),
  ((AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing ğ’œ).map i) a =
    (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType ğ’œ).val.map i a
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType
          ğ’œ).val.obj
    Xâœ âŸ¶
  (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType ğ’œ).val.obj Yâœ is not a `âˆ€`

Testing || CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {J : Type u} [inst_2 : CategoryTheory.Category.{v, u} J] (E : CategoryTheory.Functor D C) [inst_3 : E.IsEquivalence]
  [inst : CategoryTheory.Limits.HasLimitsOfShape J C], CategoryTheory.Limits.HasLimitsOfShape J D
Result.exception ::
Duper saturated

Testing || HasProd.update' : âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : TopologicalSpace Î±] [inst_1 : CommMonoid Î±] [inst_2 : T2Space Î±]
  [inst_3 : ContinuousMul Î±] [inst_4 : DecidableEq Î²] {f : Î² â†’ Î±} {a a' : Î±},
  HasProd f a â†’ âˆ€ (b : Î²) (x : Î±), HasProd (Function.update f b x) a' â†’ a * x = a' * f b
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Matrix.trace_transpose : âˆ€ {n : Type u_3} {R : Type u_6} [inst : Fintype n] [inst_1 : AddCommMonoid R] (A : Matrix n n R),
  A.transpose.trace = A.trace
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `âˆ€`

Testing || CategoryTheory.Cat.freeRefl_obj_str_comp : âˆ€ (V : CategoryTheory.ReflQuiv) â¦ƒa b c : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRelâ¦„
  (a_1 : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel a b)
  (a_2 : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel b c),
  CategoryTheory.CategoryStruct.comp a_1 a_2 = CategoryTheory.Quotient.comp CategoryTheory.Cat.FreeReflRel a_1 a_2
Result.success

Testing || TensorProduct.add_tmul : âˆ€ {R : Type u_1} [inst : CommSemiring R] {M : Type u_4} {N : Type u_5} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid N] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R N] (mâ‚ mâ‚‚ : M) (n : N),
  (mâ‚ + mâ‚‚) âŠ—â‚œ[R] n = mâ‚ âŠ—â‚œ[R] n + mâ‚‚ âŠ—â‚œ[R] n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `âŸ¦x_1âŸ§`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || toZ_of_ge : âˆ€ {Î¹ : Type u_1} [inst : LinearOrder Î¹] [inst_1 : SuccOrder Î¹] [inst_2 : IsSuccArchimedean Î¹] [inst_3 : PredOrder Î¹]
  {i0 i : Î¹} (hi : i0 â‰¤ i), toZ i0 i = â†‘(Nat.find â‹¯)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (h : i0 â‰¤ i),
  â‹¯ = â‹¯, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || ContinuousAlternatingMap.ofSubsingleton_apply_toContinuousMultilinearMap : âˆ€ (R : Type u_1) (M : Type u_2) (N : Type u_4) {Î¹ : Type u_6} [inst : Semiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : _root_.Module R M] [inst_3 : TopologicalSpace M] [inst_4 : AddCommMonoid N] [inst_5 : _root_.Module R N]
  [inst_6 : TopologicalSpace N] [inst_7 : Subsingleton Î¹] (i : Î¹) (f : M â†’L[R] N),
  ((ContinuousAlternatingMap.ofSubsingleton R M N i) f).toContinuousMultilinearMap =
    (ContinuousMultilinearMap.ofSubsingleton R M N i) f
Result.success

Testing || TopologicalGroup.of_comm_of_nhds_one : âˆ€ {G : Type u} [inst : CommGroup G] [inst_1 : TopologicalSpace G],
  Filter.Tendsto (Function.uncurry fun x1 x2 => x1 * x2) (nhds 1 Ã—Ë¢ nhds 1) (nhds 1) â†’
    Filter.Tendsto (fun x => xâ»Â¹) (nhds 1) (nhds 1) â†’
      (âˆ€ (xâ‚€ : G), nhds xâ‚€ = Filter.map (fun x => xâ‚€ * x) (nhds 1)) â†’ TopologicalGroup G
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.ZeroAtFilter.boundedAtFilter : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SeminormedAddGroup Î²] {l : Filter Î±} {f : Î± â†’ Î²},
  l.ZeroAtFilter f â†’ l.BoundedAtFilter f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_3 =o[x_1] fun _x => cifvar_19`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Turing.ListBlank.nth_mk : âˆ€ {Î“ : Type u_1} [inst : Inhabited Î“] (l : List Î“) (n : â„•), (Turing.ListBlank.mk l).nth n = l.getI n
Result.success

Testing || CategoryTheory.epi_iff_surjective : âˆ€ {X Y : Type u} (f : X âŸ¶ Y), CategoryTheory.Epi f â†” Function.Surjective f
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (Â¬ ((!0 !1) â†” (!2 !1))) is not type correct

Testing || Multiset.le_prod_of_submultiplicative_on_pred : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : CommMonoid Î±] [inst_1 : OrderedCommMonoid Î²] (f : Î± â†’ Î²) (p : Î± â†’ Prop),
  f 1 = 1 â†’
    p 1 â†’
      (âˆ€ (a b : Î±), p a â†’ p b â†’ f (a * b) â‰¤ f a * f b) â†’
        (âˆ€ (a b : Î±), p a â†’ p b â†’ p (a * b)) â†’ âˆ€ (s : Multiset Î±), (âˆ€ a âˆˆ s, p a) â†’ f s.prod â‰¤ (Multiset.map f s).prod
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_6 a x_2 â‰¤ cifvar_6 a x_3`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Fin.sum_univ_six : âˆ€ {Î² : Type u_2} [inst : AddCommMonoid Î²] (f : Fin 6 â†’ Î²), âˆ‘ i : Fin 6, f i = f 0 + f 1 + f 2 + f 3 + f 4 + f 5
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.isRotated_singleton_iff : âˆ€ {Î± : Type u} {l : List Î±} {x : Î±}, l ~r [x] â†” l = [x]
Result.exception ::
Duper saturated

Testing || CategoryTheory.Equivalence.changeInverse_counitIso_hom_app : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  (e : C â‰Œ D) {G : CategoryTheory.Functor D C} (iso : e.inverse â‰… G) (X : D),
  (e.changeInverse iso).counitIso.hom.app X =
    CategoryTheory.CategoryStruct.comp (e.functor.map (iso.inv.app X)) (e.counitIso.hom.app X)
Result.success

Testing || CategoryTheory.comp_eqToHom_heq : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {X Y Z : C} (f : X âŸ¶ Y) (h : Y = Z),
  HEq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) f
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (p : X = X),
  CategoryTheory.eqToHom p = CategoryTheory.CategoryStruct.id X, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || Multiset.toFinset_nsmul : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (s : Multiset Î±) (n : â„•), n â‰  0 â†’ (n â€¢ s).toFinset = s.toFinset
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Quotient.out_eq' : âˆ€ {Î± : Sort u_1} {sâ‚ : Setoid Î±} (q : Quotient sâ‚), Quotient.mk'' q.out = q
Result.success

Testing || IsLocalizedModule.mk'_add : âˆ€ {R : Type u_1} [inst : CommSemiring R] {S : Submonoid R} {M : Type u_2} {M' : Type u_3} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M'] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M'] (f : M â†’â‚—[R] M')
  [inst_5 : IsLocalizedModule S f] (mâ‚ mâ‚‚ : M) (s : â†¥S),
  IsLocalizedModule.mk' f (mâ‚ + mâ‚‚) s = IsLocalizedModule.mk' f mâ‚ s + IsLocalizedModule.mk' f mâ‚‚ s
Result.success

Testing || IntermediateField.equivOfEq_symm : âˆ€ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E] {S T : IntermediateField F E}
  (h : S = T), (IntermediateField.equivOfEq h).symm = IntermediateField.equivOfEq â‹¯
Result.success

Testing || MeasureTheory.eLpNormEssSup_const : âˆ€ {Î± : Type u_1} {F : Type u_3} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : NormedAddCommGroup F]
  (c : F), Î¼ â‰  0 â†’ MeasureTheory.eLpNormEssSup (fun x => c) Î¼ = â†‘â€–câ€–â‚Š
Result.success

Testing || Ideal.map_radical_of_surjective : âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] {f : R â†’+* S},
  Function.Surjective â‡‘f â†’ âˆ€ {I : Ideal R}, RingHom.ker f â‰¤ I â†’ Ideal.map f I.radical = (Ideal.map f I).radical
Result.exception ::
Duper saturated

Testing || Submodule.smul_torsionBy : âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (a : R)
  (x : â†¥(Submodule.torsionBy R M a)), a â€¢ x = 0
Result.exception ::
Duper saturated

Testing || dite_ite_distrib_right : âˆ€ {Î± : Sort u_1} {p q : Prop} [inst : Decidable p] [inst_1 : Decidable q] {a b : p â†’ Î±} {c : Â¬p â†’ Î±},
  dite p (fun hp => if q then a hp else b hp) c = if q then dite p a c else dite p b c
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Limits.cofan_mk_inj : âˆ€ {Î² : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {f : Î² â†’ C} (P : C) (p : (b : Î²) â†’ f b âŸ¶ P)
  (j : Î²), (CategoryTheory.Limits.Cofan.mk P p).inj j = p j
Result.success

Testing || Mathlib.Tactic.Monoidal.evalHorizontalCompAux'_whisker : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C] {f f' g g' h : C}
  {Î· : g âŸ¶ h} {Î¸ : f' âŸ¶ g'}
  {Î·Î¸ : CategoryTheory.MonoidalCategory.tensorObj g f' âŸ¶ CategoryTheory.MonoidalCategory.tensorObj h g'}
  {Î·â‚ :
    CategoryTheory.MonoidalCategory.tensorObj f (CategoryTheory.MonoidalCategory.tensorObj g f') âŸ¶
      CategoryTheory.MonoidalCategory.tensorObj f (CategoryTheory.MonoidalCategory.tensorObj h g')}
  {Î·â‚‚ :
    CategoryTheory.MonoidalCategory.tensorObj f (CategoryTheory.MonoidalCategory.tensorObj g f') âŸ¶
      CategoryTheory.MonoidalCategory.tensorObj (CategoryTheory.MonoidalCategory.tensorObj f h) g'}
  {Î·â‚ƒ :
    CategoryTheory.MonoidalCategory.tensorObj (CategoryTheory.MonoidalCategory.tensorObj f g) f' âŸ¶
      CategoryTheory.MonoidalCategory.tensorObj (CategoryTheory.MonoidalCategory.tensorObj f h) g'},
  CategoryTheory.MonoidalCategory.tensorHom Î· Î¸ = Î·Î¸ â†’
    CategoryTheory.MonoidalCategory.whiskerLeft f Î·Î¸ = Î·â‚ â†’
      CategoryTheory.CategoryStruct.comp Î·â‚ (CategoryTheory.MonoidalCategory.associator f h g').inv = Î·â‚‚ â†’
        CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator f g f').hom Î·â‚‚ = Î·â‚ƒ â†’
          CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.MonoidalCategory.whiskerLeft f Î·) Î¸ = Î·â‚ƒ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerLeft
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Subring.mem_bot : âˆ€ {R : Type u} [inst : Ring R] {x : R}, x âˆˆ âŠ¥ â†” âˆƒ n, â†‘n = x
Result.success

Testing || MeasurableSet.cylinder : âˆ€ {Î¹ : Type u_2} {Î± : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MeasurableSpace (Î± i)] (s : Finset Î¹)
  {S : Set ((i : { x // x âˆˆ s }) â†’ Î± â†‘i)}, MeasurableSet S â†’ MeasurableSet (MeasureTheory.cylinder s S)
Result.exception ::
Duper saturated

Testing || IsSelfAdjoint.zpow : âˆ€ {R : Type u_1} [inst : Group R] [inst_1 : StarMul R] {x : R}, IsSelfAdjoint x â†’ âˆ€ (n : â„¤), IsSelfAdjoint (x ^ n)
Result.success

Testing || CliffordAlgebra.ofBaseChange_comp_toBaseChange : âˆ€ {R : Type u_1} (A : Type u_2) {V : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : AddCommGroup V]
  [inst_3 : Algebra R A] [inst_4 : _root_.Module R V] [inst_5 : Invertible 2] (Q : QuadraticForm R V),
  (CliffordAlgebra.ofBaseChange A Q).comp (CliffordAlgebra.toBaseChange A Q) =
    AlgHom.id A (CliffordAlgebra (QuadraticForm.baseChange A Q))
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || uniformEquicontinuousOn_unique : âˆ€ {Î¹ : Type u_1} {Î± : Type u_6} {Î² : Type u_8} [uÎ± : UniformSpace Î±] [uÎ² : UniformSpace Î²] [inst : Unique Î¹]
  {F : Î¹ â†’ Î² â†’ Î±} {S : Set Î²}, UniformEquicontinuousOn F S â†” UniformContinuousOn (F default) S
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Metric.continuous_infNndist_pt : âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), Continuous fun x => Metric.infNndist x s
Result.success

Testing || IntermediateField.pow_mem : âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)
  {x : L}, x âˆˆ S â†’ âˆ€ (n : â„¤), x ^ n âˆˆ S
Result.success

Testing || CochainComplex.HomComplex.Cochain.map_comp : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C â„¤} (K : CochainComplex C â„¤) {D : Type u_2} [inst_2 : CategoryTheory.Category.{u_3, u_2} D]
  [inst_3 : CategoryTheory.Preadditive D] {nâ‚ nâ‚‚ nâ‚â‚‚ : â„¤} (zâ‚ : CochainComplex.HomComplex.Cochain F G nâ‚)
  (zâ‚‚ : CochainComplex.HomComplex.Cochain G K nâ‚‚) (h : nâ‚ + nâ‚‚ = nâ‚â‚‚) (Î¦ : CategoryTheory.Functor C D)
  [inst_4 : Î¦.Additive], (zâ‚.comp zâ‚‚ h).map Î¦ = (zâ‚.map Î¦).comp (zâ‚‚.map Î¦) h
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ModelWithCorners.toHomeomorph_apply : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ğ•œ E H)
  [inst_4 : I.Boundaryless] (a : H), I.toHomeomorph a = â†‘I a
Result.success

Testing || isBot_iff_isMin : âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±} [inst_1 : IsDirected Î± fun x1 x2 => x1 â‰¥ x2], IsBot a â†” IsMin a
Result.success

Testing || Cardinal.toPartENat_lift : âˆ€ (c : Cardinal.{v}), Cardinal.toPartENat (Cardinal.lift.{u, v} c) = Cardinal.toPartENat c
Result.exception ::
Duper saturated

Testing || AlgHom.range_comp_le_range : âˆ€ {R : Type u} {A : Type v} {B : Type w} {C : Type w'} [inst : CommSemiring R] [inst_1 : Semiring A]
  [inst_2 : Algebra R A] [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : Semiring C] [inst_6 : Algebra R C]
  (f : A â†’â‚[R] B) (g : B â†’â‚[R] C), (g.comp f).range â‰¤ g.range
Result.exception ::
Duper saturated

Testing || DifferentiableWithinAt.const_cpow : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {x : E} {s : Set E} {c : â„‚},
  DifferentiableWithinAt â„‚ f s x â†’ c â‰  0 âˆ¨ f x â‰  0 â†’ DifferentiableWithinAt â„‚ (fun x => c ^ f x) s x
Result.success

Testing || SetTheory.PGame.memâ‚—.congr_left : âˆ€ {x y : SetTheory.PGame}, x.Identical y â†’ âˆ€ {w : SetTheory.PGame}, x.memâ‚— w â†” y.memâ‚— w
Result.exception ::
Duper saturated

Testing || iSup_inf_eq : âˆ€ {Î± : Type u} {Î¹ : Sort w} [inst : Order.Frame Î±] (f : Î¹ â†’ Î±) (a : Î±), (â¨† i, f i) âŠ“ a = â¨† i, f i âŠ“ a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a âˆˆ x_0 of Î» binder contains bound variables

Testing || MulHom.coe_coe : âˆ€ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Mul M] [inst_1 : Mul N] [inst_2 : FunLike F M N]
  [inst_3 : MulHomClass F M N] (f : F), â‡‘â†‘f = â‡‘f
Result.exception ::
Duper saturated

Testing || PresheafOfModules.toSheaf_map_sheafificationHomEquiv_symm : âˆ€ {C : Type u'} [inst : CategoryTheory.Category.{v', u'} C] {J : CategoryTheory.GrothendieckTopology C}
  {Râ‚€ : CategoryTheory.Functor Cáµ’áµ– RingCat} {R : CategoryTheory.Sheaf J RingCat} (Î± : Râ‚€ âŸ¶ R.val)
  [inst_1 : CategoryTheory.Presheaf.IsLocallyInjective J Î±] [inst_2 : CategoryTheory.Presheaf.IsLocallySurjective J Î±]
  [inst_3 : J.WEqualsLocallyBijective AddCommGrp] [inst_4 : CategoryTheory.HasWeakSheafify J AddCommGrp]
  {P : PresheafOfModules Râ‚€} {F : SheafOfModules R}
  (g : P âŸ¶ (PresheafOfModules.restrictScalars Î±).obj ((SheafOfModules.forget R).obj F)),
  (SheafOfModules.toSheaf R).map ((PresheafOfModules.sheafificationHomEquiv Î±).symm g) =
    ((CategoryTheory.sheafificationAdjunction J AddCommGrp).homEquiv P.presheaf ((SheafOfModules.toSheaf R).obj F)).symm
      ((PresheafOfModules.toPresheaf Râ‚€).map g)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || compl_bihimp_self : âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] (a : Î±), bihimp aá¶œ a = âŠ¥
Result.exception ::
Duper saturated

Testing || CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_Ï†Q : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  (S : CategoryTheory.ShortComplex C) (hf : S.f = 0) (hg : S.g = 0) (c : CategoryTheory.Limits.KernelFork S.g)
  (hc : CategoryTheory.Limits.IsLimit c),
  (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).Ï†Q =
    CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).Q
Result.success

Testing || Basis.card_le_card_of_linearIndependent : âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  [inst_3 : StrongRankCondition R] {Î¹ : Type u_1} [inst_4 : Fintype Î¹],
  Basis Î¹ R M â†’
    âˆ€ {Î¹' : Type u_2} [inst_5 : Fintype Î¹'] {v : Î¹' â†’ M}, LinearIndependent R v â†’ Fintype.card Î¹' â‰¤ Fintype.card Î¹
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `List.Perm.length_eq`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Orientation.rotation_trans : âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : Fact (Module.finrank â„ V = 2)]
  (o : Orientation â„ V (Fin 2)) (Î¸â‚ Î¸â‚‚ : Real.Angle), (o.rotation Î¸â‚).trans (o.rotation Î¸â‚‚) = o.rotation (Î¸â‚‚ + Î¸â‚)
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsPrimitiveRoot.sub_one_norm_isPrimePow : âˆ€ {n : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L],
  IsPrimitiveRoot Î¶ â†‘n â†’
    IsPrimePow â†‘n â†’
      âˆ€ [inst_3 : IsCyclotomicExtension {n} K L],
        Irreducible (Polynomial.cyclotomic (â†‘n) K) â†’ n â‰  2 â†’ (Algebra.norm K) (Î¶ - 1) = â†‘(â†‘n).minFac
Result.exception ::
Auto.Monomorphization.FVarRep.constInst2FVarId :: Cannot find canonicalized instance of ConstInst â¦—â¦— Fact â¦˜â¦˜

Testing || Stream'.tail_eq_drop : âˆ€ {Î± : Type u} (s : Stream' Î±), s.tail = Stream'.drop 1 s
Result.success

Testing || UniformEquiv.piCongrRight_apply : âˆ€ {Î¹ : Type u_4} {Î²â‚ : Î¹ â†’ Type u_5} {Î²â‚‚ : Î¹ â†’ Type u_6} [inst : (i : Î¹) â†’ UniformSpace (Î²â‚ i)]
  [inst_1 : (i : Î¹) â†’ UniformSpace (Î²â‚‚ i)] (F : (i : Î¹) â†’ Î²â‚ i â‰ƒáµ¤ Î²â‚‚ i) (a : (i : Î¹) â†’ Î²â‚ i) (i : Î¹),
  (UniformEquiv.piCongrRight F) a i = (F i) (a i)
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Matrix.mulVec_empty : âˆ€ {Î± : Type u} {m' : Type uâ‚˜} [inst : NonUnitalNonAssocSemiring Î±] (A : Matrix m' (Fin 0) Î±) (v : Fin 0 â†’ Î±),
  A.mulVec v = 0
Result.success

Testing || MvPolynomial.isHomogeneous_C : âˆ€ (Ïƒ : Type u_1) {R : Type u_3} [inst : CommSemiring R] (r : R), (MvPolynomial.C r).IsHomogeneous 0
Result.exception ::
Duper saturated

Testing || NonUnitalStarSubalgebra.mem_map : âˆ€ {F : Type v'} {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : NonUnitalNonAssocSemiring A]
  [inst_2 : _root_.Module R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B] [inst_5 : _root_.Module R B]
  [inst_6 : Star B] [inst_7 : FunLike F A B] [inst_8 : NonUnitalAlgHomClass F R A B] [inst_9 : StarHomClass F A B]
  {S : NonUnitalStarSubalgebra R A} {f : F} {y : B}, y âˆˆ NonUnitalStarSubalgebra.map f S â†” âˆƒ x âˆˆ S, f x = y
Result.success

Testing || uniqueDiffWithinAt_Iio : âˆ€ (a : â„), UniqueDiffWithinAt â„ (Set.Iio a) a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : #1, ((!6 (!0 x0) x1) = (!0 x0 x1)))) is not type correct

Testing || strictMonoOn_Ici_of_pred_lt : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : PartialOrder Î±] [inst_1 : Preorder Î²] {Ïˆ : Î± â†’ Î²} [inst_2 : PredOrder Î±]
  [inst_3 : IsPredArchimedean Î±] {n : Î±}, (âˆ€ (m : Î±), n < m â†’ Ïˆ (Order.pred m) < Ïˆ m) â†’ StrictMonoOn Ïˆ (Set.Ici n)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Order.succ m`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || groupCohomology.twoCocycles_ext : âˆ€ {k G : Type u} [inst : CommRing k] [inst_1 : Group G] {A : Rep k G} {fâ‚ fâ‚‚ : â†¥(groupCohomology.twoCocycles A)},
  (âˆ€ (g h : G), fâ‚ (g, h) = fâ‚‚ (g, h)) â†’ fâ‚ = fâ‚‚
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.getMsbD_one : âˆ€ {w i : â„•}, (1#w).getMsbD i = (decide (i = w - 1) && decide (0 < w))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `BitVec.ofNat x_0 cifvar_4`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NormedSpace.exp_zero : âˆ€ {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [inst : Field ğ•‚] [inst_1 : Ring ğ”¸] [inst_2 : Algebra ğ•‚ ğ”¸] [inst_3 : TopologicalSpace ğ”¸]
  [inst_4 : TopologicalRing ğ”¸], NormedSpace.exp ğ•‚ 0 = 1
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: FormalMultilinearSeries ğ•‚ ğ”¸ ğ”¸ is not a `âˆ€`

Testing || MeromorphicOn.inv_iff : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {s : ğ•œ â†’ ğ•œ} {U : Set ğ•œ}, MeromorphicOn sâ»Â¹ U â†” MeromorphicOn s U
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WithLp.prod_norm_equiv_symm : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SeminormedAddCommGroup Î±] [inst_1 : SeminormedAddCommGroup Î²] (f : Î± Ã— Î²),
  â€–(WithLp.equiv âŠ¤ (Î± Ã— Î²)).symm fâ€– = â€–fâ€–
Result.success

Testing || Ordinal.add_omega0_opow : âˆ€ {a b : Ordinal.{u}}, a < Ordinal.omega0 ^ b â†’ a + Ordinal.omega0 ^ b = Ordinal.omega0 ^ b
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Module.AEval.isTorsion_of_aeval_eq_zero : âˆ€ {R : Type u_1} {M : Type u_3} {A : Type u_4} {a : A} [inst : CommSemiring R] [inst_1 : NoZeroDivisors R]
  [inst_2 : Semiring A] [inst_3 : Algebra R A] [inst_4 : AddCommMonoid M] [inst_5 : _root_.Module A M]
  [inst_6 : _root_.Module R M] [inst_7 : IsScalarTower R A M] {p : Polynomial R},
  (Polynomial.aeval a) p = 0 â†’ p â‰  0 â†’ Module.IsTorsion (Polynomial R) (Module.AEval R M a)
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.ae_toFiniteAux : âˆ€ {Î± : Type u_1} {mÎ± : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MeasureTheory.SFinite Î¼],
  MeasureTheory.ae Î¼.toFiniteAux = MeasureTheory.ae Î¼
Result.exception ::
Duper saturated

Testing || Topology.IsEmbedding.restrictPreimage : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} (s : Set Î²),
  Topology.IsEmbedding f â†’ Topology.IsEmbedding (s.restrictPreimage f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceSubtype`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubmonoid.unop_closure : âˆ€ {M : Type u_2} [inst : AddZeroClass M] (s : Set Máµƒáµ’áµ–),
  (AddSubmonoid.closure s).unop = AddSubmonoid.closure (AddOpposite.op â»Â¹' s)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Monoid.Coprod.fst_apply_inl : âˆ€ {M : Type u_1} {N : Type u_2} [inst : Monoid M] [inst_1 : Monoid N] (x : M),
  Monoid.Coprod.fst (Monoid.Coprod.inl x) = x
Result.success

Testing || SemidirectProduct.rightHom_comp_inr : âˆ€ {N : Type u_1} {G : Type u_2} [inst : Group N] [inst_1 : Group G] {Ï† : G â†’* MulAut N},
  SemidirectProduct.rightHom.comp SemidirectProduct.inr = MonoidHom.id G
Result.success

Testing || Equiv.uniformEmbedding : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â‰ƒ Î²),
  UniformContinuous â‡‘f â†’ UniformContinuous â‡‘f.symm â†’ IsUniformEmbedding â‡‘f
Result.success

Testing || Set.LeftInvOn.eq : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {f : Î± â†’ Î²} {f' : Î² â†’ Î±},
  Set.LeftInvOn f' f s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ f' (f x) = x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!4 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Multiset.mem_powersetAux : âˆ€ {Î± : Type u_1} {l : List Î±} {s : Multiset Î±}, s âˆˆ Multiset.powersetAux l â†” s â‰¤ â†‘l
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Topology.IsEmbedding.t2Space : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]
  {f : X â†’ Y}, Topology.IsEmbedding f â†’ T2Space X
Result.success

Testing || Option.isSome_unattach : âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {o : Option { x // p x }}, o.unattach.isSome = o.isSome
Result.success

Testing || AddChar.zmod_char_ne_one_iff : âˆ€ {C : Type v} [inst : CommMonoid C] (n : â„•) [inst_1 : NeZero n] (Ïˆ : AddChar (ZMod n) C), Ïˆ â‰  1 â†” Ïˆ 1 â‰  1
Result.exception ::
Duper saturated

Testing || IsAddUnit.add : âˆ€ {M : Type u_1} [inst : AddMonoid M] {a b : M}, IsAddUnit a â†’ IsAddUnit b â†’ IsAddUnit (a + b)
Result.exception ::
Duper saturated

Testing || Polynomial.evalâ‚‚_C_X : âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.evalâ‚‚ Polynomial.C Polynomial.X p = p
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.AEEqFun.pair_eq_mk : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±}
  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³] (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³),
  f.pair g = MeasureTheory.AEEqFun.mk (fun x => (â†‘f x, â†‘g x)) â‹¯
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasureTheory.AEEqFun.aestronglyMeasurable
  x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Multiset.card_mono : âˆ€ {Î± : Type u_1}, Monotone â‡‘Multiset.card
Result.exception ::
Duper saturated

Testing || ContinuousMap.coe_copy : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : C(X, Y)) (f' : X â†’ Y)
  (h : f' = â‡‘f), â‡‘(f.copy f' h) = f'
Result.exception ::
Duper saturated

Testing || Module.mapEvalEquiv_symm_apply : âˆ€ (R : Type u_1) (M : Type u_2) [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  [inst_3 : Module.IsReflexive R M] (W'' : Submodule R (Module.Dual R (Module.Dual R M))),
  (Module.mapEvalEquiv R M).symm W'' = Submodule.comap (Module.Dual.eval R M) W''
Result.success

Testing || ExceptCpsT.run_throw : âˆ€ {m : Type u_1 â†’ Type u_2} {Îµ Î² : Type u_1} {e : Îµ} [inst : Monad m], (throw e).run = pure (Except.error e)
Result.success

Testing || Polynomial.hasseDeriv_X : âˆ€ {R : Type u_1} [inst : Semiring R] (k : â„•), 1 < k â†’ (Polynomial.hasseDeriv k) Polynomial.X = 0
Result.success

Testing || Array.get?_eq_get?_toList : âˆ€ {Î± : Type u_1} (a : Array Î±) (i : â„•), a.get? i = a.toList.get? i
Result.success

Testing || Matroid.spanning_iff_exists_base_subset : âˆ€ {Î± : Type u_2} {M : Matroid Î±} {S : Set Î±}, autoParam (S âŠ† M.E) _autoâœ â†’ (M.Spanning S â†” âˆƒ B, M.Base B âˆ§ B âŠ† S)
Result.success

Testing || Sum.bnot_isRight : âˆ€ {Î± : Type u_1} {Î² : Type u_2} (x : Î± âŠ• Î²), (!decide (x.isRight = x.isLeft)) = true
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Function.zero_of_even_and_odd : âˆ€ {Î± : Type u_3} {Î² : Type u_4} [inst : AddCommGroup Î²] [inst_1 : NoZeroSMulDivisors â„• Î²] {f : Î± â†’ Î²} [inst_2 : Neg Î±],
  Function.Even f â†’ Function.Odd f â†’ f = 0
Result.exception ::
Duper saturated

Testing || groupCohomology.mem_oneCocycles_def : âˆ€ {k G : Type u} [inst : CommRing k] [inst_1 : Group G] {A : Rep k G} (f : G â†’ CoeSort.coe A),
  f âˆˆ groupCohomology.oneCocycles A â†” âˆ€ (g h : G), (A.Ï g) (f h) - f (g * h) + f g = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Rep.instAddCommGroupCoe x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Real.mul_lt_sin : âˆ€ {x : â„}, 0 < x â†’ x < Real.pi / 2 â†’ 2 / Real.pi * x < Real.sin x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toMonoidWithZero`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finsupp.neLocus_neg : âˆ€ {Î± : Type u_1} {N : Type u_3} [inst : DecidableEq Î±] [inst_1 : DecidableEq N] [inst_2 : AddGroup N] (f g : Î± â†’â‚€ N),
  (-f).neLocus g = f.neLocus (-g)
Result.success

Testing || LinearMap.hasBasis_weakBilin : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E]
  [inst_2 : _root_.Module ğ•œ E] [inst_3 : AddCommGroup F] [inst_4 : _root_.Module ğ•œ F] (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ),
  (nhds 0).HasBasis B.toSeminormFamily.basisSets id
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `WeakBilin.instAddCommGroup x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.snorm'_lt_top_of_snorm'_lt_top_of_exponent_le : âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} [inst : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}
  {f : Î± â†’ E} {p q : â„} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],
  MeasureTheory.AEStronglyMeasurable f Î¼ â†’
    MeasureTheory.eLpNorm' f q Î¼ < âŠ¤ â†’ 0 â‰¤ p â†’ p â‰¤ q â†’ MeasureTheory.eLpNorm' f p Î¼ < âŠ¤
Result.success

Testing || Algebra.TensorProduct.assoc_symm_tmul : âˆ€ (R : Type uR) {A : Type uA} {B : Type uB} {C : Type uC} [inst : CommSemiring R] [inst_1 : Semiring A]
  [inst_2 : Algebra R A] [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : Semiring C] [inst_6 : Algebra R C]
  (a : A) (b : B) (c : C), (Algebra.TensorProduct.assoc R A B C).symm (a âŠ—â‚œ[R] b âŠ—â‚œ[R] c) = (a âŠ—â‚œ[R] b) âŠ—â‚œ[R] c
Result.success

Testing || MeasureTheory.integral_add : âˆ€ {Î± : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}
  {Î¼ : MeasureTheory.Measure Î±} {f g : Î± â†’ G},
  MeasureTheory.Integrable f Î¼ â†’
    MeasureTheory.Integrable g Î¼ â†’ âˆ« (a : Î±), f a + g a âˆ‚Î¼ = âˆ« (a : Î±), f a âˆ‚Î¼ + âˆ« (a : Î±), g a âˆ‚Î¼
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Classical.propDecidable
  (cifvar_0 x_1 x_0)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.filter_empty : âˆ€ {Î± : Type u_1} (p : Î± â†’ Prop) [inst : DecidablePred p], Finset.filter p âˆ… = âˆ…
Result.success

Testing || ContinuousLinearMap.exist_extension_of_finiteDimensional_range : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : IsRCLikeNormedField ğ•œ] {E : Type u_2} {F : Type u_3}
  [inst_2 : SeminormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup F]
  [inst_5 : NormedSpace ğ•œ F] {p : Submodule ğ•œ E} (f : â†¥p â†’L[ğ•œ] F) [inst_6 : FiniteDimensional ğ•œ â†¥(LinearMap.range f)],
  âˆƒ g, f = g.comp p.subtypeL
Result.exception ::
Duper saturated

Testing || MulDissociated.of_inv : âˆ€ {Î± : Type u_1} [inst : CommGroup Î±] {s : Set Î±}, MulDissociated sâ»Â¹ â†’ MulDissociated s
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Equiv.Perm.support_cycleOf_eq_nil_iff : âˆ€ {Î± : Type u_2} {f : Equiv.Perm Î±} {x : Î±} [inst : DecidableEq Î±] [inst_1 : Fintype Î±],
  (f.cycleOf x).support = âˆ… â†” x âˆ‰ f.support
Result.success

Testing || Pell.exists_of_not_isSquare : âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ x y, x ^ 2 - d * y ^ 2 = 1 âˆ§ y â‰  0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddCommGroupWithOne.toAddCommGroup`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.biproduct_Î¹_comp_leftDistributor_hom_assoc : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.MonoidalCategory C] [inst_3 : CategoryTheory.MonoidalPreadditive C]
  [inst_4 : CategoryTheory.Limits.HasFiniteBiproducts C] {J : Type} [inst_5 : Fintype J] (X : C) (f : J â†’ C) (j : J)
  {Z : C} (h : (â¨ fun j => CategoryTheory.MonoidalCategory.tensorObj X (f j)) âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp
      (CategoryTheory.MonoidalCategory.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j))
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom h) =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategory.tensorObj X (f j)) j) h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_20.Ï€ jâœ`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || UniformSpace.Completion.continuous_dist : âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : TopologicalSpace Î²]
  {f g : Î² â†’ UniformSpace.Completion Î±}, Continuous f â†’ Continuous g â†’ Continuous fun x => dist (f x) (g x)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Continuous x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || RingEquiv.piEquivPiSubtypeProd_symm_apply : âˆ€ {Î¹ : Type u_7} (p : Î¹ â†’ Prop) [inst : DecidablePred p] (Y : Î¹ â†’ Type u_8)
  [inst_1 : (i : Î¹) â†’ NonUnitalNonAssocSemiring (Y i)] (f : ((i : { x // p x }) â†’ Y â†‘i) Ã— ((i : { x // Â¬p x }) â†’ Y â†‘i))
  (x : Î¹), (RingEquiv.piEquivPiSubtypeProd p Y).symm f x = if h : p x then f.1 âŸ¨x, hâŸ© else f.2 âŸ¨x, hâŸ©
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || CochainComplex.HomComplex.Cocycle.Î´_eq_zero : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C â„¤} {n : â„¤} (z : CochainComplex.HomComplex.Cocycle F G n) (m : â„¤),
  CochainComplex.HomComplex.Î´ n m â†‘z = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CochainComplex.HomComplex.Î´
  cifvar_12 x_0 z`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MulEquiv.comapSubgroup_apply : âˆ€ {G : Type u_1} [inst : Group G] {H : Type u_5} [inst_1 : Group H] (f : G â‰ƒ* H) (H_1 : Subgroup H),
  f.comapSubgroup H_1 = Subgroup.comap (â†‘f) H_1
Result.success

Testing || EquivLike.coe_symm_comp_self : âˆ€ {Î± : Sort u} {Î² : Sort v} {F : Sort u_1} [inst : EquivLike F Î± Î²] (e : F), â‡‘(â†‘e).symm âˆ˜ â‡‘e = id
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetry_snd_assoc : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b âŸ¶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a âŸ¶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful] {Z : C} (h : b âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.snd f') h) =
    CategoryTheory.CategoryStruct.comp (hf'.fst' g) h
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `âˆ€`

Testing || AddMonoid.Coprod.snd_apply_inr : âˆ€ {M : Type u_1} {N : Type u_2} [inst : AddMonoid M] [inst_1 : AddMonoid N] (x : N),
  AddMonoid.Coprod.snd (AddMonoid.Coprod.inr x) = x
Result.success

Testing || CategoryTheory.Limits.Î¹_comp_colimitRightOpIsoUnopLimit_hom_assoc : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {J : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} J]
  (F : CategoryTheory.Functor Jáµ’áµ– C) [inst_2 : CategoryTheory.Limits.HasLimit F] (j : J) {Z : Cáµ’áµ–}
  (h : Opposite.op (CategoryTheory.Limits.limit F) âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F.rightOp j)
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitRightOpIsoUnopLimit F).hom h) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F (Opposite.op j)).op h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.colimit.Î¹
  (cifvar_43 cifvar_1) x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.lintegral_singleton : âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MeasurableSingletonClass Î±]
  (f : Î± â†’ ENNReal) (a : Î±), âˆ«â» (x : Î±) in {a}, f x âˆ‚Î¼ = f a * Î¼ {a}
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ContinuousMultilinearMap.norm_def : âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : NontriviallyNormedField ğ•œ]
  [inst_1 : (i : Î¹) â†’ SeminormedAddCommGroup (E i)] [inst_2 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] [inst_5 : Fintype Î¹]
  (f : ContinuousMultilinearMap ğ•œ E G), â€–fâ€– = sInf {c | 0 â‰¤ c âˆ§ âˆ€ (m : (i : Î¹) â†’ E i), â€–f mâ€– â‰¤ c * âˆ i : Î¹, â€–m iâ€–}
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instâœâ´ i`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.nil_product : âˆ€ {Î± : Type u_1} {Î² : Type u_2} (l : List Î²), [] Ã—Ë¢ l = []
Result.success

Testing || Std.DHashMap.getKeyD_erase : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {x : BEq Î±} {x_1 : Hashable Î±} {m : Std.DHashMap Î± Î²} [inst : EquivBEq Î±]
  [inst : LawfulHashable Î±] {k a fallback : Î±},
  (m.erase k).getKeyD a fallback = if (k == a) = true then fallback else m.getKeyD a fallback
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Std.DHashMap.getKeyD.proof_1 mâœ`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.iSup_iInf_of_monotone : âˆ€ {Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [inst : Finite Î¹] [inst : Preorder Î¹'] [inst_1 : Nonempty Î¹']
  [inst_2 : IsDirected Î¹' fun x1 x2 => x1 â‰¤ x2] [inst_3 : Order.Frame Î±] {f : Î¹ â†’ Î¹' â†’ Î±},
  (âˆ€ (i : Î¹), Monotone (f i)) â†’ â¨† j, â¨… i, f i j = â¨… i, â¨† j, f i j
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type xâœ âˆˆ Set.univ of Î» binder contains bound variables

Testing || Set.biUnion_le_eq_iUnion : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] {s : Î± â†’ Set Î²}, â‹ƒ n, â‹ƒ m, â‹ƒ (_ : m â‰¤ n), s m = â‹ƒ n, s n
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type m â‰¤ nâœ of Î» binder contains bound variables

Testing || CategoryTheory.Functor.LaxMonoidal.Î¼_natural_right : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}
  [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] [inst_3 : CategoryTheory.MonoidalCategory D]
  (F : CategoryTheory.Functor C D) [inst_4 : F.LaxMonoidal] {X Y : C} (X' : C) (f : X âŸ¶ Y),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft (F.obj X') (F.map f))
      (CategoryTheory.Functor.LaxMonoidal.Î¼ F X' Y) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X' X)
      (F.map (CategoryTheory.MonoidalCategory.whiskerLeft X' f))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerLeft
  (cifvar_16 (cifvar_17 cifvar_18) x_0) (cifvar_4 x_1)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MulEquiv.toCommGrpIso_inv : âˆ€ {X Y : CommGrp} (e : â†‘X â‰ƒ* â†‘Y), e.toCommGrpIso.inv = e.symm.toMonoidHom
Result.success

Testing || ContinuousMap.one_apply : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : _root_.One Î²]
  (x : Î±), 1 x = 1
Result.success

Testing || Submonoid.LocalizationMap.mk'_sec : âˆ€ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N]
  (f : S.LocalizationMap N) (z : N), f.mk' (f.sec z).1 (f.sec z).2 = z
Result.exception ::
Auto.Reif.resolveTy :: Unable to resolve âˆ€ (y : â†¥S), IsUnit (f.toMonoidHom â†‘y)

Testing || ZMod.exists : âˆ€ {n : â„•} {P : ZMod n â†’ Prop}, (âˆƒ x, P x) â†” âˆƒ x, P â†‘x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ZMod.commRing x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.getD_map : âˆ€ {Î± : Type u} {Î² : Type v} (l : List Î±) (d : Î±) {n : â„•} (f : Î± â†’ Î²), (List.map f l).getD n (f d) = f (l.getD n d)
Result.success

Testing || Antitone.ge_of_tendsto : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [inst_2 : OrderClosedTopology Î±]
  [inst_3 : SemilatticeInf Î²] {f : Î² â†’ Î±} {a : Î±},
  Antitone f â†’ Filter.Tendsto f Filter.atBot (nhds a) â†’ âˆ€ (b : Î²), f b â‰¤ a
Result.success

Testing || Function.Semiconj.surjOn_range : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {f : Î± â†’ Î²},
  Function.Semiconj f fa fb â†’ Function.Surjective fa â†’ Set.SurjOn fb (Set.range f) (Set.range f)
Result.success

Testing || ConvexOn.slope_le_of_hasDerivWithinAt_Iio : âˆ€ {S : Set â„} {f : â„ â†’ â„} {x y f' : â„},
  ConvexOn â„ S f â†’ x âˆˆ S â†’ y âˆˆ S â†’ x < y â†’ HasDerivWithinAt f f' (Set.Iio y) y â†’ slope f x y â‰¤ f'
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instDistribLatticeOfLinearOrder`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Cardinal.beth_pos : âˆ€ (o : Ordinal.{u_1}), 0 < Cardinal.beth o
Result.exception ::
Duper saturated

Testing || le_hasProd_of_le_prod : âˆ€ {Î¹ : Type u_1} {Î± : Type u_3} [inst : Preorder Î±] [inst_1 : CommMonoid Î±] [inst_2 : TopologicalSpace Î±] {a c : Î±}
  {f : Î¹ â†’ Î±} [inst_3 : ClosedIciTopology Î±], HasProd f a â†’ (âˆ€ (s : Finset Î¹), c â‰¤ âˆ i âˆˆ s, f i) â†’ c â‰¤ a
Result.success

Testing || exists_compact_superset : âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] {K : Set X},
  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x âˆˆ t of Î» binder contains bound variables

Testing || Option.mem_dite_none_left : âˆ€ {Î± : Type u_1} {p : Prop} {x : Î±} [inst : Decidable p] {l : Â¬p â†’ Option Î±},
  (x âˆˆ if h : p then none else l h) â†” âˆƒ (h : Â¬p), x âˆˆ l h
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.HasFiniteIntegral.smul : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : NormedAddCommGroup Î²]
  {ğ•œ : Type u_5} [inst_1 : NormedAddCommGroup ğ•œ] [inst_2 : SMulZeroClass ğ•œ Î²] [inst_3 : BoundedSMul ğ•œ Î²] (c : ğ•œ)
  {f : Î± â†’ Î²}, MeasureTheory.HasFiniteIntegral f Î¼ â†’ MeasureTheory.HasFiniteIntegral (c â€¢ f) Î¼
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.nadd_lt_nadd_right : âˆ€ {b c : Ordinal.{u}}, b < c â†’ âˆ€ (a : Ordinal.{u}), b.nadd a < c.nadd a
Result.exception ::
Duper saturated

Testing || ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux_real : âˆ€ {q : â„•} {a : ZMod q} [inst : NeZero q],
  IsUnit a â†’
    âˆ€ {x : â„},
      1 < x â†’
        ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a â†‘x =
          â†‘(ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a â†‘x).re
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || edist_zero_left : âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), edist 0 a = â†‘â€–aâ€–â‚Š
Result.success

Testing || SimpleGraph.EdgeDisjointTriangles.farFromTriangleFree : âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} [inst : LinearOrderedField ğ•œ] {G : SimpleGraph Î±} {Îµ : ğ•œ} [inst_1 : Fintype Î±]
  [inst_2 : DecidableRel G.Adj] [inst_3 : DecidableEq Î±],
  G.EdgeDisjointTriangles â†’ Îµ * â†‘(Fintype.card Î± ^ 2) â‰¤ â†‘(G.cliqueFinset 3).card â†’ G.FarFromTriangleFree Îµ
Result.success

Testing || AddSubgroup.index_map_of_injective : âˆ€ {G : Type u_1} {G' : Type u_2} [inst : AddGroup G] [inst_1 : AddGroup G'] (H : AddSubgroup G) {f : G â†’+ G'},
  Function.Injective â‡‘f â†’ (AddSubgroup.map f H).index = H.index * f.range.index
Result.success

Testing || MeasureTheory.integrableOn_Ici_iff_integrableAtFilter_atTop : âˆ€ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]
  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} {a : X} [inst_3 : LinearOrder X] [inst_4 : CompactIccSpace X],
  MeasureTheory.IntegrableOn f (Set.Ici a) Î¼ â†”
    MeasureTheory.IntegrableAtFilter f Filter.atTop Î¼ âˆ§ MeasureTheory.LocallyIntegrableOn f (Set.Ici a) Î¼
Result.exception ::
Duper saturated

Testing || Submodule.copy_eq : âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  (S : Submodule R M) (s : Set M) (hs : s = â†‘S), S.copy s hs = S
Result.exception ::
Duper saturated

Testing || LinearMap.BilinMap.toQuadraticMap_add : âˆ€ {R : Type u_3} {M : Type u_4} {N : Type u_5} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : _root_.Module R M] [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R N]
  (Bâ‚ Bâ‚‚ : LinearMap.BilinMap R M N), (Bâ‚ + Bâ‚‚).toQuadraticMap = Bâ‚.toQuadraticMap + Bâ‚‚.toQuadraticMap
Result.success

Testing || AddSubgroup.leftCosetEquivAddSubgroup.proof_4 : âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] {s : AddSubgroup Î±} (g : Î±) (x : â†¥s),
  (fun x => âŸ¨-g + â†‘x, â‹¯âŸ©) ((fun x => âŸ¨g + â†‘x, â‹¯âŸ©) x) = x
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (h : â†‘xâœ âˆˆ â†‘s âˆ§ g +áµ¥ â†‘xâœ = g + â†‘xâœ),
  â‹¯ = â‹¯, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || Matrix.mulVec_add : âˆ€ {m : Type u_2} {n : Type u_3} {Î± : Type v} [inst : NonUnitalNonAssocSemiring Î±] [inst_1 : Fintype n]
  (A : Matrix m n Î±) (x y : n â†’ Î±), A.mulVec (x + y) = A.mulVec x + A.mulVec y
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Matrix.dotProduct x_1
  (cifvar_7 x_2 x_3)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContDiff.contDiffWithinAt : âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {s : Set E}
  {f : E â†’ F} {x : E} {n : WithTop â„•âˆ}, ContDiff ğ•œ n f â†’ ContDiffWithinAt ğ•œ n f s x
Result.success

Testing || Algebra.algebraMap_ofSubsemiring_apply : âˆ€ {R : Type u} [inst : CommSemiring R] (S : Subsemiring R) (x : â†¥S), (algebraMap (â†¥S) R) x = â†‘x
Result.success

Testing || ProbabilityTheory.IdentDistrib.integral_eq : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]
  [inst_2 : MeasurableSpace Î³] {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³}
  [inst_3 : NormedAddCommGroup Î³] [inst_4 : NormedSpace â„ Î³] [inst_5 : BorelSpace Î³],
  ProbabilityTheory.IdentDistrib f g Î¼ Î½ â†’ âˆ« (x : Î±), f x âˆ‚Î¼ = âˆ« (x : Î²), g x âˆ‚Î½
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `IsClosed x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || convex_ball : âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] (a : E) (r : â„),
  Convex â„ (Metric.ball a r)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : (#1 â†’ #2), ((!7 x0 x1) â†’ (âˆ€ x2 : #2, (!0 (!4 (Î»x3 : #1, ((!5 x0 x3) âˆ§ (!8 (x1 x3) x2))))))))) is not type correct

Testing || Auto.Embedding.Lam.LamValid.imp_self : âˆ€ {lctx : â„• â†’ Embedding.Lam.LamSort} {t : Embedding.Lam.LamTerm} {lval : Embedding.Lam.LamValuation},
  Embedding.Lam.LamWF lval.toLamTyVal
      { lctx := lctx, rterm := t, rty := Embedding.Lam.LamSort.base Embedding.Lam.LamBaseSort.prop } â†’
    Embedding.Lam.LamValid lval lctx (t.mkImp t)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.right_eq_inter : âˆ€ {Î± : Type u} {s t : Set Î±}, t = s âˆ© t â†” t âŠ† s
Result.success

Testing || Pointed.Iso.mk_hom_toFun : âˆ€ {Î± Î² : Pointed} (e : Î±.X â‰ƒ Î².X) (he : e Î±.point = Î².point) (a : Î±.X), (Pointed.Iso.mk e he).hom.toFun a = e a
Result.success

Testing || CategoryTheory.Limits.biproduct.lift_eq : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {J : Type}
  [inst_2 : Fintype J] {f : J â†’ C} [inst_3 : CategoryTheory.Limits.HasBiproduct f] {T : C} {g : (j : J) â†’ T âŸ¶ f j},
  CategoryTheory.Limits.biproduct.lift g =
    âˆ‘ j : J, CategoryTheory.CategoryStruct.comp (g j) (CategoryTheory.Limits.biproduct.Î¹ f j)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `g j`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.toFinset_congr : âˆ€ {Î± : Type u_1} {s t : Set Î±} [inst : Fintype â†‘s] [inst_1 : Fintype â†‘t], s = t â†’ s.toFinset = t.toFinset
Result.exception ::
Duper saturated

Testing || Bimon_.comp_hom' : âˆ€ (C : Type uâ‚) [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C]
  [inst_2 : CategoryTheory.BraidedCategory C] {M N K : Bimon_ C} (f : M âŸ¶ N) (g : N âŸ¶ K),
  (CategoryTheory.CategoryStruct.comp f g).hom = CategoryTheory.CategoryStruct.comp f.hom g.hom
Result.success

Testing || Subgroup.exists_pow_mem_of_relindex_ne_zero : âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G},
  H.relindex K â‰  0 â†’ âˆ€ {a : G}, a âˆˆ K â†’ âˆƒ n, 0 < n âˆ§ n â‰¤ H.relindex K âˆ§ a ^ n âˆˆ H âŠ“ K
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Submonoid.exponent_top : âˆ€ (G : Type u) [inst : Monoid G], Monoid.exponent â†¥âŠ¤ = Monoid.exponent G
Result.exception ::
Duper saturated

Testing || WeierstrassCurve.Ïˆ_neg : âˆ€ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R) (n : â„¤), W.Ïˆ (-n) = -W.Ïˆ n
Result.success

Testing || Std.HashMap.getKey?_eq_some_getKey : âˆ€ {Î± : Type u} {Î² : Type v} {x : BEq Î±} {x_1 : Hashable Î±} {m : Std.HashMap Î± Î²} [inst : EquivBEq Î±]
  [inst : LawfulHashable Î±] {a : Î±} {h' : a âˆˆ m}, m.getKey? a = some (m.getKey a h')
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (h : aâœÂ² âˆˆ mâœ.inner),
  mâœ.getKey aâœÂ² h = mâœ.inner.getKey aâœÂ² h, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || Part.left_dom_of_inter_dom : âˆ€ {Î± : Type u_1} [inst : Inter Î±] {a b : Part Î±}, (a âˆ© b).Dom â†’ a.Dom
Result.exception ::
Duper saturated

Testing || AddUnits.val_neg_ofNSMulEqZero : âˆ€ {M : Type u_1} [inst : AddMonoid M] (a : M) (n : â„•) (ha : n â€¢ a = 0) (hn : n â‰  0),
  â†‘(-AddUnits.ofNSMulEqZero a n ha hn) = (n - 1) â€¢ a
Result.success

Testing || CategoryTheory.GrothendieckTopology.sheafifyCompIso_inv_eq_sheafifyLift : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type wâ‚}
  [inst_1 : CategoryTheory.Category.{max v u, wâ‚} D] {E : Type wâ‚‚} [inst_2 : CategoryTheory.Category.{max v u, wâ‚‚} E]
  (F : CategoryTheory.Functor D E)
  [inst_3 :
    âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±),
      CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D]
  [inst_4 :
    âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±),
      CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E]
  [inst_5 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)áµ’áµ– D]
  [inst_6 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)áµ’áµ– E]
  [inst_7 : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.Cover X)áµ’áµ– F]
  [inst_8 :
    âˆ€ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor Cáµ’áµ– D),
      CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F]
  (P : CategoryTheory.Functor Cáµ’áµ– D) [inst_9 : CategoryTheory.ConcreteCategory D]
  [inst_10 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)]
  [inst_11 : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.Cover X)áµ’áµ– (CategoryTheory.forget D)]
  [inst_12 : (CategoryTheory.forget D).ReflectsIsomorphisms],
  (J.sheafifyCompIso F P).inv = J.sheafifyLift (CategoryTheory.whiskerRight (J.toSheafify P) F) â‹¯
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2.instPreorderCover x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_Î¹ : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  (S : CategoryTheory.ShortComplex C) (hf : S.f = 0) (c : CategoryTheory.Limits.KernelFork S.g)
  (hc : CategoryTheory.Limits.IsLimit c),
  (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).Î¹ = CategoryTheory.Limits.Fork.Î¹ c
Result.success

Testing || finGaloisGroupMap.map_comp : âˆ€ {k : Type u_1} {K : Type u_2} [inst : Field k] [inst_1 : Field K] [inst_2 : Algebra k K]
  {Lâ‚ Lâ‚‚ Lâ‚ƒ : (FiniteGaloisIntermediateField k K)áµ’áµ–} (f : Lâ‚ âŸ¶ Lâ‚‚) (g : Lâ‚‚ âŸ¶ Lâ‚ƒ),
  finGaloisGroupMap (CategoryTheory.CategoryStruct.comp f g) =
    CategoryTheory.CategoryStruct.comp (finGaloisGroupMap f) (finGaloisGroupMap g)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.left_mem_of_mk_mem_sym2 : âˆ€ {Î± : Type u_1} {xs : List Î±} {a b : Î±}, s(a, b) âˆˆ xs.sym2 â†’ a âˆˆ xs
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.tendsto_of_subseq_tendsto : âˆ€ {Î± : Type u_3} {Î¹ : Type u_6} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : l.IsCountablyGenerated],
  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’
    Filter.Tendsto x l f
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (Nat â†’ #3), (âˆ€ x1 : #2, (âˆ€ x2 : #4, (âˆ€ x3 : #5, ((!4 x0 x1 x2) â†’ ((!8 x2 x3) â†’ (!19 (Î»x4 : Nat, (!10 x3 (x0 x4))) x1))))))) is not type correct

Testing || Polynomial.eq_X_sub_C_of_splits_of_single_root : âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) {x : K} {h : Polynomial K},
  Polynomial.Splits i h â†’
    (Polynomial.map i h).roots = {i x} â†’ h = Polynomial.C h.leadingCoeff * (Polynomial.X - Polynomial.C x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.map_id' : âˆ€ {Î± : Type u_1} (l : List Î±), List.map (fun a => a) l = l
Result.success

Testing || AntitoneOn.map_inf : âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {s : Set Î±} {x y : Î±} [inst : LinearOrder Î±] [inst_1 : SemilatticeSup Î²],
  AntitoneOn f s â†’ x âˆˆ s â†’ y âˆˆ s â†’ f (x âŠ“ y) = f x âŠ” f y
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Î± â†’
  Prop, type of âˆ€ bound variable is not of sort `Prop`, and depends on bound variables

Testing || limsInf_nhds : âˆ€ {Î± : Type u_2} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]
  (a : Î±), (nhds a).limsInf = a
Result.exception ::
Duper saturated

Testing || List.map_subset : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {lâ‚ lâ‚‚ : List Î±} (f : Î± â†’ Î²), lâ‚ âŠ† lâ‚‚ â†’ List.map f lâ‚ âŠ† List.map f lâ‚‚
Result.exception ::
(deterministic) timeout at `fluidSup`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HasFDerivAt.mul_const' : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {x : E} {ğ”¸ : Type u_5} [inst_3 : NormedRing ğ”¸] [inst_4 : NormedAlgebra ğ•œ ğ”¸] {a : E â†’ ğ”¸}
  {a' : E â†’L[ğ•œ] ğ”¸}, HasFDerivAt a a' x â†’ âˆ€ (b : ğ”¸), HasFDerivAt (fun y => a y * b) (a'.smulRight b) x
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.card_dvd_card_add_right : âˆ€ {Î± : Type u_2} [inst : AddGroup Î±] [inst_1 : DecidableEq Î±] {s t : Finset Î±},
  ((fun x => x +áµ¥ t) '' â†‘s).PairwiseDisjoint id â†’ t.card âˆ£ (s + t).card
Result.success

Testing || Convex.norm_image_sub_le_of_norm_fderiv_le' : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_3} {G : Type u_4}
  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : IsRCLikeNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E]
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ G} {C : â„} {s : Set E} {x y : E} {Ï† : E â†’L[ğ•œ] G},
  (âˆ€ x âˆˆ s, DifferentiableAt ğ•œ f x) â†’
    (âˆ€ x âˆˆ s, â€–fderiv ğ•œ f x - Ï†â€– â‰¤ C) â†’ Convex â„ s â†’ x âˆˆ s â†’ y âˆˆ s â†’ â€–f y - f x - Ï† (y - x)â€– â‰¤ C * â€–y - xâ€–
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!22 !23 !24) = !0) is not type correct

Testing || Complex.cpow_one : âˆ€ (x : â„‚), x ^ 1 = x
Result.success

Testing || NonUnitalSubalgebra.copy_eq : âˆ€ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : NonUnitalNonAssocSemiring A] [inst_2 : _root_.Module R A]
  (S : NonUnitalSubalgebra R A) (s : Set A) (hs : s = â†‘S), S.copy s hs = S
Result.exception ::
Duper saturated

Testing || List.nodup_permutations : âˆ€ {Î± : Type u_1} (s : List Î±), s.Nodup â†’ s.permutations.Nodup
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Subgroup.pow_mem_of_index_ne_zero_of_dvd : âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G},
  H.index â‰  0 â†’ âˆ€ (a : G) {n : â„•}, (âˆ€ (m : â„•), 0 < m â†’ m â‰¤ H.index â†’ m âˆ£ n) â†’ a ^ n âˆˆ H
Result.success

Testing || natAbs_nsmul_eq_zero : âˆ€ {G : Type u_3} [inst : AddGroup G] {a : G} {n : â„¤}, n.natAbs â€¢ a = 0 â†” n â€¢ a = 0
Result.exception ::
Duper saturated

Testing || Stream'.WSeq.map_comp : âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Î± â†’ Î²) (g : Î² â†’ Î³) (s : Stream'.WSeq Î±),
  Stream'.WSeq.map (g âˆ˜ f) s = Stream'.WSeq.map g (Stream'.WSeq.map f s)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ExistsContDiffBumpBase.y_neg : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]
  [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (D : â„) (x : E),
  ExistsContDiffBumpBase.y D (-x) = ExistsContDiffBumpBase.y D x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!15 !35 !36) = !0) is not type correct

Testing || IsAddCyclic.unique_zsmul_zmod : âˆ€ {Î± : Type u_1} {a : Î±} [inst : AddGroup Î±] [inst_1 : Fintype Î±],
  (âˆ€ (x : Î±), x âˆˆ AddSubgroup.zmultiples a) â†’ âˆ€ (x : Î±), âˆƒ! n, x = n.val â€¢ a
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ZMod.commRing x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matroid.basis_empty_iff : âˆ€ {Î± : Type u_1} {I : Set Î±} (M : Matroid Î±), M.Basis I âˆ… â†” I = âˆ…
Result.success

Testing || contMDiffAt_iff : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {E' : Type u_5} [inst_6 : NormedAddCommGroup E']
  [inst_7 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_8 : TopologicalSpace H'] {I' : ModelWithCorners ğ•œ E' H'}
  {M' : Type u_7} [inst_9 : TopologicalSpace M'] [inst_10 : ChartedSpace H' M'] {n : â„•âˆ} {f : M â†’ M'} {x : M},
  ContMDiffAt I I' n f x â†”
    ContinuousAt f x âˆ§
      ContDiffWithinAt ğ•œ (â†‘n) (â†‘(extChartAt I' (f x)) âˆ˜ f âˆ˜ â†‘(extChartAt I x).symm) (Set.range â†‘I) (â†‘(extChartAt I x) x)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : #1, (âˆ€ x2 : #2, (âˆ€ x3 : (#3 â†’ #4), (âˆ€ x4 : #3, ((!19 (!29 x1 x0 x2) x3 x4) = (!0 x1 x0 x2 x3 x4))))))) is not type correct

Testing || MeasureTheory.IsFundamentalDomain.mk' : âˆ€ {G : Type u_1} {Î± : Type u_3} [inst : Group G] [inst_1 : MulAction G Î±] [inst_2 : MeasurableSpace Î±] {s : Set Î±}
  {Î¼ : MeasureTheory.Measure Î±},
  MeasureTheory.NullMeasurableSet s Î¼ â†’ (âˆ€ (x : Î±), âˆƒ! g, g â€¢ x âˆˆ s) â†’ MeasureTheory.IsFundamentalDomain G s Î¼
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((âˆƒ x0 : #0, ((!14 x0) âˆ§ (!15 (!16 !2) !1 x0))) = (!0 !1 !2)) is not type correct

Testing || not_summable_of_ratio_norm_eventually_ge : âˆ€ {Î± : Type u_2} [inst : SeminormedAddCommGroup Î±] {f : â„• â†’ Î±} {r : â„},
  1 < r â†’ (âˆƒá¶  (n : â„•) in Filter.atTop, â€–f nâ€– â‰  0) â†’ (âˆ€á¶  (n : â„•) in Filter.atTop, r * â€–f nâ€– â‰¤ â€–f (n + 1)â€–) â†’ Â¬Summable f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.atTop`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero : âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},
  inner x y = 0 â†’ Real.sin (InnerProductGeometry.angle x (x + y)) * â€–x + yâ€– = â€–yâ€–
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLT`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContinuousAt.finset_inf_apply : âˆ€ {L : Type u_1} {X : Type u_2} [inst : TopologicalSpace L] [inst_1 : TopologicalSpace X] {Î¹ : Type u_3}
  [inst_2 : SemilatticeInf L] [inst_3 : OrderTop L] [inst_4 : ContinuousInf L] {s : Finset Î¹} {f : Î¹ â†’ X â†’ L} {x : X},
  (âˆ€ i âˆˆ s, ContinuousAt (f i) x) â†’ ContinuousAt (fun a => s.inf fun x => f x a) x
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Elapsed time: 261846 ms

Summary:

0 E CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint
1 S IsCoprime.of_mul_add_right_left
2 S CategoryTheory.evaluation_obj_obj
3 S add_le_of_le_tsub_right_of_le
4 E Matrix.Nondegenerate.exists_not_ortho_of_ne_zero
5 S NonUnitalSubring.closure_eq_of_le
6 S UInt32.intCast_def
7 E MeasureTheory.SignedMeasure.rnDeriv_sub
8 E List.foldlIdx_eq_foldlIdxSpec
9 S Subring.coe_zero
10 S Std.DHashMap.Internal.Rawâ‚€.getKey?_eq_getKey?â‚˜
11 E Multiset.map_univ_coeEmbedding
12 E Ring.multichoose_zero_right'
13 E Filter.EventuallyEq.gradient
14 E Matrix.PosSemidef.eq_of_sq_eq_sq
15 S minpoly.coeff_zero_ne_zero
16 E List.cons_subperm_of_not_mem_of_mem
17 E LinearMap.BilinForm.IsSymm.eq
18 E CategoryTheory.Limits.IsImage.isoExt_inv_m
19 E Equiv.curry_apply
20 E dif_neg
21 E Ordinal.one_CNF
22 S ContinuousAffineMap.sub_contLinear
23 S AddEquiv.instEquivLike.proof_2
24 E List.mapIdx_set
25 E SetTheory.PGame.insertRight_le
26 E nhdsAdjoint_nhds
27 E instUniqueAddUnitsOfSubsingleton.proof_1
28 E Cardinal.mk_coe_finset
29 E CategoryTheory.Sieve.pullback_ofObjects_eq_top
30 S Set.iUnion_option
31 E Ergodic.ae_empty_or_univ_of_preimage_ae_le'
32 E MeasureTheory.Measure.rnDeriv_smul_right_of_ne_top
33 E PartialHomeomorph.coe_trans_symm
34 S Set.bounded_lt_Iic
35 E MeasureTheory.eLpNorm_const_smul_le
36 E CategoryTheory.Iso.isIso_inv
37 E IntermediateField.adjoin_univ
38 S NonemptyInterval.snd_add
39 E CategoryTheory.Bicategory.RightExtension.w_assoc
40 S Disjoint.subset_compl_left
41 E IsAntichain.flip
42 E LowerAdjoint.closure_iUnion_closure
43 S Subsemiring.mem_closure_iff
44 S Real.deriv_cos
45 E Pell.IsFundamental.mul_inv_x_lt_x
46 S Complex.cos_conj
47 E MeasureTheory.Supermartingale.set_integral_le
48 E AddAction.pretransitive_iff_unique_quotient_of_nonempty
49 E InnerProductGeometry.norm_sub_eq_add_norm_of_angle_eq_pi
50 S Finset.union_sdiff_cancel_left
51 E Module.Presentation.finite
52 E LowerSet.mem_iInfâ‚‚_iff
53 S Finsupp.smul_single'
54 S Commute.inv
55 S Finset.Nonempty.piFinset_const
56 E List.cons_sublist_cons'
57 E Set.image_subset_sups_right
58 S FractionalIdeal.mem_extended_iff
59 S Bimod.regular_actRight
60 E TrivSqZeroExt.map_comp_map
61 E StrictConvexOn.slope_lt_of_hasDerivAt
62 E AddUnits.min_val
63 S FreeCommRing.isSupported_add
64 E IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point
65 S ContDiffBump.neg
66 E IsAddSubgroup.normalizer_isAddSubgroup
67 E SubmonoidClass.finsupp_prod_mem
68 E BitVec.sub_add_bmod_cancel
69 E Set.einfsep_iUnion_mem_option
70 E bddAbove_neg
71 E Sat.Fmla.subsumes_left
72 S OrderHom.snd_coe
73 S Quaternion.imK_snd_dualNumberEquiv
74 E AddCommMagma.IsRightCancelAdd.toIsCancelAdd
75 E Finset.sum_smul_vsub_const_eq_affineCombination_vsub
76 E CategoryTheory.Limits.hasTerminalChangeUniverse
77 E Algebra.IsStandardSmooth.localization_away
78 E IsCoprime.dvd_of_dvd_mul_right
79 S UInt32.toUInt16_toNat
80 S Std.Tactic.BVDecide.Normalize.Bool.or_elim
81 S MeasureTheory.SimpleFunc.pair_apply
82 E _private.Mathlib.NumberTheory.FermatPsp.0.Nat.b_id_helper
83 S ofLex_inj
84 S compactlySupported_eq_top
85 E LinearIsometry.map_orthogonalProjection'
86 E ProbabilityTheory.Kernel.iIndepSets.ae_isProbabilityMeasure
87 S Real.exp_ne_zero
88 E Profinite.NobelingProof.GoodProducts.maxToGood_injective
89 E StrictConvexOn.map_sum_eq_iff'
90 E RightCancelSemigroup.ext
91 S Finset.diffs_union_right
92 E CategoryTheory.Functor.relativelyRepresentable.symmetryIso_hom
93 S Fin.rev_sub
94 E Std.Tactic.BVDecide.BVBinPred.eval_ult
95 E List.sum_pos
96 E Ordinal.comp_familyOfBFamily'
97 E star_natCast_smul
98 E SetTheory.PGame.fuzzy_of_fuzzy_of_equiv
99 E LocallyConvexSpace.ofBases
100 E EulerProduct.eulerProduct
101 E Mathlib.Vector.get_ofFn
102 S CategoryTheory.ShortComplex.sub_Ï„â‚
103 E MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq
104 S Complex.sameRay_of_arg_eq
105 E CategoryTheory.Limits.initial.to_comp
106 S BoundedLatticeHom.id_comp
107 S Differentiable.analyticAt
108 E CompleteOrthogonalIdempotents.option
109 S QuaternionAlgebra.neg_mk
110 E Filter.eventually_gt_atTop
111 S NNReal.iSup_mul_le
112 E Padic.AddValuation.map_add
113 S PNat.mod_add_div'
114 E CategoryTheory.SingleFunctors.shiftIso_add'
115 S imaginaryPart_eq_neg_I_smul_skewAdjointPart
116 S Submodule.toAddSubmonoid_eq
117 E DFinsupp.equivFunOnFintype_symm_coe
118 E _private.Mathlib.NumberTheory.Padics.Hensel.0.newton_seq_dist
119 S Multiset.disjoint_add_right
120 E List.Perm.symm
121 S CompleteLat.Iso.mk_hom_toFun
122 E PartENat.card_eq_zero_iff_empty
123 S NonemptyInterval.pure_fst
124 E AlternatingMap.coe_multilinearMap_injective
125 S FreeCommRing.isSupported_sub
126 S MeasureTheory.ae_of_all
127 E CoxeterSystem.not_isRightDescent_iff
128 E RingHom.liftOfRightInverse_comp_apply
129 S LinearIndependent.total_ne_of_not_mem_support
130 E CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso
131 E AntivaryOn.of_neg_right
132 E DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul
133 E Int.bitwise_or
134 S Filter.eventuallyLE_congr
135 S ProbabilityTheory.Kernel.compProd_apply
136 S List.cons_head!_tail
137 S hasSum_geometric_of_abs_lt_one
138 E PolynomialModule.eval_map'
139 E WittVector.mul_polyOfInterest_aux1
140 E Filter.Tendsto.inv_tendsto_zero
141 E Submodule.convex
142 E Submodule.quotientPi_apply
143 S FirstOrder.Language.Formula.equivSentence_inf
144 S TrivSqZeroExt.isUnit_or_isNilpotent
145 E ZMod.val_add_of_le
146 S MvPowerSeries.order_le
147 S AffineMap.snd_linear
148 S LinearEquiv.coe_coe
149 S LinearEquiv.sumArrowLequivProdArrow_symm_apply_inr
150 E Finset.Nontrivial.pow
151 E WeierstrassCurve.Affine.Point.some_add_some_of_Yne
152 S isCoprime_mul_unit_right_left
153 S ciInf_le_of_le'
154 E RingHom.map_mulVec
155 E Ordinal.dvd_of_mod_eq_zero
156 E Profinite.projective_of_extrDisc
157 E FirstOrder.Language.Substructure.mem_inf
158 E ModuleCat.ExtendScalars.map'_id
159 E Real.sin_zero
160 S CategoryTheory.Sigma.inclCompMap_inv_app
161 S div_mul_cancel_left
162 E AlgebraicGeometry.IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux
163 E MeasureTheory.OuterMeasure.mkMetric_top
164 S Std.DHashMap.Internal.Rawâ‚€.getKey?_eq_none
165 E WithTop.pow_right_strictMono
166 S ofBoolRing_symm_eq
167 E MvPolynomial.C_dvd_iff_zmod
168 E CategoryTheory.MonoidalCategory.whiskerLeftIso_trans
169 S EReal.coe_ennreal_le_coe_ennreal_iff
170 S NonUnitalSubring.coe_bot
171 E innerDualCone_eq_iInter_innerDualCone_singleton
172 E Set.iUnion_sub_left_image
173 S SetTheory.PGame.lf_of_lf_of_le
174 E MeasureTheory.eLpNorm_trim_ae
175 E List.Perm.subset
176 E Complex.differentiableAt_cos
177 S CategoryTheory.Functor.Iteration.truncFunctor_obj
178 S RelEmbedding.map_rel_iff
179 S SymAlg.sym_ne_zero_iff
180 E AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber
181 S Complex.abs_im_eq_abs
182 E Ordinal.principal_swap_iff
183 E MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq
184 S PartialEquiv.restr_univ
185 E MeasureTheory.AEFinStronglyMeasurable.ae_nonneg_of_forall_setIntegral_nonneg
186 E Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.limplies_of_assignmentsInvariant
187 S CategoryTheory.Square.Hom.comp_Ï„â‚„
188 S Eq.congr_left
189 E LieAlgebra.exists_isRegular_of_finrank_le_card
190 E leftInverse_add_left_sub
191 E MeasurableSpace.generateFrom_measurableSet
192 E MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure
193 E Profinite.NobelingProof.GoodProducts.linearIndependentAux
194 S BddAbove.isBoundedUnder_of_range
195 E FractionalIdeal.num_eq_zero_iff
196 E Finset.ruzsa_covering_mul
197 S Matrix.head_cons
198 S Set.image_neg_Ici
199 E Set.natCard_div_le
200 E Finset.mem_disjSum
201 E CategoryTheory.pseudofunctorOfIsLocallyDiscrete_mapComp
202 E Std.DHashMap.getKey_insert_self
203 S map_symmDiff
204 E BoundedContinuousFunction.norm_lt_iff_of_compact
205 S WithTop.sum_eq_top_iff
206 E Real.le_sSup_iff
207 E Associated.prod
208 E Fin.cycleRange_zero
209 E HolorIndex.cast_type
210 S UpperHalfPlane.coe_mk
211 E Nat.one_lt_pow_iff
212 E MeasureTheory.FiniteMeasure.null_iff_toMeasure_null
213 E min_mul_min_le_min_mul_mul'
214 E List.smul_sum
215 E LinearMap.compQuadraticMap_polar
216 E lowerBounds_infClosure
217 S Ordinal.lsub_le
218 S Subsemigroup.comap_top
219 S CofiniteTopology.continuous_of
220 S LE.le.add_eq_left
221 E ContMDiffAt.clm_comp
222 E CategoryTheory.regularTopology.isSheafFor_regular_of_projective
223 E QuotSMulTop.map_comp
224 S MeasureTheory.IntegrableOn.union
225 S Int.lt_mul_of_ediv_lt
226 S MeasureTheory.SimpleFunc.GCongr.mk_le_mk
227 E cfcâ‚™HomSuperset_id'
228 E ContinuousMap.sup_mem_subalgebra_closure
229 S IsFractionRing.associated_num_den_inv
230 E Con.le_comap_conGen
231 S TopologicalSpace.CompactOpens.coe_mk
232 E Metric.cthickening_thickening_subset
233 S mul_right_eq_selfâ‚€
234 E AlgHom.ker_rangeRestrict
235 E AlgHom.map_smul_of_tower
236 E wellFoundedGT_antisymmetrization_iff
237 S frontier_Icc
238 E Set.compl_singleton_eq
239 E ContinuousMap.dist_le_iff_of_nonempty
240 E MeasureTheory.IsFundamentalDomain.measure_ne_zero
241 S AffineSubspace.sOppSide_lineMap_right
242 E Projectivization.map_injective
243 E Submodule.le_comap_single_pi
244 S deriv_update
245 E Submonoid.map_iInf
246 S Combinatorics.Subspace.coe_apply
247 E FreeSemigroup.ext
248 S SetTheory.PGame.one_leftMoves
249 E OrderIso.equivalence_unitIso
250 S Module.reflection_apply
251 E CategoryTheory.ComonadHom.ext'
252 E NumberField.InfinitePlace.comap_surjective
253 E Substring.ValidFor.drop
254 E ZMod.pow_div_two_eq_neg_one_or_one
255 E CauchyFilter.denseRange_pureCauchy
256 E mem_tangentCone_of_openSegment_subset
257 S WeierstrassCurve.Î¨â‚‚Sq_eq
258 S Monoid.exponent_pos
259 E Nat.clog_of_two_le
260 S NonemptyInterval.fst_nsmul
261 E AddSubgroup.comap.proof_1
262 E Order.pred_iterate_le
263 E OrderHom.map_lfp_comp
264 S Subgroup.le_topologicalClosure
265 S CategoryTheory.Functor.mapHomotopyCategory_obj
266 E list_sum_mem
267 S Codisjoint.symm
268 S Nat.succ_iterate
269 S Lean.Omega.Int.lt_of_not_le
270 E Matrix.mul_submatrix_one
271 E QuadraticModuleCat.toIsometry_id
272 S InnerProductSpace.Core.inner_sub_left
273 S Nat.mul_lt_mul_of_lt_of_le'
274 S SmoothPartitionOfUnity.toPartitionOfUnity_toFun
275 S Submodule.quotDualCoannihilatorToDual_apply
276 E IsCompact.nhdsSet_inf_eq_biSup
277 E exists_disjoint_smul_of_isCompact
278 E exists_setIndependent_of_sSup_atoms_eq_top
279 E NNReal.mk_one
280 S leOnePart_le_one'
281 S Functor.mapEquiv_symm_apply
282 E OrderEmbedding.preimage_Ioi
283 S CentroidHom.toEnd_pow
284 E List.ofFn_mul'
285 E Set.iUnion_nonempty_self
286 S CategoryTheory.ShortComplex.RightHomologyMapData.smul_Ï†H
287 E EMetric.ball_mem_nhds
288 E SymplecticGroup.symplectic_det
289 E tendsto_ceil_left_pure_ceil
290 E Finset.cons_induction
291 E MvPolynomial.coe_eq_zero_iff
292 E CategoryTheory.Comma.toIdPUnitEquiv_counitIso_hom_app
293 E aeSeq.prop_of_mem_aeSeqSet
294 E List.Nodup.isCycleOn_formPerm
295 E CategoryTheory.Limits.image.Î¹_zero'
296 S Bornology.IsCobounded.closedBall_compl_subset
297 E Complex.abs_im_lt_abs
298 E Trivialization.Prod.continuous_to_fun
299 S IsGLB.sInf_eq
300 S le_of_forall_pos_sub_le
301 E TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks
302 E WeierstrassCurve.variableChange_Î”
303 S AlgEquiv.toRingEquiv_symm
304 E GenContFract.zeroth_cont_eq_h_one
305 E List.getElem_drop
306 E ContinuousOn.mono_rng
307 E Set.image_mulSingle_uIcc_left
308 E StarAlgebra.elemental.self_mem
309 E Ordinal.sub_le_self
310 E SemiconjBy.pow_right
311 E AddSubgroup.quotientEquivSumOfLE'.proof_4
312 S Order.krullDim_nat
313 E PNat.gcd_comm
314 E TrivSqZeroExt.map_comp_inlAlgHom
315 S Matrix.toLinearMapâ‚›â‚—â‚‚'_symm
316 E AlgebraicGeometry.PresheafedSpace.Hom.ext
317 S DiscreteQuotient.leComap_id_iff
318 S String.Pos.mk_le_mk
319 S one_div_mul_add_mul_one_div_eq_one_div_add_one_div
320 S MeasureTheory.Measure.restrict_add_restrict_compl
321 E SupClosed.preimage
322 E ContMDiffAt.neg
323 E Cardinal.lift_umax
324 E TypeVec.fst_diag
325 S Real.zero_rpow_le_one
326 E LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad
327 E CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_inv_app_fiber
328 E MvPolynomial.sum_eval_eq_zero
329 E convex_halfSpace_re_le
330 E interior_halfspace
331 E Pi.negPart_apply
332 E AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing_map_apply
333 E CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence
334 E HasProd.update'
335 E Matrix.trace_transpose
336 S CategoryTheory.Cat.freeRefl_obj_str_comp
337 E TensorProduct.add_tmul
338 E toZ_of_ge
339 S ContinuousAlternatingMap.ofSubsingleton_apply_toContinuousMultilinearMap
340 E TopologicalGroup.of_comm_of_nhds_one
341 E Filter.ZeroAtFilter.boundedAtFilter
342 S Turing.ListBlank.nth_mk
343 E CategoryTheory.epi_iff_surjective
344 E Multiset.le_prod_of_submultiplicative_on_pred
345 E Fin.sum_univ_six
346 E List.isRotated_singleton_iff
347 S CategoryTheory.Equivalence.changeInverse_counitIso_hom_app
348 E CategoryTheory.comp_eqToHom_heq
349 E Multiset.toFinset_nsmul
350 S Quotient.out_eq'
351 S IsLocalizedModule.mk'_add
352 S IntermediateField.equivOfEq_symm
353 S MeasureTheory.eLpNormEssSup_const
354 E Ideal.map_radical_of_surjective
355 E Submodule.smul_torsionBy
356 E dite_ite_distrib_right
357 S CategoryTheory.Limits.cofan_mk_inj
358 E Mathlib.Tactic.Monoidal.evalHorizontalCompAux'_whisker
359 S Subring.mem_bot
360 E MeasurableSet.cylinder
361 S IsSelfAdjoint.zpow
362 E CliffordAlgebra.ofBaseChange_comp_toBaseChange
363 E uniformEquicontinuousOn_unique
364 S Metric.continuous_infNndist_pt
365 S IntermediateField.pow_mem
366 E CochainComplex.HomComplex.Cochain.map_comp
367 S ModelWithCorners.toHomeomorph_apply
368 S isBot_iff_isMin
369 E Cardinal.toPartENat_lift
370 E AlgHom.range_comp_le_range
371 S DifferentiableWithinAt.const_cpow
372 E SetTheory.PGame.memâ‚—.congr_left
373 E iSup_inf_eq
374 E MulHom.coe_coe
375 E PresheafOfModules.toSheaf_map_sheafificationHomEquiv_symm
376 E compl_bihimp_self
377 S CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_Ï†Q
378 E Basis.card_le_card_of_linearIndependent
379 E Orientation.rotation_trans
380 E IsPrimitiveRoot.sub_one_norm_isPrimePow
381 S Stream'.tail_eq_drop
382 E UniformEquiv.piCongrRight_apply
383 S Matrix.mulVec_empty
384 E MvPolynomial.isHomogeneous_C
385 S NonUnitalStarSubalgebra.mem_map
386 E uniqueDiffWithinAt_Iio
387 E strictMonoOn_Ici_of_pred_lt
388 E groupCohomology.twoCocycles_ext
389 E BitVec.getMsbD_one
390 E NormedSpace.exp_zero
391 E MeromorphicOn.inv_iff
392 S WithLp.prod_norm_equiv_symm
393 E Ordinal.add_omega0_opow
394 E Module.AEval.isTorsion_of_aeval_eq_zero
395 E MeasureTheory.ae_toFiniteAux
396 E Topology.IsEmbedding.restrictPreimage
397 E AddSubmonoid.unop_closure
398 S Monoid.Coprod.fst_apply_inl
399 S SemidirectProduct.rightHom_comp_inr
400 S Equiv.uniformEmbedding
401 E Set.LeftInvOn.eq
402 E Multiset.mem_powersetAux
403 S Topology.IsEmbedding.t2Space
404 S Option.isSome_unattach
405 E AddChar.zmod_char_ne_one_iff
406 E IsAddUnit.add
407 E Polynomial.evalâ‚‚_C_X
408 E MeasureTheory.AEEqFun.pair_eq_mk
409 E Multiset.card_mono
410 E ContinuousMap.coe_copy
411 S Module.mapEvalEquiv_symm_apply
412 S ExceptCpsT.run_throw
413 S Polynomial.hasseDeriv_X
414 S Array.get?_eq_get?_toList
415 S Matroid.spanning_iff_exists_base_subset
416 E Sum.bnot_isRight
417 E Function.zero_of_even_and_odd
418 E groupCohomology.mem_oneCocycles_def
419 E Real.mul_lt_sin
420 S Finsupp.neLocus_neg
421 E LinearMap.hasBasis_weakBilin
422 S MeasureTheory.snorm'_lt_top_of_snorm'_lt_top_of_exponent_le
423 S Algebra.TensorProduct.assoc_symm_tmul
424 E MeasureTheory.integral_add
425 S Finset.filter_empty
426 E ContinuousLinearMap.exist_extension_of_finiteDimensional_range
427 E MulDissociated.of_inv
428 S Equiv.Perm.support_cycleOf_eq_nil_iff
429 E Pell.exists_of_not_isSquare
430 E CategoryTheory.biproduct_Î¹_comp_leftDistributor_hom_assoc
431 E UniformSpace.Completion.continuous_dist
432 E RingEquiv.piEquivPiSubtypeProd_symm_apply
433 E CochainComplex.HomComplex.Cocycle.Î´_eq_zero
434 S MulEquiv.comapSubgroup_apply
435 E EquivLike.coe_symm_comp_self
436 E CategoryTheory.Functor.relativelyRepresentable.symmetry_snd_assoc
437 S AddMonoid.Coprod.snd_apply_inr
438 E CategoryTheory.Limits.Î¹_comp_colimitRightOpIsoUnopLimit_hom_assoc
439 E MeasureTheory.lintegral_singleton
440 E ContinuousMultilinearMap.norm_def
441 S List.nil_product
442 E Std.DHashMap.getKeyD_erase
443 E Set.iSup_iInf_of_monotone
444 E Set.biUnion_le_eq_iUnion
445 E CategoryTheory.Functor.LaxMonoidal.Î¼_natural_right
446 S MulEquiv.toCommGrpIso_inv
447 S ContinuousMap.one_apply
448 E Submonoid.LocalizationMap.mk'_sec
449 E ZMod.exists
450 S List.getD_map
451 S Antitone.ge_of_tendsto
452 S Function.Semiconj.surjOn_range
453 E ConvexOn.slope_le_of_hasDerivWithinAt_Iio
454 E Cardinal.beth_pos
455 S le_hasProd_of_le_prod
456 E exists_compact_superset
457 E Option.mem_dite_none_left
458 E MeasureTheory.HasFiniteIntegral.smul
459 E Ordinal.nadd_lt_nadd_right
460 E ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux_real
461 S edist_zero_left
462 S SimpleGraph.EdgeDisjointTriangles.farFromTriangleFree
463 S AddSubgroup.index_map_of_injective
464 E MeasureTheory.integrableOn_Ici_iff_integrableAtFilter_atTop
465 E Submodule.copy_eq
466 S LinearMap.BilinMap.toQuadraticMap_add
467 E AddSubgroup.leftCosetEquivAddSubgroup.proof_4
468 E Matrix.mulVec_add
469 S ContDiff.contDiffWithinAt
470 S Algebra.algebraMap_ofSubsemiring_apply
471 E ProbabilityTheory.IdentDistrib.integral_eq
472 E convex_ball
473 E Auto.Embedding.Lam.LamValid.imp_self
474 S Set.right_eq_inter
475 S Pointed.Iso.mk_hom_toFun
476 E CategoryTheory.Limits.biproduct.lift_eq
477 E Set.toFinset_congr
478 S Bimon_.comp_hom'
479 E Subgroup.exists_pow_mem_of_relindex_ne_zero
480 E Submonoid.exponent_top
481 S WeierstrassCurve.Ïˆ_neg
482 E Std.HashMap.getKey?_eq_some_getKey
483 E Part.left_dom_of_inter_dom
484 S AddUnits.val_neg_ofNSMulEqZero
485 E CategoryTheory.GrothendieckTopology.sheafifyCompIso_inv_eq_sheafifyLift
486 S CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_Î¹
487 E finGaloisGroupMap.map_comp
488 E List.left_mem_of_mk_mem_sym2
489 E Filter.tendsto_of_subseq_tendsto
490 E Polynomial.eq_X_sub_C_of_splits_of_single_root
491 S List.map_id'
492 E AntitoneOn.map_inf
493 E limsInf_nhds
494 E List.map_subset
495 E HasFDerivAt.mul_const'
496 S Finset.card_dvd_card_add_right
497 E Convex.norm_image_sub_le_of_norm_fderiv_le'
498 S Complex.cpow_one
499 E NonUnitalSubalgebra.copy_eq
500 E List.nodup_permutations
501 S Subgroup.pow_mem_of_index_ne_zero_of_dvd
502 E natAbs_nsmul_eq_zero
503 E Stream'.WSeq.map_comp
504 E ExistsContDiffBumpBase.y_neg
505 E IsAddCyclic.unique_zsmul_zmod
506 S Matroid.basis_empty_iff
507 E contMDiffAt_iff
508 E MeasureTheory.IsFundamentalDomain.mk'
509 E not_summable_of_ratio_norm_eventually_ge
510 E InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero
511 E ContinuousAt.finset_inf_apply

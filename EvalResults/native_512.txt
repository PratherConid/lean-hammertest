Config = {maxHeartbeats := 65536, timeout := 10, solverConfig := native, logFile := evalAutoOut.txt}

Testing || FiniteDimensional.trans : âˆ€ (F : Type u_1) (K : Type u_2) (A : Type u_3) [inst : DivisionRing F] [inst_1 : DivisionRing K]
  [inst_2 : AddCommGroup A] [inst_3 : _root_.Module F K] [inst_4 : _root_.Module K A] [inst_5 : _root_.Module F A]
  [inst_6 : IsScalarTower F K A] [inst_7 : FiniteDimensional F K] [inst_8 : FiniteDimensional K A],
  FiniteDimensional F A
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Module.Finite cifvar_6 cifvar_7`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Complex.instIsComplete : CauSeq.IsComplete â„‚ â‡‘Complex.abs
Result.exception ::
Duper saturated

Testing || ContDiffOn.norm_sq : âˆ€ (ğ•œ : Type u_1) {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst : InnerProductSpace ğ•œ E]
  [inst : NormedSpace â„ E] {G : Type u_4} [inst_2 : NormedAddCommGroup G] [inst_3 : NormedSpace â„ G] {f : G â†’ E}
  {s : Set G} {n : WithTop â„•âˆ}, ContDiffOn â„ n f s â†’ ContDiffOn â„ n (fun y => â€–f yâ€– ^ 2) s
Result.exception ::
Duper saturated

Testing || PartialHomeomorph.isOpen_image_iff_of_subset_source : âˆ€ {X : Type u_1} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (e : PartialHomeomorph X Y)
  {s : Set X}, s âŠ† e.source â†’ (IsOpen (â†‘e '' s) â†” IsOpen s)
Result.exception ::
Duper saturated

Testing || CategoryTheory.Functor.IsEventuallyConstantTo.coneÏ€App_eq_id : âˆ€ {J : Type u_1} {C : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} J]
  [inst_1 : CategoryTheory.Category.{u_3, u_2} C] {F : CategoryTheory.Functor J C} {iâ‚€ : J}
  (h : F.IsEventuallyConstantTo iâ‚€) [inst_2 : CategoryTheory.IsCofiltered J],
  h.coneÏ€App iâ‚€ = CategoryTheory.CategoryStruct.id (F.obj iâ‚€)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (h : F.IsEventuallyConstantTo iâ‚€),
  CategoryTheory.CategoryStruct.comp (h.isoMap (CategoryTheory.IsCofiltered.minToLeft iâ‚€ iâ‚€) â‹¯).inv
      (F.map (CategoryTheory.IsCofiltered.minToRight iâ‚€ iâ‚€)) =
    h.coneÏ€App iâ‚€, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || CompHausLike.hasPullbacksOfInclusions : âˆ€ {P : TopCat â†’ Prop} [inst : CompHausLike.HasExplicitFiniteCoproducts P],
  (âˆ€ â¦ƒX Y B : CompHausLike Pâ¦„ (f : X âŸ¶ B) (g : Y âŸ¶ B),
      Topology.IsOpenEmbedding â‡‘f â†’ CompHausLike.HasExplicitPullback f g) â†’
    CompHausLike.HasExplicitPullbacksOfInclusions P
Result.exception ::
Duper saturated

Testing || List.mem_flatten : âˆ€ {Î± : Type u_1} {a : Î±} {L : List (List Î±)}, a âˆˆ L.flatten â†” âˆƒ l âˆˆ L, a âˆˆ l
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Polynomial.cyclotomic_two : âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 2 R = Polynomial.X + 1
Result.success

Testing || BoxIntegral.Box.dist_le_distortion_mul : âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] (I : BoxIntegral.Box Î¹) (i : Î¹),
  dist I.lower I.upper â‰¤ â†‘I.distortion * (I.upper i - I.lower i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderedAddCommGroup.toAddCommGroup`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || mul_le_of_le_of_le_one_of_nonneg : âˆ€ {Î± : Type u_3} {a b c : Î±} [inst : MulOneClass Î±] [inst_1 : _root_.Zero Î±] [inst_2 : Preorder Î±]
  [inst_3 : PosMulMono Î±], b â‰¤ c â†’ a â‰¤ 1 â†’ 0 â‰¤ b â†’ b * a â‰¤ c
Result.success

Testing || CategoryTheory.Limits.hasCoequalizers_of_hasPushouts_and_binary_coproducts : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C]
  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasCoequalizers C
Result.exception ::
Duper saturated

Testing || Function.OfArity.uncurry_two_eq_uncurry : âˆ€ {Î± Î² : Type u} (f : Function.OfArity Î± Î² 2), f.uncurry = Function.uncurry f âˆ˜ â‡‘(finTwoArrowEquiv Î±)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Matrix.vecHead aâœÂ³ â†’
  Function.FromTypes (Matrix.vecTail aâœÂ³)
    aâœÂ², type of âˆ€ bound variable is not of sort `Prop`, and depends on bound variables

Testing || mem_own_rightAddCoset : âˆ€ {Î± : Type u_1} [inst : AddMonoid Î±] (s : AddSubmonoid Î±) (a : Î±), a âˆˆ AddOpposite.op a +áµ¥ â†‘s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Ideal.isHomogeneous_iff_forall_subset : âˆ€ {Î¹ : Type u_1} {Ïƒ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : SetLike Ïƒ A]
  [inst_2 : AddSubmonoidClass Ïƒ A] (ğ’œ : Î¹ â†’ Ïƒ) [inst_3 : DecidableEq Î¹] [inst_4 : AddMonoid Î¹] [inst_5 : GradedRing ğ’œ]
  (I : Ideal A), Ideal.IsHomogeneous ğ’œ I â†” âˆ€ (i : Î¹), â†‘I âŠ† â‡‘(GradedRing.proj ğ’œ i) â»Â¹' â†‘I
Result.exception ::
Duper saturated

Testing || AlgebraicGeometry.Scheme.evaluation_naturality : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) {V : Y.Opens} (x : â†‘â†‘X.toPresheafedSpace) (hx : f.base x âˆˆ V),
  CategoryTheory.CategoryStruct.comp (Y.evaluation V (f.base x) hx) (AlgebraicGeometry.Scheme.Hom.residueFieldMap f x) =
    CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f V)
      (X.evaluation ((TopologicalSpace.Opens.map f.base).obj V) x hx)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.SingleObj.mapHom_comp : âˆ€ {M : Type u} [inst : Monoid M] {N : Type v} [inst_1 : Monoid N] (f : M â†’* N) {P : Type w} [inst_2 : Monoid P]
  (g : N â†’* P),
  (CategoryTheory.SingleObj.mapHom M P) (g.comp f) =
    ((CategoryTheory.SingleObj.mapHom M N) f).comp ((CategoryTheory.SingleObj.mapHom N P) g)
Result.success

Testing || isAddUnit_of_add_isAddUnit_right : âˆ€ {M : Type u_1} [inst : AddCommMonoid M] {x y : M}, IsAddUnit (x + y) â†’ IsAddUnit y
Result.success

Testing || PMF.toOuterMeasure_uniformOfFintype_apply : âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Nonempty Î±] (s : Set Î±),
  (PMF.uniformOfFintype Î±).toOuterMeasure s = â†‘(Fintype.card â†‘s) / â†‘(Fintype.card Î±)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (hs : Finset.univ.Nonempty),
  PMF.uniformOfFintype Î± = PMF.uniformOfFinset Finset.univ hs, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  (K : ChainComplex C â„•) [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] {Î” Î”' : SimplexCategoryáµ’áµ–}
  (A : SimplicialObject.Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') {Î”'' : SimplexCategory} {e : Opposite.unop Î”' âŸ¶ Î”''}
  {i : Î”'' âŸ¶ Opposite.unop A.fst} [inst_3 : CategoryTheory.Epi e] [inst_4 : CategoryTheory.Mono i],
  CategoryTheory.CategoryStruct.comp e i = CategoryTheory.CategoryStruct.comp Î¸.unop A.e â†’
    CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”).inj A)
        ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map Î¸) =
      CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i)
        (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”').inj (SimplicialObject.Splitting.IndexSet.mk e))
Result.exception ::
Duper saturated

Testing || CircleDeg1Lift.le_iterate_of_add_int_le_map : âˆ€ (f : CircleDeg1Lift) {x : â„} {m : â„¤}, x + â†‘m â‰¤ f x â†’ âˆ€ (n : â„•), x + â†‘n * â†‘m â‰¤ (â‡‘f)^[n] x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ProbabilityTheory.Kernel.iIndepFun.meas_biInter : âˆ€ {Î± : Type u_1} {Î© : Type u_2} {Î¹ : Type u_3} {Î² : Î¹ â†’ Type u_4} {mÎ² : (i : Î¹) â†’ MeasurableSpace (Î² i)}
  {_mÎ± : MeasurableSpace Î±} {_mÎ© : MeasurableSpace Î©} {Îº : ProbabilityTheory.Kernel Î± Î©} {Î¼ : MeasureTheory.Measure Î±}
  {s : Î¹ â†’ Set Î©} {S : Finset Î¹} {f : (x : Î¹) â†’ Î© â†’ Î² x},
  ProbabilityTheory.Kernel.iIndepFun mÎ² f Îº Î¼ â†’
    (âˆ€ i âˆˆ S, MeasurableSet (s i)) â†’ âˆ€áµ (a : Î±) âˆ‚Î¼, (Îº a) (â‹‚ i âˆˆ S, s i) = âˆ i âˆˆ S, (Îº a) (s i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `f x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Functor.comp_obj : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {E : Type uâ‚ƒ} [inst_2 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E] (F : CategoryTheory.Functor C D)
  (G : CategoryTheory.Functor D E) (X : C), (F.comp G).obj X = G.obj (F.obj X)
Result.success

Testing || genericPoint_closure : âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : QuasiSober Î±] [inst_2 : IrreducibleSpace Î±],
  closure {genericPoint Î±} = Set.univ
Result.exception ::
Duper saturated

Testing || AddMonoidHom.noncommCoprod.proof_2 : âˆ€ {M : Type u_1} {N : Type u_2} {P : Type u_3} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] [inst_2 : AddMonoid P]
  (f : M â†’+ P) (g : N â†’+ P) (comm : âˆ€ (m : M) (n : N), AddCommute (f m) (g n)) (x y : M Ã— N),
  ((â†‘f).noncommCoprod (â†‘g) comm).toFun (x + y) =
    ((â†‘f).noncommCoprod (â†‘g) comm).toFun x + ((â†‘f).noncommCoprod (â†‘g) comm).toFun y
Result.success

Testing || Finset.coe_mem : âˆ€ {Î± : Type u_1} {s : Finset Î±} (x : â†‘â†‘s), â†‘x âˆˆ s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : #1, ((!4 (!6 (!7 x0)) x1) = (!0 x0 x1)))) is not type correct

Testing || Real.nat_cast_lt_toNNReal : âˆ€ {r : â„} {n : â„•}, â†‘n < r.toNNReal â†” â†‘n < r
Result.success

Testing || AddMonoidAlgebra.lift_apply : âˆ€ {k : Type uâ‚} {G : Type uâ‚‚} [inst : CommSemiring k] [inst_1 : AddMonoid G] {A : Type uâ‚ƒ} [inst_2 : Semiring A]
  [inst_3 : Algebra k A] (F : Multiplicative G â†’* A) (f : MonoidAlgebra k G),
  ((AddMonoidAlgebra.lift k G A) F) f = Finsupp.sum f fun a b => b â€¢ F (Multiplicative.ofAdd a)
Result.exception ::
Duper saturated

Testing || Finset.sup_singleton : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SemilatticeSup Î±] [inst_1 : OrderBot Î±] {f : Î² â†’ Î±} {b : Î²}, {b}.sup f = f b
Result.success

Testing || Complex.I_mul_im : âˆ€ (z : â„‚), (Complex.I * z).im = z.re
Result.exception ::
Duper saturated

Testing || Option.orElse_none' : âˆ€ {Î± : Type u_1} (x : Option Î±), (x.orElse fun x => none) = x
Result.exception ::
Duper saturated

Testing || Module.Flat.iff_lTensor_exact : âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M],
  Module.Flat R M â†”
    âˆ€ â¦ƒN N' N'' : Type (max u v)â¦„ [inst_3 : AddCommGroup N] [inst_4 : AddCommGroup N'] [inst_5 : AddCommGroup N'']
      [inst_6 : _root_.Module R N] [inst_7 : _root_.Module R N'] [inst_8 : _root_.Module R N''] â¦ƒf : N â†’â‚—[R] N'â¦„
      â¦ƒg : N' â†’â‚—[R] N''â¦„, Function.Exact â‡‘f â‡‘g â†’ Function.Exact â‡‘(LinearMap.lTensor M f) â‡‘(LinearMap.lTensor M g)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddCommGroup.toAddCommMonoid`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Int.emod_negSucc : âˆ€ (m : â„•) (n : â„¤), Int.negSucc m % n = Int.subNatNat n.natAbs (m % n.natAbs).succ
Result.success

Testing || Set.preimage_injective : âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²}, Function.Injective (Set.preimage f) â†” Function.Surjective f
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HurwitzZeta.completedCosZeta_one_sub : âˆ€ (a : UnitAddCircle) (s : â„‚), HurwitzZeta.completedCosZeta a (1 - s) = HurwitzZeta.completedHurwitzZetaEven a s
Result.success

Testing || List.TFAE.out : âˆ€ {l : List Prop},
  l.TFAE â†’
    âˆ€ (nâ‚ nâ‚‚ : â„•) {a b : Prop}, autoParam (l.get? nâ‚ = some a) _autoâœ â†’ autoParam (l.get? nâ‚‚ = some b) _autoâœÂ¹ â†’ (a â†” b)
Result.exception ::
Duper saturated

Testing || CommRingCat.Under.equalizerFork'_Î¹ : âˆ€ {R : CommRingCat} {A B : Type u} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra (â†‘R) A]
  [inst_3 : Algebra (â†‘R) B] (f g : A â†’â‚[â†‘R] B),
  (CommRingCat.Under.equalizerFork' f g).Î¹ = (AlgHom.equalizer f g).val.toUnder
Result.success

Testing || OrderIso.map_csSup' : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : ConditionallyCompleteLattice Î±] [inst_1 : ConditionallyCompleteLattice Î²]
  (e : Î± â‰ƒo Î²) {s : Set Î±}, s.Nonempty â†’ BddAbove s â†’ e (sSup s) = sSup (â‡‘e '' s)
Result.success

Testing || Nat.ofDigits_lt_base_pow_length : âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ x âˆˆ l, x < b) â†’ Nat.ofDigits b l < b ^ l.length
Result.exception ::
Duper saturated

Testing || EMetric.preimage_add_left_ball : âˆ€ {G : Type v} [inst : AddGroup G] [inst_1 : PseudoEMetricSpace G] [inst_2 : IsometricVAdd G G] (a b : G) (r : ENNReal),
  (fun x => a + x) â»Â¹' EMetric.ball b r = EMetric.ball (-a + b) r
Result.success

Testing || Cardinal.induction_on_pi : âˆ€ {Î¹ : Type u} {p : (Î¹ â†’ Cardinal.{v}) â†’ Prop} (f : Î¹ â†’ Cardinal.{v}),
  (âˆ€ (f : Î¹ â†’ Type v), p fun i => Cardinal.mk (f i)) â†’ p f
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Turing.PartrecToTM2.tr_move : âˆ€ (p : Turing.PartrecToTM2.Î“' â†’ Bool) (kâ‚ kâ‚‚ : Turing.PartrecToTM2.K') (q : Turing.PartrecToTM2.Î›'),
  Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Î›'.move p kâ‚ kâ‚‚ q) =
    Turing.PartrecToTM2.pop' kâ‚
      (Turing.TM2.Stmt.branch (fun s => s.elim true p) (Turing.TM2.Stmt.goto fun x => q)
        (Turing.PartrecToTM2.push' kâ‚‚ (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.Î›'.move p kâ‚ kâ‚‚ q)))
Result.success

Testing || Array.reflBEq_iff : âˆ€ {Î± : Type u_1} [inst : BEq Î±], ReflBEq (Array Î±) â†” ReflBEq Î±
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.finiteDimensional : âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]
  [inst_3 : FiniteDimensional K V] {W : Type u_3} [inst_4 : AddCommGroup W] [inst_5 : _root_.Module K W]
  [inst_6 : FiniteDimensional K W], FiniteDimensional K (V â†’â‚—[K] W)
Result.success

Testing || sum_conjClasses_card_eq_card : âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype (ConjClasses G)] [inst_2 : Fintype G]
  [inst_3 : (x : ConjClasses G) â†’ Fintype â†‘x.carrier], âˆ‘ x : ConjClasses G, x.carrier.toFinset.card = Fintype.card G
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instâœ x`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || nonempty_Prop : âˆ€ {p : Prop}, Nonempty p â†” p
Result.success

Testing || WithTop.instOrderedSub : âˆ€ {Î± : Type u_1} [inst : CanonicallyOrderedAddCommMonoid Î±] [inst_1 : Sub Î±] [inst_2 : OrderedSub Î±],
  OrderedSub (WithTop Î±)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `WithTop.instSub`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Ideal.comap_map_mk : âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},
  I â‰¤ J â†’ Ideal.comap (Ideal.Quotient.mk I) (Ideal.map (Ideal.Quotient.mk I) J) = J
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Ideal.Quotient.commRing x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Std.DHashMap.Internal.Rawâ‚€.contains_insertIfNew : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} (m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²) [inst : BEq Î±] [inst_1 : Hashable Î±]
  [inst_2 : EquivBEq Î±] [inst_3 : LawfulHashable Î±],
  (â†‘m).WF â†’ âˆ€ {k a : Î±} {v : Î² k}, (m.insertIfNew k v).contains a = (k == a || m.contains a)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.ShortComplex.opcyclesMap'_g'_assoc : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {Sâ‚ Sâ‚‚ : CategoryTheory.ShortComplex C} (Ï† : Sâ‚ âŸ¶ Sâ‚‚) (hâ‚ : Sâ‚.RightHomologyData) (hâ‚‚ : Sâ‚‚.RightHomologyData) {Z : C}
  (h : Sâ‚‚.Xâ‚ƒ âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' Ï† hâ‚ hâ‚‚)
      (CategoryTheory.CategoryStruct.comp hâ‚‚.g' h) =
    CategoryTheory.CategoryStruct.comp hâ‚.g' (CategoryTheory.CategoryStruct.comp Ï†.Ï„â‚ƒ h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.p`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || act_rel_of_act_rel_of_rel_act_rel : âˆ€ {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {r : N â†’ N â†’ Prop} [inst : ContravariantClass M N Î¼ r]
  [inst : IsTrans N r] (m : M) {a b c : N}, r (Î¼ m a) b â†’ r (Î¼ m b) (Î¼ m c) â†’ r (Î¼ m a) c
Result.success

Testing || hasContinuousInvâ‚€_of_hasSmoothInvâ‚€ : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] {I : ModelWithCorners ğ•œ E H} {G : Type u_4}
  [inst_4 : TopologicalSpace G] [inst_5 : ChartedSpace H G] [inst_6 : Inv G] [inst_7 : _root_.Zero G]
  [inst : SmoothInvâ‚€ I G], HasContinuousInvâ‚€ G
Result.exception ::
Duper saturated

Testing || BitVec.msb_eq_getLsbD_last : âˆ€ {w : â„•} (x : BitVec w), x.msb = x.getLsbD (w - 1)
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WittVector.mul_polyOfInterest_aux5 : âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•),
  â†‘p ^ (n + 1) * WittVector.polyOfInterest p n = WittVector.remainder p n - WittVector.wittPolyProdRemainder p (n + 1)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.MorphismProperty.pullback_fst : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {P : CategoryTheory.MorphismProperty C}
  [inst_1 : P.IsStableUnderBaseChange] {X Y S : C} (f : X âŸ¶ S) (g : Y âŸ¶ S)
  [inst_2 : CategoryTheory.Limits.HasPullback f g], P g â†’ P (CategoryTheory.Limits.pullback.fst f g)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty C is not a `âˆ€`

Testing || Eq.ge : âˆ€ {Î± : Type u_2} [inst : Preorder Î±] {x y : Î±}, x = y â†’ y â‰¤ x
Result.success

Testing || Set.infinite_prod : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²},
  (s Ã—Ë¢ t).Infinite â†” s.Infinite âˆ§ t.Nonempty âˆ¨ t.Infinite âˆ§ s.Nonempty
Result.success

Testing || IsLocalization.submonoid_map_le_is_unit : âˆ€ {R : Type u_1} [inst : CommRing R] (M : Submonoid R) (S : Type u_2) [inst_1 : CommRing S] [inst_2 : Algebra R S]
  [inst_3 : IsLocalization M S], Submonoid.map (algebraMap R S) M â‰¤ IsUnit.submonoid S
Result.exception ::
Duper saturated

Testing || instNontrivialStalkPresheafSmoothSheaf : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {EM : Type u_2} [inst_1 : NormedAddCommGroup EM]
  [inst_2 : NormedSpace ğ•œ EM] {HM : Type u_3} [inst_3 : TopologicalSpace HM] (IM : ModelWithCorners ğ•œ EM HM)
  {E : Type u_4} [inst_4 : NormedAddCommGroup E] [inst_5 : NormedSpace ğ•œ E] {H : Type u_5} [inst_6 : TopologicalSpace H]
  (I : ModelWithCorners ğ•œ E H) {M : Type u} [inst_7 : TopologicalSpace M] [inst_8 : ChartedSpace HM M] (N : Type u)
  [inst_9 : TopologicalSpace N] [inst_10 : ChartedSpace H N] [inst_11 : Nontrivial N] (x : M),
  Nontrivial ((smoothSheaf IM I M N).presheaf.stalk x)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `smoothSheaf.eval x_0 x_1 cifvar_1
  x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Limits.colimitYonedaHomIsoLimitOp_Ï€_apply : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{uâ‚‚, uâ‚} C] {I : Type vâ‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, vâ‚} I]
  (D : CategoryTheory.Functor I C) (F : CategoryTheory.Functor Cáµ’áµ– (Type uâ‚‚))
  [inst_2 : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.yoneda)]
  [inst_3 : CategoryTheory.Limits.HasLimitsOfShape Iáµ’áµ– (Type (max uâ‚ uâ‚‚))]
  (f : CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda) âŸ¶ F) (i : Iáµ’áµ–),
  CategoryTheory.Limits.limit.Ï€ (D.op.comp (F.comp CategoryTheory.uliftFunctor.{uâ‚, uâ‚‚})) i
      ((CategoryTheory.Limits.colimitYonedaHomIsoLimitOp D F).hom f) =
    {
      down :=
        f.app (Opposite.op (D.obj (Opposite.unop i)))
          ((CategoryTheory.Limits.colimit.Î¹ (D.comp CategoryTheory.yoneda) (Opposite.unop i)).app
            (Opposite.op (D.obj (Opposite.unop i))) (CategoryTheory.CategoryStruct.id (D.obj (Opposite.unop i)))) }
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: (CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda) âŸ¶ F) âŸ¶
  CategoryTheory.Limits.limit (D.op.comp (F.comp CategoryTheory.uliftFunctor.{uâ‚, uâ‚‚})) is not a `âˆ€`

Testing || Asymptotics.isEquivalent_iff_exists_eq_mul : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : NormedField Î²] {u v : Î± â†’ Î²} {l : Filter Î±},
  Asymptotics.IsEquivalent l u v â†” âˆƒ Ï†, âˆƒ (_ : Filter.Tendsto Ï† l (nhds 1)), u =á¶ [l] Ï† * v
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Filter.Tendsto Ï† l
  (nhds 1) of Î» binder contains bound variables

Testing || norm_add_sq_real : âˆ€ {F : Type u_3} [inst : SeminormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),
  â€–x + yâ€– ^ 2 = â€–xâ€– ^ 2 + 2 * inner x y + â€–yâ€– ^ 2
Result.exception ::
Duper saturated

Testing || Polynomial.natDegree_pos_of_not_isUnit_of_dvd_monic : âˆ€ {R : Type u} [inst : CommSemiring R] {a p : Polynomial R}, p.Monic â†’ Â¬IsUnit a â†’ a âˆ£ p â†’ 0 < a.natDegree
Result.success

Testing || MeasureTheory.SimpleFunc.measurableSet_preimage : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] (f : MeasureTheory.SimpleFunc Î± Î²) (s : Set Î²),
  MeasurableSet (â‡‘f â»Â¹' s)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || EMetric.tendsto_nhds_nhds : âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²},
  Filter.Tendsto f (nhds a) (nhds b) â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ â¦ƒx : Î±â¦„, edist x a < Î´ â†’ edist (f x) b < Îµ
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || QuadraticModuleCat.forgetâ‚‚_map : âˆ€ {R : Type u} [inst : CommRing R] (X Y : QuadraticModuleCat R) (f : X âŸ¶ Y),
  (CategoryTheory.forgetâ‚‚ (QuadraticModuleCat R) (ModuleCat R)).map f = ModuleCat.ofHom f.toIsometry.toLinearMap
Result.success

Testing || ZeroHom.comp.proof_1 : âˆ€ {M : Type u_3} {N : Type u_2} {P : Type u_1} [inst : _root_.Zero M] [inst_1 : _root_.Zero N] [inst_2 : _root_.Zero P]
  (hnp : ZeroHom N P) (hmn : ZeroHom M N), hnp (hmn 0) = 0
Result.success

Testing || Turing.PartrecToTM2.supports_insert : âˆ€ {K S : Finset Turing.PartrecToTM2.Î›'} {q : Turing.PartrecToTM2.Î›'},
  Turing.PartrecToTM2.Supports (insert q K) S â†”
    Turing.TM2.SupportsStmt S (Turing.PartrecToTM2.tr q) âˆ§ Turing.PartrecToTM2.Supports K S
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ContinuousLinearEquiv.isOpen : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]
  [inst_5 : CompleteSpace E], IsOpen (Set.range ContinuousLinearEquiv.toContinuousLinearMap)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (#1 â†’ #2), (âˆ€ x1 : (#2 â†’ Prop), ((âˆ€ x2 : #2, ((!6 (!2 x0) x2) â†’ (x1 x2))) â†” (âˆ€ x2 : #1, (x1 (x0 x2)))))) is not type correct

Testing || MeasureTheory.StronglyMeasurable.measurableSet_mulSupport : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : MeasurableSpace Î±} [inst : _root_.One Î²] [inst_1 : TopologicalSpace Î²]
  [inst_2 : TopologicalSpace.MetrizableSpace Î²],
  MeasureTheory.StronglyMeasurable f â†’ MeasurableSet (Function.mulSupport f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Measurable x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DirichletCharacter.isMultiplicative_toArithmeticFunction : âˆ€ {N : â„•} {R : Type u_1} [inst : CommMonoidWithZero R] (Ï‡ : DirichletCharacter R N),
  (toArithmeticFunction fun x => Ï‡ â†‘x).IsMultiplicative
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || mem_perms_of_finset_iff : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {s : Finset Î±} {f : Equiv.Perm Î±},
  f âˆˆ permsOfFinset s â†” âˆ€ {x : Î±}, f x â‰  x â†’ x âˆˆ s
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || _private.Mathlib.Data.Real.Pi.Irrational.0.is_integer : âˆ€ {p : Polynomial â„¤} (a b : â„¤) {k : â„•},
  p.natDegree â‰¤ k â†’ âˆƒ z, Polynomial.evalâ‚‚ (Int.castRingHom â„) (â†‘a / â†‘b) p * â†‘b ^ k = â†‘z
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Order.height_eq_top_iff : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {x : Î±}, Order.height x = âŠ¤ â†” âˆ€ (n : â„•), âˆƒ p, RelSeries.last p = x âˆ§ p.length = n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderTop.toTop`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.getD_map : âˆ€ {Î± : Type u} {Î² : Type v} (l : List Î±) (d : Î±) {n : â„•} (f : Î± â†’ Î²), (List.map f l).getD n (f d) = f (l.getD n d)
Result.success

Testing || FiniteDimensional.exists_is_basis_integral : âˆ€ (A : Type u_1) (K : Type u_2) [inst : CommRing A] [inst_1 : Field K] [inst_2 : Algebra A K]
  [inst_3 : IsFractionRing A K] (L : Type u_3) [inst_4 : Field L] [inst_5 : Algebra K L] [inst_6 : Algebra A L]
  [inst_7 : IsScalarTower A K L] [inst_8 : FiniteDimensional K L] [inst_9 : IsDomain A],
  âˆƒ s b, âˆ€ (x : { x // x âˆˆ s }), IsIntegral A (b x)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Basis { x // x âˆˆ s } K L of Î» binder contains bound variables

Testing || LinearMap.prod_eq_inf_comap : âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]
  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R Mâ‚‚] (p : Submodule R M) (q : Submodule R Mâ‚‚),
  p.prod q = Submodule.comap (LinearMap.fst R M Mâ‚‚) p âŠ“ Submodule.comap (LinearMap.snd R M Mâ‚‚) q
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearMap.instFunLike`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || HahnSeries.toPowerSeriesAlg_apply : âˆ€ (R : Type u_2) [inst : CommSemiring R] {A : Type u_3} [inst_1 : Semiring A] [inst_2 : Algebra R A]
  (f : HahnSeries â„• A), (HahnSeries.toPowerSeriesAlg R) f = PowerSeries.mk f.coeff
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (Â¬ ((!0 !1 !2) = (!3 (!4 !2)))) is not type correct

Testing || Order.Iic_pred_of_not_isMin : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : PredOrder Î±] {a : Î±}, Â¬IsMin a â†’ Set.Iic (Order.pred a) = Set.Iio a
Result.exception ::
Duper saturated

Testing || Complex.abs_of_nonneg : âˆ€ {r : â„}, 0 â‰¤ r â†’ Complex.abs â†‘r = r
Result.success

Testing || eventually_uniformity_iterate_comp_subset : âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},
  s âˆˆ uniformity Î± â†’ âˆ€ (n : â„•), âˆ€á¶  (t : Set (Î± Ã— Î±)) in (uniformity Î±).smallSets, (fun x => compRel t x)^[n] t âŠ† s
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Set (Î± Ã— Î±) is not a `âˆ€`

Testing || Sum.Lex.Icc_inr_inr : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : OrderTop Î±] [inst_3 : OrderBot Î²]
  [inst_4 : LocallyFiniteOrder Î±] [inst_5 : LocallyFiniteOrder Î²] (bâ‚ bâ‚‚ : Î²),
  Finset.Icc (Sum.inrâ‚— bâ‚) (Sum.inrâ‚— bâ‚‚) =
    Finset.map (Function.Embedding.inr.trans toLex.toEmbedding) (Finset.Icc bâ‚ bâ‚‚)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (inj' : Function.Injective Sum.inr),
  Function.Embedding.inr = { toFun := Sum.inr, inj' := inj' }, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || AlgebraicGeometry.LocallyRingedSpace.stalkMap_inv_hom_assoc : âˆ€ {X Y : AlgebraicGeometry.LocallyRingedSpace} (e : X â‰… Y) (x : â†‘X.toTopCat) {Z : CommRingCat}
  (h : X.presheaf.stalk x âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap e.inv (e.hom.base x))
      (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap e.hom x) h) =
    CategoryTheory.CategoryStruct.comp (X.presheaf.stalkSpecializes â‹¯) h
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Nat.even_sub : âˆ€ {m n : â„•}, n â‰¤ m â†’ (Even (m - n) â†” (Even m â†” Even n))
Result.success

Testing || List.mem_of_mem_inter_right : âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} {a : Î±} [inst : DecidableEq Î±], a âˆˆ lâ‚ âˆ© lâ‚‚ â†’ a âˆˆ lâ‚‚
Result.success

Testing || Set.Finite.toFinset_insert : âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {s : Set Î±} {a : Î±} (hs : (insert a s).Finite), hs.toFinset = insert a â‹¯.toFinset
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.instInsert`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || QuotientAddGroup.quotientEquivSelf.proof_3 : âˆ€ (Î± : Type u_1) (x : Î±), x = x
Result.success

Testing || List.eq_nil_of_map_eq_nil : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {l : List Î±}, List.map f l = [] â†’ l = []
Result.success

Testing || NumberField.InfinitePlace.comap_id : âˆ€ {K : Type u_2} [inst : Field K] (w : NumberField.InfinitePlace K), w.comap (RingHom.id K) = w
Result.success

Testing || RelIso.cast_trans : âˆ€ {Î± Î² Î³ : Type u} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} {t : Î³ â†’ Î³ â†’ Prop} (hâ‚ : Î± = Î²) (hâ‚' : Î² = Î³) (hâ‚‚ : HEq r s)
  (hâ‚‚' : HEq s t), (RelIso.cast hâ‚ hâ‚‚).trans (RelIso.cast hâ‚' hâ‚‚') = RelIso.cast â‹¯ â‹¯
Result.exception ::
Duper saturated

Testing || Set.nontrivial_of_lt : âˆ€ {Î± : Type u} {s : Set Î±} [inst : Preorder Î±] {x y : Î±}, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ s.Nontrivial
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || CategoryTheory.Groupoid.Free.of_eq : âˆ€ {V : Type u} [inst : Quiver V],
  CategoryTheory.Groupoid.Free.of V =
    Quiver.Symmetrify.of â‹™q CategoryTheory.Paths.of â‹™q
      (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor
Result.success

Testing || Antitone.iUnion_comp_tendsto_atBot : âˆ€ {Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [inst : Preorder Î²] {l : Filter Î±} [inst_1 : l.NeBot] {s : Î² â†’ Set Î³},
  Antitone s â†’ âˆ€ {f : Î± â†’ Î²}, Filter.Tendsto f l Filter.atBot â†’ â‹ƒ a, s (f a) = â‹ƒ b, s b
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.atBot`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Filter.map_sigma_mk_comap : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Ï€ : Î± â†’ Type u_6} {Ï€' : Î² â†’ Type u_7} {f : Î± â†’ Î²},
  Function.Injective f â†’
    âˆ€ (g : (a : Î±) â†’ Ï€ a â†’ Ï€' (f a)) (a : Î±) (l : Filter (Ï€' (f a))),
      Filter.map (Sigma.mk a) (Filter.comap (g a) l) = Filter.comap (Sigma.map f g) (Filter.map (Sigma.mk (f a)) l)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Sigma.mk i`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ProbabilityTheory.mgf_smul_left : âˆ€ {Î© : Type u_1} {m : MeasurableSpace Î©} {X : Î© â†’ â„} {Î¼ : MeasureTheory.Measure Î©} {t : â„} (Î± : â„),
  ProbabilityTheory.mgf (Î± â€¢ X) Î¼ t = ProbabilityTheory.mgf X Î¼ (Î± * t)
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.ShortComplex.SnakeInput.Lâ‚ƒ_exact : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Abelian C]
  (S : CategoryTheory.ShortComplex.SnakeInput C), S.Lâ‚ƒ.Exact
Result.exception ::
Duper saturated

Testing || PartialHomeomorph.eventually_left_inverse' : âˆ€ {X : Type u_1} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (e : PartialHomeomorph X Y)
  {x : Y}, x âˆˆ e.target â†’ âˆ€á¶  (y : X) in nhds (â†‘e.symm x), â†‘e.symm (â†‘e y) = y
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || CategoryTheory.ComposableArrows.homMkâ‚ƒ_app_zero : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {f g : CategoryTheory.ComposableArrows C 3}
  (appâ‚€ : f.obj' 0 â‹¯ âŸ¶ g.obj' 0 â‹¯) (appâ‚ : f.obj' 1 â‹¯ âŸ¶ g.obj' 1 â‹¯) (appâ‚‚ : f.obj' 2 â‹¯ âŸ¶ g.obj' 2 â‹¯)
  (appâ‚ƒ : f.obj' 3 â‹¯ âŸ¶ g.obj' 3 â‹¯)
  (wâ‚€ :
    CategoryTheory.CategoryStruct.comp (f.map' 0 1 â‹¯ â‹¯) appâ‚ = CategoryTheory.CategoryStruct.comp appâ‚€ (g.map' 0 1 â‹¯ â‹¯))
  (wâ‚ :
    CategoryTheory.CategoryStruct.comp (f.map' 1 2 â‹¯ â‹¯) appâ‚‚ = CategoryTheory.CategoryStruct.comp appâ‚ (g.map' 1 2 â‹¯ â‹¯))
  (wâ‚‚ :
    CategoryTheory.CategoryStruct.comp (f.map' 2 3 â‹¯ â‹¯) appâ‚ƒ =
      CategoryTheory.CategoryStruct.comp appâ‚‚ (g.map' 2 3 â‹¯ â‹¯)),
  (CategoryTheory.ComposableArrows.homMkâ‚ƒ appâ‚€ appâ‚ appâ‚‚ appâ‚ƒ wâ‚€ wâ‚ wâ‚‚).app 0 = appâ‚€
Result.exception ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  CategoryTheory.CategoryStruct.comp (f.map (CategoryTheory.homOfLE â‹¯)) appâ‚ =
    CategoryTheory.CategoryStruct.comp appâ‚€ (g.map (CategoryTheory.homOfLE â‹¯)) is not type correct

Testing || ProbabilityTheory.Kernel.condKernelCountable_apply : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î© : Type u_3} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²}
  {mÎ© : MeasurableSpace Î©} [inst : Countable Î±] (ÎºCond : Î± â†’ ProbabilityTheory.Kernel Î² Î©)
  (h_atom : âˆ€ (x y : Î±), x âˆˆ measurableAtom y â†’ ÎºCond x = ÎºCond y) (p : Î± Ã— Î²),
  (ProbabilityTheory.Kernel.condKernelCountable ÎºCond h_atom) p = (ÎºCond p.1) p.2
Result.success

Testing || MonoidHom.submonoidComap_apply_coe : âˆ€ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M â†’* N) (N' : Submonoid N)
  (x : â†¥(Submonoid.comap f N')), â†‘((f.submonoidComap N') x) = f â†‘x
Result.success

Testing || Batteries.instTransCmpFlipOrdering : âˆ€ {Î± : Sort u_1} {cmp : Î± â†’ Î± â†’ Ordering} [inst : Batteries.TransCmp cmp], Batteries.TransCmp (flip cmp)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.BilinForm.nondegenerate_of_det_ne_zero : âˆ€ {Mâ‚‚ : Type u_4} [inst : AddCommGroup Mâ‚‚] {A : Type u_5} [inst_1 : CommRing A] [inst_2 : IsDomain A]
  [inst_3 : _root_.Module A Mâ‚‚] (Bâ‚ƒ : LinearMap.BilinForm A Mâ‚‚) {Î¹ : Type u_6} [inst_4 : DecidableEq Î¹]
  [inst_5 : Fintype Î¹] (b : Basis Î¹ A Mâ‚‚), ((BilinForm.toMatrix b) Bâ‚ƒ).det â‰  0 â†’ Bâ‚ƒ.Nondegenerate
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (Â¬ ((!1 !2 (!3 (!4 !5) !6)) = !7)) is not type correct

Testing || NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top : âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], Submodule.span â„ â†‘(NumberField.Units.unitLattice K) = âŠ¤
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || translate_neg_right : âˆ€ {Î± : Type u_2} {G : Type u_5} [inst : AddCommGroup G] [inst_1 : Neg Î±] (a : G) (f : G â†’ Î±),
  translate a (-f) = -translate a f
Result.exception ::
Duper saturated

Testing || ContDiff.of_succ : âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}
  {n : WithTop â„•âˆ}, ContDiff ğ•œ (n + 1) f â†’ ContDiff ğ•œ n f
Result.success

Testing || Matrix.det_updateCol_add_self : âˆ€ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (A : Matrix n n R)
  {i j : n}, i â‰  j â†’ (A.updateCol i fun k => A k i + A k j).det = A.det
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `âˆ€`

Testing || uniformContinuous_const : âˆ€ {Î± : Type ua} {Î² : Type ub} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {b : Î²}, UniformContinuous fun x => b
Result.success

Testing || CategoryTheory.Adjunction.compPreadditiveYonedaIso_hom_app_app_apply : âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Preadditive D] {F : CategoryTheory.Functor C D}
  {G : CategoryTheory.Functor D C} (adj : F âŠ£ G) [inst_4 : F.Additive] (X : Cáµ’áµ–) (Y : D)
  (a : ULift.{max vâ‚ vâ‚‚, vâ‚} (Opposite.unop X âŸ¶ G.obj Y)),
  ((adj.compPreadditiveYonedaIso.hom.app Y).app X) a =
    { down := (adj.homEquiv (Opposite.unop X) Y).symm (AddEquiv.ulift a) }
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ContinuousLinearEquiv.compContinuousMultilinearMapL_apply : âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} {G' : Type wG'} [inst : NontriviallyNormedField ğ•œ]
  [inst_1 : (i : Î¹) â†’ SeminormedAddCommGroup (E i)] [inst_2 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] [inst_5 : SeminormedAddCommGroup G']
  [inst_6 : NormedSpace ğ•œ G'] [inst_7 : Fintype Î¹] (g : G â‰ƒL[ğ•œ] G') (f : ContinuousMultilinearMap ğ•œ E G),
  (ContinuousLinearEquiv.compContinuousMultilinearMapL E g) f = (â†‘g).compContinuousMultilinearMap f
Result.success

Testing || conjneg_conjneg : âˆ€ {G : Type u_2} {R : Type u_3} [inst : AddGroup G] [inst_1 : CommSemiring R] [inst_2 : StarRing R] (f : G â†’ R),
  conjneg (conjneg f) = f
Result.exception ::
Duper saturated

Testing || ProbabilityTheory.Kernel.IsSFiniteKernel.snd : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Î³ : Type u_4}
  {mÎ³ : MeasurableSpace Î³} (Îº : ProbabilityTheory.Kernel Î± (Î² Ã— Î³)) [inst : ProbabilityTheory.IsSFiniteKernel Îº],
  ProbabilityTheory.IsSFiniteKernel Îº.snd
Result.success

Testing || CategoryTheory.preserves_mono_of_preservesLimit : âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  (F : CategoryTheory.Functor C D) {X Y : C} (f : X âŸ¶ Y)
  [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f f) F] [inst_3 : CategoryTheory.Mono f],
  CategoryTheory.Mono (F.map f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_20 x_0).map
  (cifvar_9 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddGroupNormClass.toNormedAddGroup.proof_1 : âˆ€ {F : Type u_2} {Î± : Type u_1} [inst : FunLike F Î± â„] [inst_1 : AddGroup Î±] [inst_2 : AddGroupNormClass F Î± â„] (f : F)
  {x y : Î±}, dist x y = 0 â†’ x = y
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!11 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || PadicInt.nonarchimedean : âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (q r : â„¤_[p]), â€–q + râ€– â‰¤ â€–qâ€– âŠ” â€–râ€–
Result.success

Testing || CategoryTheory.Pretriangulated.instIsHomologicalOppositeAddCommGrpObjFunctorPreadditiveYoneda : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.HasShift C â„¤] [inst_3 : CategoryTheory.Limits.HasZeroObject C]
  [inst_4 : âˆ€ (n : â„¤), (CategoryTheory.shiftFunctor C n).Additive] [inst_5 : CategoryTheory.Pretriangulated C] (B : C),
  (CategoryTheory.preadditiveYoneda.obj B).IsHomological
Result.exception ::
Duper saturated

Testing || StrictConvexOn.lt_on_open_segment' : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]
  [inst_2 : LinearOrderedAddCommMonoid Î²] [inst_3 : SMul ğ•œ E] [inst_4 : _root_.Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]
  {s : Set E} {f : E â†’ Î²},
  StrictConvexOn ğ•œ s f â†’
    âˆ€ {x y : E}, x âˆˆ s â†’ y âˆˆ s â†’ x â‰  y â†’ âˆ€ {a b : ğ•œ}, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < f x âŠ” f y
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLE`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || OrderedCommGroup.toMulLeftReflectLE : âˆ€ (Î± : Type u) [inst : OrderedCommGroup Î±], MulLeftReflectLE Î±
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || neg_of_smul_neg_right' : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {a : Î±} {b : Î²} [inst : _root_.Zero Î±] [inst_1 : _root_.Zero Î²]
  [inst_2 : SMulWithZero Î± Î²] [inst_3 : LinearOrder Î±] [inst_4 : LinearOrder Î²] [inst_5 : PosSMulMono Î± Î²],
  a â€¢ b < 0 â†’ 0 â‰¤ b â†’ a < 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulZeroClass.toSMul`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Std.DHashMap.Internal.Rawâ‚€.size_le_size_insert : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} (m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²) [inst : BEq Î±] [inst_1 : Hashable Î±]
  [inst_2 : EquivBEq Î±] [inst_3 : LawfulHashable Î±], (â†‘m).WF â†’ âˆ€ {k : Î±} {v : Î² k}, (â†‘m).size â‰¤ (â†‘(m.insert k v)).size
Result.exception ::
Duper saturated

Testing || CategoryTheory.Zigzag.of_zag : âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} J] {jâ‚ jâ‚‚ : J},
  CategoryTheory.Zag jâ‚ jâ‚‚ â†’ CategoryTheory.Zigzag jâ‚ jâ‚‚
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HomogeneousIdeal.toIdeal_iSupâ‚‚ : âˆ€ {Î¹ : Type u_1} {Ïƒ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : DecidableEq Î¹] [inst_2 : AddMonoid Î¹]
  [inst_3 : SetLike Ïƒ A] [inst_4 : AddSubmonoidClass Ïƒ A] {ğ’œ : Î¹ â†’ Ïƒ} [inst_5 : GradedRing ğ’œ] {Îº : Sort u_4}
  {Îº' : Îº â†’ Sort u_5} (s : (i : Îº) â†’ Îº' i â†’ HomogeneousIdeal ğ’œ), (â¨† i, â¨† j, s i j).toIdeal = â¨† i, â¨† j, (s i j).toIdeal
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Îº' iâœ of Î» binder contains bound variables

Testing || CategoryTheory.GrothendieckTopology.sheafifyLift_unique : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}
  [inst_1 : CategoryTheory.Category.{max v u, w} D]
  [inst_2 :
    âˆ€ (P : CategoryTheory.Functor Cáµ’áµ– D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)]
  [inst_3 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)áµ’áµ– D] {P Q : CategoryTheory.Functor Cáµ’áµ– D}
  (Î· : P âŸ¶ Q) (hQ : CategoryTheory.Presheaf.IsSheaf J Q) (Î³ : J.sheafify P âŸ¶ Q),
  CategoryTheory.CategoryStruct.comp (J.toSheafify P) Î³ = Î· â†’ Î³ = J.sheafifyLift Î· hQ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2.instPreorderCover x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Asymptotics.IsBigO.eventually_integrableOn : âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] {g : Î± â†’ F} {l : Filter Î±} {Î¹ : Type u_4}
  [inst_1 : MeasurableSpace Î¹] {f : Î¹ Ã— Î± â†’ E} {s : Set Î¹} {Î¼ : MeasureTheory.Measure Î¹} [inst_2 : Norm F],
  f =O[Filter.principal s Ã—Ë¢ l] (g âˆ˜ Prod.snd) â†’
    (âˆ€á¶  (x : Î±) in l, MeasureTheory.AEStronglyMeasurable (fun i => f (i, x)) (Î¼.restrict s)) â†’
      MeasurableSet s â†’ Î¼ s < âŠ¤ â†’ âˆ€á¶  (x : Î±) in l, MeasureTheory.IntegrableOn (fun i => f (i, x)) s Î¼
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (#12 â†’ Prop), (âˆ€ x1 : #16, ((!31 (Î»x2 : #12, (x0 x2)) x1) â†’ (âˆƒ x2 : #17, ((!32 x1 x2) âˆ§ (âˆ€ x3 : #12, ((!33 x2 x3) â†’ (x0 x3)))))))) is not type correct

Testing || Associates.le_singleton_iff : âˆ€ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDedekindDomain A] (x : A) (n : â„•) (I : Ideal A),
  Associates.mk I ^ n â‰¤ Associates.mk (Ideal.span {x}) â†” x âˆˆ I ^ n
Result.success

Testing || Subgroup.op_iInf : âˆ€ {Î¹ : Sort u_1} {G : Type u_2} [inst : Group G] (S : Î¹ â†’ Subgroup G), (iInf S).op = â¨… i, (S i).op
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || mul_nsmul' : âˆ€ {M : Type u_2} [inst : AddMonoid M] (a : M) (m n : â„•), (m * n) â€¢ a = m â€¢ n â€¢ a
Result.success

Testing || Multiset.coe_eq_singleton : âˆ€ {Î± : Type u_1} {l : List Î±} {a : Î±}, â†‘l = {a} â†” l = [a]
Result.success

Testing || Polynomial.opRingEquiv_op_monomial : âˆ€ {R : Type u_1} [inst : Semiring R] (n : â„•) (r : R),
  (Polynomial.opRingEquiv R) (MulOpposite.op ((Polynomial.monomial n) r)) = (Polynomial.monomial n) (MulOpposite.op r)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Classical.decEq
  (cifvar_38 cifvar_39) b cifvar_33`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Monotone.map_liminf_of_continuousAt : âˆ€ {Î¹ : Type u_1} {R : Type u_4} {S : Type u_5} {F : Filter Î¹} [inst : F.NeBot]
  [inst : ConditionallyCompleteLinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]
  [inst_3 : ConditionallyCompleteLinearOrder S] [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {f : R â†’ S},
  Monotone f â†’
    âˆ€ (a : Î¹ â†’ R),
      ContinuousAt f (Filter.liminf a F) â†’
        autoParam (Filter.IsCoboundedUnder (fun x1 x2 => x1 â‰¥ x2) F a) _autoâœ â†’
          autoParam (Filter.IsBoundedUnder (fun x1 x2 => x1 â‰¥ x2) F a) _autoâœÂ¹ â†’
            f (Filter.liminf a F) = Filter.liminf (f âˆ˜ a) F
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.ball_empty_iff : âˆ€ {Î± : Type u} {p : Î± â†’ Prop}, (âˆ€ x âˆˆ âˆ…, p x) â†” True
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, ((!0 !2 x0) = (!2 x0))) is not type correct

Testing || AddSubmonoid.prod_le_iff : âˆ€ {N : Type u_2} [inst : AddZeroClass N] {M : Type u_5} [inst_1 : AddZeroClass M] {s : AddSubmonoid M}
  {t : AddSubmonoid N} {u : AddSubmonoid (M Ã— N)},
  s.prod t â‰¤ u â†” AddSubmonoid.map (AddMonoidHom.inl M N) s â‰¤ u âˆ§ AddSubmonoid.map (AddMonoidHom.inr M N) t â‰¤ u
Result.exception ::
Duper saturated

Testing || Real.sin_pos_of_mem_Ioo : âˆ€ {x : â„}, x âˆˆ Set.Ioo 0 Real.pi â†’ 0 < Real.sin x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!0 (!7 x0) x1) = (!5 x0 x1)))) is not type correct

Testing || Equiv.Perm.commute_of_mem_cycleFactorsFinset_commute : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] (k g : Equiv.Perm Î±),
  (âˆ€ c âˆˆ g.cycleFactorsFinset, Commute k c) â†’ Commute k g
Result.exception ::
Duper saturated

Testing || Submonoid.prod_eq_bot_iff : âˆ€ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {s : Submonoid M} {t : Submonoid N},
  s.prod t = âŠ¥ â†” s = âŠ¥ âˆ§ t = âŠ¥
Result.exception ::
Duper saturated

Testing || SatisfiesM_Option_eq : âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {x : Option Î±}, SatisfiesM p x â†” âˆ€ (a : Î±), x = some a â†’ p a
Result.exception ::
Duper saturated

Testing || WeierstrassCurve.variableChange_Î” : âˆ€ {R : Type u} [inst : CommRing R] (W : WeierstrassCurve R) (C : WeierstrassCurve.VariableChange R),
  (W.variableChange C).Î” = â†‘C.uâ»Â¹ ^ 12 * W.Î”
Result.exception ::
Duper saturated

Testing || RelEmbedding.toEmbedding_inj : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} {f g : r â†ªr s},
  f.toEmbedding = g.toEmbedding â†” f = g
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x_0 â†ªr x_1 of Î» binder contains bound variables

Testing || Fin.rev_bot : âˆ€ {n : â„•} [inst : NeZero n], âŠ¥.rev = âŠ¤
Result.success

Testing || CategoryTheory.Limits.hasBiproductsOfShape_finite : âˆ€ {J : Type w} (C : Type uC) [inst : CategoryTheory.Category.{uC', uC} C]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C]
  [inst_3 : Finite J], CategoryTheory.Limits.HasBiproductsOfShape J C
Result.exception ::
Duper saturated

Testing || Std.DHashMap.Internal.List.getValueCast!_eraseKey_self : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] {l : List ((a : Î±) Ã— Î² a)} {k : Î±}
  [inst_2 : Inhabited (Î² k)],
  Std.DHashMap.Internal.List.DistinctKeys l â†’
    Std.DHashMap.Internal.List.getValueCast! k (Std.DHashMap.Internal.List.eraseKey k l) = default
Result.exception ::
Duper saturated

Testing || tsum_const_smul : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : Monoid Î³] [inst_1 : TopologicalSpace Î±]
  [inst_2 : AddCommMonoid Î±] [inst_3 : DistribMulAction Î³ Î±] [inst_4 : ContinuousConstSMul Î³ Î±] {f : Î² â†’ Î±}
  [inst_5 : T2Space Î±] (b : Î³), Summable f â†’ âˆ‘' (i : Î²), b â€¢ f i = b â€¢ âˆ‘' (i : Î²), f i
Result.success

Testing || Finset.subset_singleton_iff : âˆ€ {Î± : Type u_1} {s : Finset Î±} {a : Î±}, s âŠ† {a} â†” s = âˆ… âˆ¨ s = {a}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : #0, ((!5 (!9 (!10 x0)) (!9 (!10 x1))) = (!0 x0 x1)))) is not type correct

Testing || PowerSeries.WithPiTopology.continuous_constantCoeff : âˆ€ (R : Type u_1) [inst : TopologicalSpace R] [inst_1 : Semiring R], Continuous â‡‘(PowerSeries.constantCoeff R)
Result.exception ::
Duper saturated

Testing || Submodule.comap_surjective_of_injective : âˆ€ {R : Type u_1} {Râ‚‚ : Type u_3} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]
  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {F : Type u_9} [inst_6 : FunLike F M Mâ‚‚] [inst_7 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚]
  [inst_8 : RingHomSurjective Ïƒâ‚â‚‚] {f : F}, Function.Injective â‡‘f â†’ Function.Surjective (Submodule.comap f)
Result.exception ::
Duper saturated

Testing || Ordnode.Valid'.of_lt : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {t : Ordnode Î±} {x : Î±} {oâ‚ : WithBot Î±} {oâ‚‚ : WithTop Î±},
  Ordnode.Valid' oâ‚ t oâ‚‚ â†’ Ordnode.nil.Bounded oâ‚ â†‘x â†’ Ordnode.All (fun x_1 => x_1 < x) t â†’ Ordnode.Valid' oâ‚ t â†‘x
Result.exception ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Heyting.Regular.coe_injective : âˆ€ {Î± : Type u_1} [inst : HeytingAlgebra Î±], Function.Injective Heyting.Regular.val
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of Î» binder contains bound variables

Testing || CauchySeq.prod : âˆ€ {Î± : Type u} {Î² : Type v} [uniformSpace : UniformSpace Î±] {Î³ : Type u_1} [inst : UniformSpace Î²] [inst_1 : Preorder Î³]
  {u : Î³ â†’ Î±} {v : Î³ â†’ Î²}, CauchySeq u â†’ CauchySeq v â†’ CauchySeq fun x => (u x, v x)
Result.exception ::
Duper saturated

Testing || exists_le_le : âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : IsDirected Î± fun x1 x2 => x1 â‰¥ x2] (a b : Î±), âˆƒ c â‰¤ a, c â‰¤ b
Result.success

Testing || List.init_eq_of_concat_eq : âˆ€ {Î± : Type u_1} {a b : Î±} {lâ‚ lâ‚‚ : List Î±}, lâ‚.concat a = lâ‚‚.concat b â†’ lâ‚ = lâ‚‚
Result.exception ::
Duper saturated

Testing || Fin.ofNat'_sub : âˆ€ {n : â„•} [inst : NeZero n] (x : â„•) (y : Fin n), Fin.ofNat' n x - y = Fin.ofNat' n (n - â†‘y + x)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Equiv.Perm.SameCycle.extendDomain : âˆ€ {Î± : Type u_2} {Î² : Type u_3} {g : Equiv.Perm Î±} {x y : Î±} {p : Î² â†’ Prop} [inst : DecidablePred p]
  {f : Î± â‰ƒ Subtype p}, g.SameCycle x y â†’ (g.extendDomain f).SameCycle â†‘(f x) â†‘(f y)
Result.success

Testing || CategoryTheory.IsUniversalColimit.of_mapCocone : âˆ€ {J : Type v'} [inst : CategoryTheory.Category.{u', v'} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {D : Type u_2} [inst_2 : CategoryTheory.Category.{u_3, u_2} D] (G : CategoryTheory.Functor C D)
  {F : CategoryTheory.Functor J C} {c : CategoryTheory.Limits.Cocone F}
  [inst_3 : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G]
  [inst_4 : CategoryTheory.Limits.ReflectsColimitsOfShape J G],
  CategoryTheory.IsUniversalColimit (G.mapCocone c) â†’ CategoryTheory.IsUniversalColimit c
Result.exception ::
Duper saturated

Testing || hasSum_single : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {f : Î² â†’ Î±} (b : Î²),
  (âˆ€ (b' : Î²), b' â‰  b â†’ f b' = 0) â†’ HasSum f (f b)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MagmaCat.ofHom_apply : âˆ€ {X Y : Type u} [inst : Mul X] [inst_1 : Mul Y] (f : X â†’â‚™* Y) (x : X), (MagmaCat.ofHom f) x = f x
Result.success

Testing || ContMDiffMap.mdifferentiableAt : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {E' : Type u_5} [inst_6 : NormedAddCommGroup E']
  [inst_7 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_8 : TopologicalSpace H'] {I' : ModelWithCorners ğ•œ E' H'}
  {M' : Type u_7} [inst_9 : TopologicalSpace M'] [inst_10 : ChartedSpace H' M'] (f : ContMDiffMap I I' M M' âŠ¤) {x : M},
  MDifferentiableAt I I' (â‡‘f) x
Result.exception ::
Duper saturated

Testing || MeasureTheory.levyProkhorovDist_self : âˆ€ {Î© : Type u_1} [inst : MeasurableSpace Î©] [inst_1 : PseudoEMetricSpace Î©] (Î¼ : MeasureTheory.Measure Î©),
  MeasureTheory.levyProkhorovDist Î¼ Î¼ = 0
Result.exception ::
Duper saturated

Testing || AddHom.fst_comp_prod : âˆ€ {M : Type u_3} {N : Type u_4} {P : Type u_5} [inst : Add M] [inst_1 : Add N] [inst_2 : Add P] (f : M â†’â‚™+ N)
  (g : M â†’â‚™+ P), (AddHom.fst N P).comp (f.prod g) = f
Result.success

Testing || AddMonoidHom.coe_ofClosureMEqTopLeft : âˆ€ {M : Type u_1} {N : Type u_2} [inst : AddMonoid M] [inst_1 : AddMonoid N] {s : Set M} (f : M â†’ N)
  (hs : AddSubmonoid.closure s = âŠ¤) (h1 : f 0 = 0) (hmul : âˆ€ x âˆˆ s, âˆ€ (y : M), f (x + y) = f x + f y),
  â‡‘(AddMonoidHom.ofClosureMEqTopLeft f hs h1 hmul) = f
Result.exception ::
Duper saturated

Testing || CategoryTheory.ShortComplex.Exact.epi_f : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {S : CategoryTheory.ShortComplex C}, S.Exact â†’ S.g = 0 â†’ CategoryTheory.Epi S.f
Result.exception ::
Duper saturated

Testing || AddMonoidHom.inverse.proof_3 : âˆ€ {A : Type u_1} {B : Type u_2} [inst : AddMonoid A] [inst_1 : AddMonoid B] (f : A â†’+ B) (g : B â†’ A)
  (hâ‚ : Function.LeftInverse g â‡‘f), ((â†‘f).inverse g hâ‚).toFun 0 = 0
Result.success

Testing || Auto.Embedding.Lam.LamEquiv.congr : âˆ€ {lval : Embedding.Lam.LamValuation} {lctx : â„• â†’ Embedding.Lam.LamSort} {argTy resTy : Embedding.Lam.LamSort}
  {fnâ‚ fnâ‚‚ argâ‚ argâ‚‚ : Embedding.Lam.LamTerm},
  Embedding.Lam.LamEquiv lval lctx (argTy.func resTy) fnâ‚ fnâ‚‚ â†’
    Embedding.Lam.LamEquiv lval lctx argTy argâ‚ argâ‚‚ â†’
      Embedding.Lam.LamEquiv lval lctx resTy (Embedding.Lam.LamTerm.app argTy fnâ‚ argâ‚)
        (Embedding.Lam.LamTerm.app argTy fnâ‚‚ argâ‚‚)
Result.exception ::
Duper saturated

Testing || CategoryTheory.SingleFunctors.shiftIso_add'_inv_app : âˆ€ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_7, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_6, u_2} D] {A : Type u_5} [inst_2 : AddMonoid A]
  [inst_3 : CategoryTheory.HasShift D A] (F : CategoryTheory.SingleFunctors C D A) (n m mn : A) (hnm : m + n = mn)
  (a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C),
  (F.shiftIso mn a a'' â‹¯).inv.app X =
    CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X)
      (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').inv.app X))
        ((CategoryTheory.shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X)))
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Duper.rule15bTheorem : âˆ€ (b : Bool), (!!b) = b
Result.success

Testing || Multiset.card_coe : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (m : Multiset Î±), Fintype.card m.ToType = m.card
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.toEnumFinset`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.pairwise_iff : âˆ€ {Î± : Type u} (R : Î± â†’ Î± â†’ Prop) (a : List Î±),
  List.Pairwise R a â†” a = [] âˆ¨ âˆƒ a_1 l, (âˆ€ a' âˆˆ l, R a_1 a') âˆ§ List.Pairwise R l âˆ§ a = a_1 :: l
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AddSubgroup.isOpen_of_isClosed_of_finiteIndex : âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousAdd G] (H : AddSubgroup G)
  [inst_3 : H.FiniteIndex], IsClosed â†‘H â†’ IsOpen â†‘H
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || parallelogram_law_with_norm : âˆ€ (ğ•œ : Type u_1) {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : SeminormedAddCommGroup E] [inst : InnerProductSpace ğ•œ E]
  (x y : E), â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `InnerProductSpace.toInner`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MvPolynomial.evalâ‚‚_map : âˆ€ {R : Type u} {Sâ‚ : Type v} {Sâ‚‚ : Type w} {Ïƒ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring Sâ‚]
  [inst_2 : CommSemiring Sâ‚‚] (f : R â†’+* Sâ‚) (g : Ïƒ â†’ Sâ‚‚) (Ï† : Sâ‚ â†’+* Sâ‚‚) (p : MvPolynomial Ïƒ R),
  MvPolynomial.evalâ‚‚ Ï† g ((MvPolynomial.map f) p) = MvPolynomial.evalâ‚‚ (Ï†.comp f) g p
Result.success

Testing || Set.indicator_le_indicator : âˆ€ {Î± : Type u_2} {M : Type u_3} [inst : Preorder M] [inst_1 : _root_.Zero M] {s : Set Î±} {f g : Î± â†’ M} {a : Î±},
  f a â‰¤ g a â†’ s.indicator f a â‰¤ s.indicator g a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!8 (!0 (!1 !2)) (!3 !2)) = (!0 (!1 !2) (!3 !2))) is not type correct

Testing || AddHom.restrict_apply : âˆ€ {M : Type u_1} {Ïƒ : Type u_4} [inst : Add M] {N : Type u_5} [inst_1 : Add N] [inst_2 : SetLike Ïƒ M]
  [inst_3 : AddMemClass Ïƒ M] (f : M â†’â‚™+ N) {S : Ïƒ} (x : â†¥S), (f.restrict S) x = f â†‘x
Result.success

Testing || Part.Ï‰Sup_eq_none : âˆ€ {Î± : Type u_2} {c : OmegaCompletePartialOrder.Chain (Part Î±)}, (Â¬âˆƒ a, Part.some a âˆˆ c) â†’ Part.Ï‰Sup c = Part.none
Result.exception ::
Duper saturated

Testing || SimpleGraph.Connected.mono : âˆ€ {V : Type u} {G G' : SimpleGraph V}, G â‰¤ G' â†’ G.Connected â†’ G'.Connected
Result.exception ::
Duper saturated

Testing || CochainComplex.mappingCone.lift_snd : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C â„¤} (Ï† : F âŸ¶ G) [inst_2 : HomologicalComplex.HasHomotopyCofiber Ï†] {K : CochainComplex C â„¤}
  (Î± : CochainComplex.HomComplex.Cocycle K F 1) (Î² : CochainComplex.HomComplex.Cochain K G 0)
  (eq : CochainComplex.HomComplex.Î´ 0 1 Î² + (â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯ = 0),
  (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift Ï† Î± Î² eq)).comp
      (CochainComplex.mappingCone.snd Ï†) â‹¯ =
    Î²
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CochainComplex.HomComplex.Î´.proof_1
  cifvar_23 (cifvar_28 xâœÂ¹)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submonoid.mem_prod : âˆ€ {N : Type u_2} [inst : MulOneClass N] {M : Type u_5} [inst_1 : MulOneClass M] {s : Submonoid M} {t : Submonoid N}
  {p : M Ã— N}, p âˆˆ s.prod t â†” p.1 âˆˆ s âˆ§ p.2 âˆˆ t
Result.exception ::
Duper saturated

Testing || CategoryTheory.sheafifyMap_sheafifyLift : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type u_1}
  [inst_1 : CategoryTheory.Category.{u_2, u_1} D] [inst_2 : CategoryTheory.HasWeakSheafify J D]
  {P Q R : CategoryTheory.Functor Cáµ’áµ– D} (Î· : P âŸ¶ Q) (Î³ : Q âŸ¶ R) (hR : CategoryTheory.Presheaf.IsSheaf J R),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyMap J Î·) (CategoryTheory.sheafifyLift J Î³ hR) =
    CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.comp Î· Î³) hR
Result.exception ::
Duper saturated

Testing || UniformOnFun.toFun_zero : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {ğ”– : Set (Set Î±)} [inst : _root_.Zero Î²], (UniformOnFun.toFun ğ”–) 0 = 0
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (Â¬ ((!0 !1 !2) = !2)) is not type correct

Testing || EuclideanGeometry.Sphere.secondInter_smul : âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] (s : EuclideanGeometry.Sphere P) (p : P) (v : V) {r : â„},
  r â‰  0 â†’ s.secondInter p (r â€¢ v) = s.secondInter p v
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || disjoint_sdiff_comm : âˆ€ {Î± : Type u} {x y z : Î±} [inst : GeneralizedBooleanAlgebra Î±], Disjoint (x \ z) y â†” Disjoint x (y \ z)
Result.success

Testing || compl_add_closure_zero_eq : âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] {t : Set G},
  t + closure {0} = t â†’ tá¶œ + closure {0} = tá¶œ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!7 !15 !9) = !0) is not type correct

Testing || Polynomial.Monic.natDegree_pos_of_not_isUnit : âˆ€ {R : Type u} [inst : CommSemiring R] {p : Polynomial R}, p.Monic â†’ Â¬IsUnit p â†’ 0 < p.natDegree
Result.success

Testing || AddSubgroup.eq_of_le_of_card_ge : âˆ€ {G : Type u_1} [inst : AddGroup G] {H K : AddSubgroup G} [inst_1 : Finite â†¥K],
  H â‰¤ K â†’ Nat.card â†¥K â‰¤ Nat.card â†¥H â†’ H = K
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (#1 â†’ Prop), ((!12 x0) = (!1 x0))) is not type correct

Testing || WittVector.mulN_coeff : âˆ€ {p : â„•} {R : Type u_1} [hp : Fact (Nat.Prime p)] [inst : CommRing R] (n : â„•) (x : WittVector p R) (k : â„•),
  (x * â†‘n).coeff k = (MvPolynomial.aeval x.coeff) (WittVector.wittMulN p n k)
Result.exception ::
Duper saturated

Testing || isIntegralCurveAt_comp_mul_ne_zero : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {H : Type u_2} [inst_2 : TopologicalSpace H]
  {I : ModelWithCorners â„ E H} {M : Type u_3} [inst_3 : TopologicalSpace M] [inst_4 : ChartedSpace H M] {Î³ : â„ â†’ M}
  {v : (x : M) â†’ TangentSpace I x} {tâ‚€ a : â„},
  a â‰  0 â†’ (IsIntegralCurveAt Î³ v tâ‚€ â†” IsIntegralCurveAt (Î³ âˆ˜ fun x => x * a) (a â€¢ v) (tâ‚€ / a))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instAddCommGroupTangentSpace
  cifvar_12`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DomAddAct.instAddActionSubtypeAEEqFunMemAddAddSubgroupLp.proof_2 : âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}
  {p : ENNReal}, Function.Injective Subtype.val
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of Î» binder contains bound variables

Testing || AddSubmonoid.le_op_iff : âˆ€ {M : Type u_2} [inst : AddZeroClass M] {Sâ‚ : AddSubmonoid Máµƒáµ’áµ–} {Sâ‚‚ : AddSubmonoid M}, Sâ‚ â‰¤ Sâ‚‚.op â†” Sâ‚.unop â‰¤ Sâ‚‚
Result.exception ::
Duper saturated

Testing || LinOrd.dualEquiv_inverse : LinOrd.dualEquiv.inverse = LinOrd.dual
Result.success

Testing || Complex.nnnorm_real : âˆ€ (r : â„), â€–â†‘râ€–â‚Š = â€–râ€–â‚Š
Result.exception ::
Duper saturated

Testing || Sublattice.mem_sInf : âˆ€ {Î± : Type u_2} [inst : Lattice Î±] {a : Î±} {S : Set (Sublattice Î±)}, a âˆˆ sInf S â†” âˆ€ L âˆˆ S, a âˆˆ L
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i âˆˆ S of Î» binder contains bound variables

Testing || CategoryTheory.ChosenFiniteProducts.lift_snd : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ChosenFiniteProducts C] {T X Y : C}
  (f : T âŸ¶ X) (g : T âŸ¶ Y),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g)
      (CategoryTheory.ChosenFiniteProducts.snd X Y) =
    g
Result.exception ::
Duper saturated

Testing || Cardinal.mk_quotient_le : âˆ€ {Î± : Type u} {s : Setoid Î±}, Cardinal.mk (Quotient s) â‰¤ Cardinal.mk Î±
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `â‡‘s`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TrivSqZeroExt.snd_exp : âˆ€ (ğ•œ : Type u_1) {R : Type u_3} {M : Type u_4} [inst : Field ğ•œ] [inst_1 : CharZero ğ•œ] [inst_2 : CommRing R]
  [inst_3 : AddCommGroup M] [inst_4 : Algebra ğ•œ R] [inst_5 : _root_.Module ğ•œ M] [inst_6 : _root_.Module R M]
  [inst_7 : _root_.Module Ráµáµ’áµ– M] [inst_8 : IsCentralScalar R M] [inst_9 : IsScalarTower ğ•œ R M]
  [inst_10 : TopologicalSpace R] [inst_11 : TopologicalSpace M] [inst_12 : TopologicalRing R]
  [inst_13 : TopologicalAddGroup M] [inst_14 : ContinuousSMul R M] [inst_15 : ContinuousSMul Ráµáµ’áµ– M]
  [inst_16 : T2Space R] [inst_17 : T2Space M] (x : TrivSqZeroExt R M),
  (NormedSpace.exp ğ•œ x).snd = NormedSpace.exp ğ•œ x.fst â€¢ x.snd
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `TrivSqZeroExt.nonAssocRing`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AlgebraicTopology.DoldKan.Q_f_idem : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {X : CategoryTheory.SimplicialObject C} (q n : â„•),
  CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Q q).f n) ((AlgebraicTopology.DoldKan.Q q).f n) =
    (AlgebraicTopology.DoldKan.Q q).f n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_9 x_0).f x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Isometry.mapsTo_perpBisector : âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {V' : Type u_3} {P' : Type u_4} [inst_4 : NormedAddCommGroup V']
  [inst_5 : InnerProductSpace â„ V'] [inst_6 : MetricSpace P'] [inst_7 : NormedAddTorsor V' P'] {f : P â†’ P'},
  Isometry f â†’
    âˆ€ (pâ‚ pâ‚‚ : P), Set.MapsTo f â†‘(AffineSubspace.perpBisector pâ‚ pâ‚‚) â†‘(AffineSubspace.perpBisector (f pâ‚) (f pâ‚‚))
Result.exception ::
Duper saturated

Testing || CategoryTheory.Discrete.monoidal_leftUnitor : âˆ€ (M : Type u) [inst : Monoid M] (X : CategoryTheory.Discrete M),
  CategoryTheory.MonoidalCategory.leftUnitor X = CategoryTheory.Discrete.eqToIso â‹¯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (p : { as := 1 * X.as } = X),
  CategoryTheory.MonoidalCategory.leftUnitor X =
    CategoryTheory.eqToIso p, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || contravariant_lt_of_contravariant_le : âˆ€ (M : Type u_1) (N : Type u_2) (Î¼ : M â†’ N â†’ N) [inst : PartialOrder N],
  (Contravariant M N Î¼ fun x1 x2 => x1 â‰¤ x2) â†’ Contravariant M N Î¼ fun x1 x2 => x1 < x2
Result.success

Testing || Int.eq_mul_div_of_mul_eq_mul_of_dvd_left : âˆ€ {a b c d : â„¤}, b â‰  0 â†’ b âˆ£ c â†’ b * a = c * d â†’ a = c / b * d
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || pointedToPartialFun_map : âˆ€ {X Y : Pointed} (f : X âŸ¶ Y) (a : { x // x â‰  X.point }),
  pointedToPartialFun.map f a = (PFun.toSubtype (fun x => x â‰  Y.point) f.toFun âˆ˜ Subtype.val) a
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: pointedToPartialFun.obj Xâœ âŸ¶ pointedToPartialFun.obj Yâœ is not a `âˆ€`

Testing || MulRingSeminormClass.toRingSeminormClass : âˆ€ {F : Type u_2} {Î± : Type u_3} {Î² : Type u_4} [inst : FunLike F Î± Î²] [inst_1 : NonAssocRing Î±]
  [inst_2 : OrderedSemiring Î²] [inst_3 : MulRingSeminormClass F Î± Î²], RingSeminormClass F Î± Î²
Result.exception ::
Duper saturated

Testing || CategoryTheory.ThinSkeleton.map_id_eq : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : Quiver.IsThin C],
  CategoryTheory.ThinSkeleton.map (CategoryTheory.Functor.id C) =
    CategoryTheory.Functor.id (CategoryTheory.ThinSkeleton C)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type xâœÂ³ â‰ˆ xâœÂ² of Î» binder contains bound variables

Testing || Ordinal.pred_lt_iff_is_succ : âˆ€ {o : Ordinal.{u_4}}, o.pred < o â†” âˆƒ a, o = Order.succ a
Result.exception ::
Duper saturated

Testing || Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors : âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R} {t : R} {n : â„•},
  p â‰  0 â†’
    â†‘n.factorial âˆˆ nonZeroDivisors R â†’
      (n < Polynomial.rootMultiplicity t p â†” âˆ€ m â‰¤ n, ((â‡‘Polynomial.derivative)^[m] p).IsRoot t)
Result.success

Testing || List.Vector.mem_iff_get : âˆ€ {Î± : Type u_1} {n : â„•} (a : Î±) (v : List.Vector Î± n), a âˆˆ v.toList â†” âˆƒ i, v.get i = a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Fin x_1.length of Î» binder contains bound variables

Testing || Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem : âˆ€ {n : â„•} {l : Std.Sat.Literal (Std.Tactic.BVDecide.LRAT.Internal.PosFin n)}
  {lratClause : Std.Tactic.BVDecide.LRAT.Internal.DefaultClause n}
  (clause : Std.Sat.CNF.Clause (Std.Tactic.BVDecide.LRAT.Internal.PosFin n)),
  l âˆˆ clause â†’
    Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.ofArray (List.toArray clause) = some lratClause â†’
      l âˆˆ lratClause.clause
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instDecidableEqBool
  (cifvar_17 (cifvar_12 (cifvar_18 x_1) (cifvar_19 (cifvar_20 x_1))) (cifvar_9 x_0)) cifvar_13`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || HomologicalComplexâ‚‚.d_f_comp_d_f : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {Iâ‚ : Type u_2} {Iâ‚‚ : Type u_3} {câ‚ : ComplexShape Iâ‚} {câ‚‚ : ComplexShape Iâ‚‚} (K : HomologicalComplexâ‚‚ C câ‚ câ‚‚)
  (iâ‚ iâ‚' iâ‚'' : Iâ‚) (iâ‚‚ : Iâ‚‚), CategoryTheory.CategoryStruct.comp ((K.d iâ‚ iâ‚').f iâ‚‚) ((K.d iâ‚' iâ‚'').f iâ‚‚) = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_9 x_0 x_1).f x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || grade_lt_grade_iff : âˆ€ {ğ•† : Type u_1} {Î± : Type u_3} [inst : Preorder ğ•†] [inst_1 : LinearOrder Î±] [inst_2 : GradeOrder ğ•† Î±] {a b : Î±},
  grade ğ•† a < grade ğ•† b â†” a < b
Result.success

Testing || Matrix.vecMulVec_empty : âˆ€ {Î± : Type u} {m' : Type uâ‚˜} [inst : NonUnitalNonAssocSemiring Î±] (v : m' â†’ Î±) (w : Fin 0 â†’ Î±),
  Matrix.vecMulVec v w = Matrix.of fun x => ![]
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.join_map_filter : âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (l : List (List Î±)), (List.map (List.filter p) l).flatten = List.filter p l.flatten
Result.success

Testing || Matrix.circulant_add : âˆ€ {Î± : Type u_1} {n : Type u_3} [inst : Add Î±] [inst_1 : Sub n] (v w : n â†’ Î±),
  Matrix.circulant (v + w) = Matrix.circulant v + Matrix.circulant w
Result.success

Testing || CategoryTheory.CostructuredArrow.map_obj_hom : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {T T' : D} {S : CategoryTheory.Functor C D} (f : T âŸ¶ T')
  (X : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)),
  ((CategoryTheory.CostructuredArrow.map f).obj X).hom = CategoryTheory.CategoryStruct.comp X.hom f
Result.success

Testing || LinearMap.range_toContinuousLinearMap : âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : _root_.Module ğ•œ E]
  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F' : Type x}
  [inst_5 : AddCommGroup F'] [inst_6 : _root_.Module ğ•œ F'] [inst_7 : TopologicalSpace F']
  [inst_8 : TopologicalAddGroup F'] [inst_9 : ContinuousSMul ğ•œ F'] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E]
  [inst_12 : FiniteDimensional ğ•œ E] (f : E â†’â‚—[ğ•œ] F'),
  LinearMap.range (LinearMap.toContinuousLinearMap f) = LinearMap.range f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ContinuousLinearMap.funLike`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LinearEquiv.isUnit_det : âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {M' : Type u_3} [inst_3 : AddCommGroup M'] [inst_4 : _root_.Module R M'] {Î¹ : Type u_4} [inst_5 : DecidableEq Î¹]
  [inst_6 : Fintype Î¹] (f : M â‰ƒâ‚—[R] M') (v : Basis Î¹ R M) (v' : Basis Î¹ R M'), IsUnit ((LinearMap.toMatrix v v') â†‘f).det
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || riemannZeta_eulerProduct_hasProd : âˆ€ {s : â„‚}, 1 < s.re â†’ HasProd (fun p => (1 - â†‘â†‘p ^ (-s))â»Â¹) (riemannZeta s)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || FiniteDimensional.finiteDimensional_subalgebra : âˆ€ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E]
  [inst_3 : FiniteDimensional F E] (S : Subalgebra F E), FiniteDimensional F â†¥S
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.iUnion_vadd_left_image : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : VAdd Î± Î²] {s : Set Î±} {t : Set Î²}, â‹ƒ a âˆˆ s, a +áµ¥ t = s +áµ¥ t
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a âˆˆ s of Î» binder contains bound variables

Testing || SimpleGraph.edgeSet_ssubset_edgeSet : âˆ€ {V : Type u} {Gâ‚ Gâ‚‚ : SimpleGraph V}, Gâ‚.edgeSet âŠ‚ Gâ‚‚.edgeSet â†” Gâ‚ < Gâ‚‚
Result.success

Testing || isAtomic_iff_isCoatomic : âˆ€ {Î± : Type u_2} [inst : Lattice Î±] [inst_1 : BoundedOrder Î±] [inst_2 : IsModularLattice Î±]
  [inst_3 : ComplementedLattice Î±], IsAtomic Î± â†” IsCoatomic Î±
Result.success

Testing || AlgebraicGeometry.isSurjectiveOnStalks_isLocalAtTarget : AlgebraicGeometry.IsLocalAtTarget
  (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] x => Function.Surjective â‡‘x)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing Râœ of Î» binder contains bound variables

Testing || hasGroupoid_continuousGroupoid : âˆ€ {H : Type u} {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M],
  HasGroupoid M (continuousGroupoid H)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type IsOpen uâœÂ² of Î» binder contains bound variables

Testing || SimpleGraph.Walk.reverse_singleton : âˆ€ {V : Type u} {G : SimpleGraph V} {u v : V} (h : G.Adj u v),
  (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).reverse = SimpleGraph.Walk.cons â‹¯ SimpleGraph.Walk.nil
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Symmetric G.Adj is not a `âˆ€`

Testing || divp_assoc' : âˆ€ {Î± : Type u} [inst : Monoid Î±] (x y : Î±) (u : Î±Ë£), x * (y /â‚š u) = x * y /â‚š u
Result.success

Testing || Set.add_iUnion : âˆ€ {Î± : Type u_2} {Î¹ : Sort u_5} [inst : Add Î±] (s : Set Î±) (t : Î¹ â†’ Set Î±), s + â‹ƒ i, t i = â‹ƒ i, s + t i
Result.success

Testing || PiToModule.fromEnd_apply : âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] {M : Type u_2} [inst_1 : AddCommGroup M] (R : Type u_3) [inst_2 : CommRing R]
  [inst_3 : _root_.Module R M] (b : Î¹ â†’ M) (f : Module.End R M) (w : Î¹ â†’ R),
  ((PiToModule.fromEnd R b) f) w = f (((Fintype.linearCombination R R) b) w)
Result.success

Testing || ContextFreeGrammar.derives_reverse_comm : âˆ€ {T : Type uT} {g : ContextFreeGrammar T} {u v : List (Symbol T g.NT)},
  g.reverse.Derives u v â†” g.Derives u.reverse v.reverse
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_compHom : âˆ€ {X Y Z : AlgebraicGeometry.Scheme} (f : X.PartialMap Y) (g : Y âŸ¶ Z) (x : â†‘â†‘X.toPresheafedSpace)
  (hx : x âˆˆ (f.compHom g).domain),
  (f.compHom g).fromSpecStalkOfMem hx = CategoryTheory.CategoryStruct.comp (f.fromSpecStalkOfMem hx) g
Result.exception ::
Duper saturated

Testing || CochainComplex.HomComplex.Î´_comp_zero_cocycle : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G K : CochainComplex C â„¤} {n : â„¤} (zâ‚ : CochainComplex.HomComplex.Cochain F G n)
  (zâ‚‚ : CochainComplex.HomComplex.Cocycle G K 0) (m : â„¤),
  CochainComplex.HomComplex.Î´ n m (zâ‚.comp â†‘zâ‚‚ â‹¯) = (CochainComplex.HomComplex.Î´ n m zâ‚).comp â†‘zâ‚‚ â‹¯
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CochainComplex.HomComplex.Î´
  cifvar_13 x_1 (cifvar_5 x_0)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NumberField.mixedEmbedding.instIsZLatticeRealMixedSpaceIntegerLattice : âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsZLattice â„ (NumberField.mixedEmbedding.integerLattice K)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || addEquivOfAddOrderOfEq.proof_1 : âˆ€ {G : Type u_2} {G' : Type u_1} [inst : AddGroup G] [inst_1 : AddGroup G'] {g : G} {g' : G'},
  addOrderOf g = addOrderOf g' â†’ addOrderOf g' âˆ£ addOrderOf g
Result.success

Testing || kstar_mul_kstar : âˆ€ {Î± : Type u_1} [inst : KleeneAlgebra Î±] (a : Î±), KStar.kstar a * KStar.kstar a = KStar.kstar a
Result.success

Testing || Real.rpow_eq_zero : âˆ€ {x y : â„}, 0 â‰¤ x â†’ y â‰  0 â†’ (x ^ y = 0 â†” x = 0)
Result.success

Testing || MvPowerSeries.coeff_mul_left_one_sub_of_lt_weightedOrder : âˆ€ {Ïƒ : Type u_1} (w : Ïƒ â†’ â„•) {R : Type u_3} [inst : Ring R] {f g : MvPowerSeries Ïƒ R} {d : Ïƒ â†’â‚€ â„•},
  â†‘((Finsupp.weight w) d) < MvPowerSeries.weightedOrder w g â†’
    (MvPowerSeries.coeff R d) (f * (1 - g)) = (MvPowerSeries.coeff R d) f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubNegMonoid`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Arrow.w_mk_right_assoc : âˆ€ {T : Type u} [inst : CategoryTheory.Category.{v, u} T] {f : CategoryTheory.Arrow T} {X Y : T} {g : X âŸ¶ Y}
  (sq : f âŸ¶ CategoryTheory.Arrow.mk g) {Z : T} (h : Y âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp g h) =
    CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp sq.right h)
Result.success

Testing || CommRingCat.isLocalRingHom_comp : âˆ€ {R S T : CommRingCat} (f : R âŸ¶ S) (g : S âŸ¶ T) [inst : IsLocalHom g.hom] [inst : IsLocalHom f.hom],
  IsLocalHom (CategoryTheory.CategoryStruct.comp f g).hom
Result.success

Testing || Nat.eq_of_dvd_of_lt_two_mul : âˆ€ {a b : â„•}, a â‰  0 â†’ b âˆ£ a â†’ a < 2 * b â†’ a = b
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finsupp.Lex.single_strictAnti : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±], StrictAnti fun a => toLex funâ‚€ | a => 1
Result.exception ::
Duper saturated

Testing || neg_iff_neg_of_mul_pos : âˆ€ {Î± : Type u_3} {a b : Î±} [inst : MulZeroClass Î±] [inst_1 : LinearOrder Î±] [inst_2 : PosMulMono Î±]
  [inst_3 : MulPosMono Î±], 0 < a * b â†’ (a < 0 â†” b < 0)
Result.success

Testing || Derivation.coe_neg : âˆ€ {R : Type u_1} [inst : CommRing R] {A : Type u_2} [inst_1 : CommRing A] [inst_2 : Algebra R A] {M : Type u_3}
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module A M] [inst_5 : _root_.Module R M] (D : Derivation R A M),
  â‡‘(-D) = -â‡‘D
Result.exception ::
Duper saturated

Testing || Quotient.finChoiceEquiv_symm_apply : âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] [inst_1 : DecidableEq Î¹] {Î± : Î¹ â†’ Sort u_2} {S : (i : Î¹) â†’ Setoid (Î± i)}
  (q : Quotient inferInstance) (i : Î¹), Quotient.finChoiceEquiv.symm q i = q.eval i
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Filter.add_neBot_iff : âˆ€ {Î± : Type u_2} [inst : Add Î±] {f g : Filter Î±}, (f + g).NeBot â†” f.NeBot âˆ§ g.NeBot
Result.success

Testing || Filter.cocardinal_aleph0_eq_cofinite : âˆ€ {Î± : Type u}, Filter.cocardinal Î± Cardinal.isRegular_aleph0 = Filter.cofinite
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (#3 â†’ Prop), ((!4 (!5 (!6 (Î»x1 : #3, (x0 x1)))) !7) = (!8 (!9 (Î»x1 : #3, (x0 x1)))))) is not type correct

Testing || ContDiffAt.snd : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {n : WithTop â„•âˆ} {f : E â†’ F Ã— G} {x : E},
  ContDiffAt ğ•œ n f x â†’ ContDiffAt ğ•œ n (fun x => (f x).2) x
Result.success

Testing || stdSimplex_unique : âˆ€ (ğ•œ : Type u_1) (Î¹ : Type u_5) [inst : OrderedSemiring ğ•œ] [inst_1 : Fintype Î¹] [inst_2 : Nonempty Î¹]
  [inst_3 : Subsingleton Î¹], stdSimplex ğ•œ Î¹ = {fun x => 1}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!7 !0 !1) = (!0 !1)) is not type correct

Testing || Matrix.UnitaryGroup.star_mul_self : âˆ€ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {Î± : Type v} [inst_2 : CommRing Î±] [inst_3 : StarRing Î±]
  (A : â†¥(Matrix.unitaryGroup n Î±)), star â†‘A * â†‘A = 1
Result.exception ::
Duper saturated

Testing || List.find?_replicate_of_neg : âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {n : â„•} {a : Î±}, Â¬p a = true â†’ List.find? p (List.replicate n a) = none
Result.success

Testing || covBy_iff_wcovBy_and_ne : âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a b : Î±}, a â‹– b â†” a â©¿ b âˆ§ a â‰  b
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.toReal_laverage : âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},
  AEMeasurable f Î¼ â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼, f x â‰  âŠ¤) â†’ (â¨â» (x : Î±), f x âˆ‚Î¼).toReal = â¨ (x : Î±), (f x).toReal âˆ‚Î¼
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CofiniteTopology.nhds_eq : âˆ€ {X : Type u} (x : CofiniteTopology X), nhds x = pure x âŠ” Filter.cofinite
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Î± â†’
  Prop, type of âˆ€ bound variable is not of sort `Prop`, and depends on bound variables

Testing || ENat.one_lt_card_iff_nontrivial : âˆ€ (Î± : Type u_3), 1 < ENat.card Î± â†” Nontrivial Î±
Result.exception ::
Duper saturated

Testing || SetTheory.PGame.lf_of_le_moveLeft : âˆ€ {x y : SetTheory.PGame} {i : y.LeftMoves}, x â‰¤ y.moveLeft i â†’ x.LF y
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x_0.RightMoves of Î» binder contains bound variables

Testing || Finset.sdiff_empty : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {s : Finset Î±}, s \ âˆ… = s
Result.success

Testing || Vector.continuous_insertIdx' : âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {n : â„•} {i : Fin (n + 1)},
  Continuous fun p => List.Vector.insertIdx p.1 i p.2
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Polynomial.nontrivial_iff : âˆ€ {R : Type u} [inst : Semiring R], Nontrivial (Polynomial R) â†” Nontrivial R
Result.exception ::
Duper saturated

Testing || AlgebraicGeometry.AffineScheme.Î“_preservesLimits : CategoryTheory.Limits.PreservesLimits AlgebraicGeometry.AffineScheme.Î“.rightOp
Result.exception ::
Duper saturated

Testing || Int.fract_sub_self : âˆ€ {Î± : Type u_2} [inst : LinearOrderedRing Î±] [inst_1 : FloorRing Î±] (a : Î±), Int.fract a - a = -â†‘âŒŠaâŒ‹
Result.success

Testing || OrderIso.bddBelow_image : âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] (e : Î± â‰ƒo Î²) {s : Set Î±},
  BddBelow (â‡‘e '' s) â†” BddBelow s
Result.exception ::
Duper saturated

Testing || ContinuousMap.comp_id : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : C(Î±, Î²)),
  f.comp (ContinuousMap.id Î±) = f
Result.success

Testing || MvPolynomial.joinâ‚‚_comp_map : âˆ€ {Ïƒ : Type u_1} {R : Type u_3} {S : Type u_4} [inst : CommSemiring R] [inst_1 : CommSemiring S]
  (f : R â†’+* MvPolynomial Ïƒ S), MvPolynomial.joinâ‚‚.comp (MvPolynomial.map f) = MvPolynomial.bindâ‚‚ f
Result.exception ::
Duper saturated

Testing || CircleDeg1Lift.map_sub_int : âˆ€ (f : CircleDeg1Lift) (x : â„) (n : â„¤), f (x - â†‘n) = f x - â†‘n
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Polynomial.natDegree_hermite : âˆ€ {n : â„•}, (Polynomial.hermite n).natDegree = n
Result.success

Testing || Monotone.map_sInf_of_continuousAt : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : CompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]
  [inst_3 : CompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²}
  {s : Set Î±}, ContinuousAt f (sInf s) â†’ Monotone f â†’ f âŠ¤ = âŠ¤ â†’ f (sInf s) = sInf (f '' s)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Î± â†’
  Prop, type of âˆ€ bound variable is not of sort `Prop`, and depends on bound variables

Testing || MemHolder.nnHolderNorm_nsmul : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : NormedAddCommGroup Y] {r : NNReal} {f : X â†’ Y}
  [inst_2 : _root_.Module â„ Y] [inst_3 : BoundedSMul â„ Y] (n : â„•),
  MemHolder r f â†’ nnHolderNorm r (n â€¢ f) = n â€¢ nnHolderNorm r f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Module.toMulActionWithZero`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Int.lt.intro : âˆ€ {a b : â„¤} {n : â„•}, a + â†‘n.succ = b â†’ a < b
Result.success

Testing || IsOpen.mul_left : âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Group Î±] [inst_2 : ContinuousConstSMul Î± Î±] {s t : Set Î±},
  IsOpen t â†’ IsOpen (s * t)
Result.success

Testing || MulAction.IsBlock.empty : âˆ€ {G : Type u_1} {X : Type u_2} [inst : SMul G X], MulAction.IsBlock G âˆ…
Result.exception ::
Duper saturated

Testing || MonoidAlgebra.opRingEquiv_single : âˆ€ {k : Type uâ‚} {G : Type uâ‚‚} [inst : Semiring k] [inst_1 : Monoid G] (r : k) (x : G),
  MonoidAlgebra.opRingEquiv (MulOpposite.op (MonoidAlgebra.single x r)) =
    MonoidAlgebra.single (MulOpposite.op x) (MulOpposite.op r)
Result.exception ::
Duper saturated

Testing || TwoSidedIdeal.mem_ker : âˆ€ {R : Type u_1} {S : Type u_2} [inst : NonUnitalNonAssocRing R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_3}
  [inst_2 : FunLike F R S] [inst_3 : NonUnitalRingHomClass F R S] (f : F) {x : R}, x âˆˆ TwoSidedIdeal.ker f â†” f x = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Zero.toOfNat0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.GradedObject.Î¹_mapBifunctorAssociator_inv : âˆ€ {Câ‚ : Type u_1} {Câ‚‚ : Type u_2} {Câ‚â‚‚ : Type u_3} {Câ‚‚â‚ƒ : Type u_4} {Câ‚ƒ : Type u_5} {Câ‚„ : Type u_6}
  [inst : CategoryTheory.Category.{u_13, u_1} Câ‚] [inst_1 : CategoryTheory.Category.{u_15, u_2} Câ‚‚]
  [inst_2 : CategoryTheory.Category.{u_14, u_5} Câ‚ƒ] [inst_3 : CategoryTheory.Category.{u_11, u_6} Câ‚„]
  [inst_4 : CategoryTheory.Category.{u_17, u_3} Câ‚â‚‚] [inst_5 : CategoryTheory.Category.{u_12, u_4} Câ‚‚â‚ƒ]
  {Fâ‚â‚‚ : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚â‚‚)}
  {G : CategoryTheory.Functor Câ‚â‚‚ (CategoryTheory.Functor Câ‚ƒ Câ‚„)}
  {F : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚â‚ƒ Câ‚„)}
  {Gâ‚‚â‚ƒ : CategoryTheory.Functor Câ‚‚ (CategoryTheory.Functor Câ‚ƒ Câ‚‚â‚ƒ)}
  (associator : CategoryTheory.bifunctorCompâ‚â‚‚ Fâ‚â‚‚ G â‰… CategoryTheory.bifunctorCompâ‚‚â‚ƒ F Gâ‚‚â‚ƒ) {Iâ‚ : Type u_7}
  {Iâ‚‚ : Type u_8} {Iâ‚ƒ : Type u_9} {J : Type u_10} {r : Iâ‚ Ã— Iâ‚‚ Ã— Iâ‚ƒ â†’ J}
  (Ïâ‚â‚‚ : CategoryTheory.GradedObject.BifunctorCompâ‚â‚‚IndexData r)
  (Ïâ‚‚â‚ƒ : CategoryTheory.GradedObject.BifunctorCompâ‚‚â‚ƒIndexData r) (Xâ‚ : CategoryTheory.GradedObject Iâ‚ Câ‚)
  (Xâ‚‚ : CategoryTheory.GradedObject Iâ‚‚ Câ‚‚) (Xâ‚ƒ : CategoryTheory.GradedObject Iâ‚ƒ Câ‚ƒ)
  [inst_6 : (((CategoryTheory.GradedObject.mapBifunctor Fâ‚â‚‚ Iâ‚ Iâ‚‚).obj Xâ‚).obj Xâ‚‚).HasMap Ïâ‚â‚‚.p]
  [inst_7 :
    (((CategoryTheory.GradedObject.mapBifunctor G Ïâ‚â‚‚.Iâ‚â‚‚ Iâ‚ƒ).obj
              (CategoryTheory.GradedObject.mapBifunctorMapObj Fâ‚â‚‚ Ïâ‚â‚‚.p Xâ‚ Xâ‚‚)).obj
          Xâ‚ƒ).HasMap
      Ïâ‚â‚‚.q]
  [inst_8 : (((CategoryTheory.GradedObject.mapBifunctor Gâ‚‚â‚ƒ Iâ‚‚ Iâ‚ƒ).obj Xâ‚‚).obj Xâ‚ƒ).HasMap Ïâ‚‚â‚ƒ.p]
  [inst_9 :
    (((CategoryTheory.GradedObject.mapBifunctor F Iâ‚ Ïâ‚‚â‚ƒ.Iâ‚‚â‚ƒ).obj Xâ‚).obj
          (CategoryTheory.GradedObject.mapBifunctorMapObj Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ.p Xâ‚‚ Xâ‚ƒ)).HasMap
      Ïâ‚‚â‚ƒ.q]
  [Hâ‚â‚‚ : CategoryTheory.GradedObject.HasGoodTrifunctorâ‚â‚‚Obj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ]
  [Hâ‚‚â‚ƒ : CategoryTheory.GradedObject.HasGoodTrifunctorâ‚‚â‚ƒObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ] (iâ‚ : Iâ‚) (iâ‚‚ : Iâ‚‚) (iâ‚ƒ : Iâ‚ƒ) (j : J)
  (h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j),
  CategoryTheory.CategoryStruct.comp
      (CategoryTheory.GradedObject.Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h)
      ((CategoryTheory.GradedObject.mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j) =
    CategoryTheory.CategoryStruct.comp (((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ))
      (CategoryTheory.GradedObject.Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.GradedObject (Iâ‚ Ã— Iâ‚‚) Câ‚â‚‚ is not a `âˆ€`

Testing || AddSubmonoid.toAddZeroClass.proof_1 : âˆ€ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), Function.Injective fun a => â†‘a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of Î» binder contains bound variables

Testing || List.subset_append_of_subset_left : âˆ€ {Î± : Type u_1} {l lâ‚ : List Î±} (lâ‚‚ : List Î±), l âŠ† lâ‚ â†’ l âŠ† lâ‚ ++ lâ‚‚
Result.success

Testing || CompHausLike.instHasPropSigma : âˆ€ {P : TopCat â†’ Prop} [inst : CompHausLike.HasExplicitFiniteCoproducts P] {Î± : Type u} [inst : Finite Î±]
  (Ïƒ : Î± â†’ Type u) [inst : (a : Î±) â†’ TopologicalSpace (Ïƒ a)] [inst_1 : âˆ€ (a : Î±), CompactSpace (Ïƒ a)]
  [inst_2 : âˆ€ (a : Î±), T2Space (Ïƒ a)] [inst_3 : âˆ€ (a : Î±), CompHausLike.HasProp P (Ïƒ a)],
  CompHausLike.HasProp P ((a : Î±) Ã— Ïƒ a)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instâœÂ³ x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || tsupport_smul_subset_right : âˆ€ {X : Type u_1} {M : Type u_9} {Î± : Type u_10} [inst : TopologicalSpace X] [inst_1 : _root_.Zero Î±]
  [inst_2 : SMulZeroClass M Î±] (f : X â†’ M) (g : X â†’ Î±), (tsupport fun x => f x â€¢ g x) âŠ† tsupport g
Result.exception ::
Duper saturated

Testing || NONote.NF : âˆ€ (o : NONote), (â†‘o).NF
Result.success

Testing || Primrec.cond : âˆ€ {Î± : Type u_1} {Ïƒ : Type u_3} [inst : Primcodable Î±] [inst_1 : Primcodable Ïƒ] {c : Î± â†’ Bool} {f g : Î± â†’ Ïƒ},
  Primrec c â†’ Primrec f â†’ Primrec g â†’ Primrec fun a => bif c a then f a else g a
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Submodule.Quotient.equiv_apply : âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {N : Type u_5}
  [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R N] (P : Submodule R M) (Q : Submodule R N) (f : M â‰ƒâ‚—[R] N)
  (hf : Submodule.map f P = Q) (a : M â§¸ P), (Submodule.Quotient.equiv P Q f hf) a = (P.mapQ Q â†‘f â‹¯) a
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `aâœ.quotientRel`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || BitVec.neg_neg : âˆ€ {w : â„•} {x : BitVec w}, - -x = x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `BitVec.instNeg`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.finRange_zero : List.finRange 0 = []
Result.success

Testing || Finset.sups_nonempty : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : SemilatticeSup Î±] {s t : Finset Î±},
  (s âŠ» t).Nonempty â†” s.Nonempty âˆ§ t.Nonempty
Result.success

Testing || Ordnode.Valid.merge : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {l r : Ordnode Î±},
  l.Valid â†’ r.Valid â†’ Ordnode.All (fun x => Ordnode.All (fun y => x < y) r) l â†’ (l.merge r).Valid
Result.success

Testing || SzemerediRegularity.increment_isEquipartition : âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±] {P : Finpartition Finset.univ} (hP : P.IsEquipartition)
  (G : SimpleGraph Î±) [inst_2 : DecidableRel G.Adj] (Îµ : â„), (SzemerediRegularity.increment hP G Îµ).IsEquipartition
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #5, (âˆ€ x1 : #4, ((!6 (!13 (!14 x0)) x1) = (!8 x0 x1)))) is not type correct

Testing || ChainComplex.quasiIsoAtâ‚€_iff : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {K L : ChainComplex C â„•} (f : K âŸ¶ L) [inst_2 : HomologicalComplex.HasHomology K 0]
  [inst_3 : HomologicalComplex.HasHomology L 0] [inst_4 : (HomologicalComplex.sc' K 1 0 0).HasHomology]
  [inst_5 : (HomologicalComplex.sc' L 1 0 0).HasHomology],
  QuasiIsoAt f 0 â†”
    CategoryTheory.ShortComplex.QuasiIso ((HomologicalComplex.shortComplexFunctor' C (ComplexShape.down â„•) 1 0 0).map f)
Result.exception ::
Duper saturated

Testing || Vector.indexOf?_mk : âˆ€ {Î± : Type u_1} {n : â„•} [inst : BEq Î±] (a : Array Î±) (h : a.size = n) (x : Î±),
  { toArray := a, size_toArray := h }.indexOf? x = Option.map (Fin.cast h) (a.indexOf? x)
Result.success

Testing || UpperSet.coe_compl : âˆ€ {Î± : Type u_1} [inst : LE Î±] (s : UpperSet Î±), â†‘s.compl = (â†‘s)á¶œ
Result.success

Testing || Equiv.Perm.IsCycle.support_pow_eq_iff : âˆ€ {Î± : Type u_2} {f : Equiv.Perm Î±} [inst : DecidableEq Î±] [inst_1 : Fintype Î±],
  f.IsCycle â†’ âˆ€ {n : â„•}, (f ^ n).support = f.support â†” Â¬orderOf f âˆ£ n
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || joinM_map_map : âˆ€ {m : Type u â†’ Type u} [inst : Monad m] [inst_1 : LawfulMonad m] {Î± Î² : Type u} (f : Î± â†’ Î²) (a : m (m Î±)),
  joinM (Functor.map f <$> a) = f <$> joinM a
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.ZeroAtFilter.neg : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : AddGroup Î²] [inst_2 : ContinuousNeg Î²]
  {l : Filter Î±} {f : Î± â†’ Î²}, l.ZeroAtFilter f â†’ l.ZeroAtFilter (-f)
Result.success

Testing || Nimber.add_nat : âˆ€ (a b : â„•), Ordinal.toNimber â†‘a + Ordinal.toNimber â†‘b = Ordinal.toNimber â†‘(a ^^^ b)
Result.exception ::
Duper saturated

Testing || Grp.FilteredColimits.forgetâ‚‚Mon_preservesFilteredColimits : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forgetâ‚‚ Grp MonCat)
Result.exception ::
Duper saturated

Testing || Auto.Embedding.Lam.LamBaseSort.eq_of_beq_eq_true : âˆ€ {bâ‚ bâ‚‚ : Embedding.Lam.LamBaseSort}, bâ‚.beq bâ‚‚ = true â†’ bâ‚ = bâ‚‚
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HahnSeries.isWF_support : âˆ€ {Î“ : Type u_1} {R : Type u_3} [inst : PartialOrder Î“] [inst_1 : _root_.Zero R] (x : HahnSeries Î“ R), x.support.IsWF
Result.success

Testing || PrimeSpectrum.localization_away_comap_range : âˆ€ {R : Type u} [inst : CommSemiring R] (S : Type v) [inst_1 : CommSemiring S] [inst_2 : Algebra R S] (r : R)
  [inst_3 : IsLocalization.Away r S], Set.range â‡‘(PrimeSpectrum.comap (algebraMap R S)) = â†‘(PrimeSpectrum.basicOpen r)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!14 !58 !31) = (!0 (!1 !2))) is not type correct

Testing || AddSubgroup.map.proof_2 : âˆ€ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N] (f : G â†’+ N) (H : AddSubgroup G) {a b : N},
  a âˆˆ (AddSubmonoid.map f H.toAddSubmonoid).carrier â†’
    b âˆˆ (AddSubmonoid.map f H.toAddSubmonoid).carrier â†’ a + b âˆˆ (AddSubmonoid.map f H.toAddSubmonoid).carrier
Result.success

Testing || Small.trans_univLE : âˆ€ (Î± : Type w) [hÎ± : Small.{u, w} Î±] [h : UnivLE.{u, v}], Small.{v, w} Î±
Result.exception ::
Duper saturated

Testing || ContinuousMap.addUnitsLift_symm_apply_apply_neg' : âˆ€ {X : Type u_1} {M : Type u_2} [inst : TopologicalSpace X] [inst_1 : AddMonoid M] [inst_2 : TopologicalSpace M]
  [inst_3 : ContinuousAdd M] (f : AddUnits C(X, M)) (x : X), â†‘(-(ContinuousMap.addUnitsLift.symm f) x) = â†‘(-f) x
Result.success

Testing || CategoryTheory.ShortComplex.SnakeInput.id_fâ‚ : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Abelian C]
  (S : CategoryTheory.ShortComplex.SnakeInput C),
  (CategoryTheory.CategoryStruct.id S).fâ‚ = CategoryTheory.CategoryStruct.id S.Lâ‚
Result.success

Testing || TensorProduct.piScalarRight_apply : âˆ€ (R : Type u_1) [inst : CommSemiring R] (S : Type u_2) [inst_1 : CommSemiring S] [inst_2 : Algebra R S] (N : Type u_3)
  [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R N] [inst_5 : _root_.Module S N] [inst_6 : IsScalarTower R S N]
  (Î¹ : Type u_4) [inst_7 : Fintype Î¹] [inst_8 : DecidableEq Î¹] (x : TensorProduct R N (Î¹ â†’ R)),
  (TensorProduct.piScalarRight R S N Î¹) x = (TensorProduct.piScalarRightHom R S N Î¹) x
Result.exception ::
Duper saturated

Testing || RootPairing.reflection_perm_involutive : âˆ€ {Î¹ : Type u_1} {R : Type u_2} {M : Type u_3} {N : Type u_4} [inst : CommRing R] [inst_1 : AddCommGroup M]
  [inst_2 : _root_.Module R M] [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R N] (P : RootPairing Î¹ R M N) (i : Î¹),
  Function.Involutive â‡‘(P.reflection_perm i)
Result.success

Testing || Set.instLawfulMonad : LawfulMonad Set
Result.exception ::
Duper saturated

Testing || decide_True' : âˆ€ (h : Decidable True), decide True = true
Result.success

Testing || LSeries.abscissaOfAbsConv_one : LSeries.abscissaOfAbsConv 1 = 1
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || isLittleO_pow_pow_of_lt_left : âˆ€ {râ‚ râ‚‚ : â„}, 0 â‰¤ râ‚ â†’ râ‚ < râ‚‚ â†’ (fun n => râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.iSup_lt_lift : âˆ€ {Î¹ : Type u} {f : Î¹ â†’ Cardinal.{max u v}} {c : Cardinal.{max u v}},
  Cardinal.lift.{v, u} (Cardinal.mk Î¹) < c.ord.cof â†’ (âˆ€ (i : Î¹), f i < c) â†’ iSup f < c
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || SeparationQuotient.inducing_mk : âˆ€ {X : Type u_1} [inst : TopologicalSpace X], Topology.IsInducing SeparationQuotient.mk
Result.success

Testing || div_two_sub_self : âˆ€ {Î± : Type u_2} [inst : LinearOrderedField Î±] (a : Î±), a / 2 - a = -(a / 2)
Result.success

Testing || aestronglyMeasurable_lineDeriv_uncurry : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : LocallyCompactSpace ğ•œ] {E : Type u_2}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] [inst_4 : MeasurableSpace E]
  [inst_5 : OpensMeasurableSpace E] {F : Type u_3} [inst_6 : NormedAddCommGroup F] [inst_7 : NormedSpace ğ•œ F]
  [inst_8 : CompleteSpace F] {f : E â†’ F} [inst_9 : SecondCountableTopology E],
  Continuous f â†’
    âˆ€ (Î¼ : MeasureTheory.Measure (E Ã— E)), MeasureTheory.AEStronglyMeasurable (fun p => lineDeriv ğ•œ f p.1 p.2) Î¼
Result.success

Testing || Int.Prime.dvd_pow' : âˆ€ {n : â„¤} {k p : â„•}, Nat.Prime p â†’ â†‘p âˆ£ n ^ k â†’ â†‘p âˆ£ n
Result.success

Testing || Filter.blimsup_not_sup : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : CompleteDistribLattice Î±] {f : Filter Î²} {p : Î² â†’ Prop} {u : Î² â†’ Î±},
  (Filter.blimsup u f fun x => Â¬p x) âŠ” Filter.blimsup u f p = Filter.limsup u f
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Coheyting.boundary_inf_le : âˆ€ {Î± : Type u_1} [inst : CoheytingAlgebra Î±] {a b : Î±},
  Coheyting.boundary (a âŠ“ b) â‰¤ Coheyting.boundary a âŠ” Coheyting.boundary b
Result.success

Testing || CategoryTheory.IsFiltered.coeqâ‚ƒ_conditionâ‚ : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {jâ‚ jâ‚‚ : C}
  (f g h : jâ‚ âŸ¶ jâ‚‚),
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeqâ‚ƒHom f g h) =
    CategoryTheory.CategoryStruct.comp g (CategoryTheory.IsFiltered.coeqâ‚ƒHom f g h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.IsFiltered.coeqHom
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || disjoint_compl_right : âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a : Î±}, Disjoint a aá¶œ
Result.success

Testing || Heyting.Regular.coe_sdiff : âˆ€ {Î± : Type u_1} [inst : HeytingAlgebra Î±] (a b : Heyting.Regular Î±), â†‘(a \ b) = â†‘a âŠ“ (â†‘b)á¶œ
Result.success

Testing || CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_isAddCommGroup : âˆ€ {P : TopCat â†’ Prop} (R : Type (max u w)) [inst : Ring R] (X : ModuleCat R) (x : (CompHausLike P)áµ’áµ–),
  (((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj x).isAddCommGroup =
    LocallyConstant.instAddCommGroup
Result.exception ::
Auto.Reif.resolveTy :: Unable to resolve AddCommGroup
  â†‘(((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj xâœ)

Testing || Polynomial.Chebyshev.aeval_U : âˆ€ {R : Type u_1} {R' : Type u_2} [inst : CommRing R] [inst_1 : CommRing R'] [inst_2 : Algebra R R'] (x : R') (n : â„¤),
  (Polynomial.aeval x) (Polynomial.Chebyshev.U R n) = Polynomial.eval x (Polynomial.Chebyshev.U R' n)
Result.success

Testing || lipschitzExtensionConstant_def : âˆ€ (E' : Type u_1) [inst : NormedAddCommGroup E'] [inst_1 : NormedSpace â„ E'] [inst_2 : FiniteDimensional â„ E'],
  lipschitzExtensionConstant E' =
    let A := (Basis.ofVectorSpace â„ E').equivFun.toContinuousLinearEquiv;
    â€–â†‘A.symmâ€–â‚Š * â€–â†‘Aâ€–â‚Š âŠ” 1
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #9, (âˆ€ x1 : #9, ((!21 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || SubMulAction.coe_copy : âˆ€ {R : Type u} {M : Type v} [inst : SMul R M] (p : SubMulAction R M) (s : Set M) (hs : s = â†‘p), â†‘(p.copy s hs) = s
Result.success

Testing || Cardinal.mul_eq_max' : âˆ€ {a b : Cardinal.{u_1}}, Cardinal.aleph0 â‰¤ a * b â†’ a * b = a âŠ” b
Result.exception ::
Duper saturated

Testing || AlgHom.val_comp_codRestrict : âˆ€ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  [inst_3 : Semiring B] [inst_4 : Algebra R B] (f : A â†’â‚[R] B) (S : Subalgebra R B) (hf : âˆ€ (x : A), f x âˆˆ S),
  S.val.comp (f.codRestrict S hf) = f
Result.success

Testing || CStarRing.norm_one : âˆ€ {E : Type u_2} [inst : NormedRing E] [inst_1 : StarRing E] [inst_2 : CStarRing E] [inst_3 : Nontrivial E], â€–1â€– = 1
Result.success

Testing || Cardinal.mk_ne_zero_iff : âˆ€ {Î± : Type u}, Cardinal.mk Î± â‰  0 â†” Nonempty Î±
Result.exception ::
Duper saturated

Testing || Fin.Ioi_zero_eq_map : âˆ€ {n : â„•}, Finset.Ioi 0 = Finset.map (Fin.succEmb n) Finset.univ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Fin.succ`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || exists_mem_frontier_infDist_compl_eq_dist : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {x : E}
  {s : Set E}, x âˆˆ s â†’ s â‰  Set.univ â†’ âˆƒ y âˆˆ frontier s, Metric.infDist x sá¶œ = dist x y
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `PseudoMetricSpace.toUniformSpace`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Filter.Tendsto.max : âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderClosedTopology Î±]
  {f g : Î² â†’ Î±} {b : Filter Î²} {aâ‚ aâ‚‚ : Î±},
  Filter.Tendsto f b (nhds aâ‚) â†’ Filter.Tendsto g b (nhds aâ‚‚) â†’ Filter.Tendsto (fun b => f b âŠ” g b) b (nhds (aâ‚ âŠ” aâ‚‚))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `nhds x`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Pi.forall_rel_cons_ext : âˆ€ {Î¹ : Type u_1} [inst : DecidableEq Î¹] {Î± : Î¹ â†’ Sort u_2} {i : Î¹} {l : List Î¹} {r : â¦ƒi : Î¹â¦„ â†’ Î± i â†’ Î± i â†’ Prop}
  {aâ‚ aâ‚‚ : Î± i} {fâ‚ fâ‚‚ : (j : Î¹) â†’ j âˆˆ l â†’ Î± j},
  r aâ‚ aâ‚‚ â†’
    (âˆ€ (i : Î¹) (hi : i âˆˆ l), r (fâ‚ i hi) (fâ‚‚ i hi)) â†’
      âˆ€ (j : Î¹) (hj : j âˆˆ i :: l), r (List.Pi.cons i l aâ‚ fâ‚ j hj) (List.Pi.cons i l aâ‚‚ fâ‚‚ j hj)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (a : j âˆˆ i ::â‚˜ â†‘l),
  List.Pi.cons i l f b j a = Multiset.Pi.cons (â†‘l) i f b j a, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || WithBot.toDual_lt_toDual_iff : âˆ€ {Î± : Type u_1} [inst : LT Î±] {a b : WithBot Î±}, WithBot.toDual a < WithBot.toDual b â†” b < a
Result.success

Testing || Nat.Partrec.Code.fixed_point : âˆ€ {f : Nat.Partrec.Code â†’ Nat.Partrec.Code}, Computable f â†’ âˆƒ c, (f c).eval = c.eval
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: â„• â†’. â„• is not a `âˆ€`

Testing || IsAddQuantale.add_bot : âˆ€ {Î± : Type u_3} [inst : AddSemigroup Î±] [inst_1 : CompleteLattice Î±] [inst_2 : IsAddQuantale Î±] {x : Î±}, x + âŠ¥ = âŠ¥
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type y âˆˆ x_1 of Î» binder contains bound variables

Testing || CategoryTheory.Equivalence.pi_functor : âˆ€ {I : Type wâ‚€} {C : I â†’ Type uâ‚} [inst : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)] {D : I â†’ Type uâ‚‚}
  [inst_1 : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)] (E : (i : I) â†’ C i â‰Œ D i),
  (CategoryTheory.Equivalence.pi E).functor = CategoryTheory.Functor.pi fun i => (E i).functor
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instâœÂ¹ i`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matroid.Matroidáµ£.coe_inj : âˆ€ {Î± : Type u_1} {Mâ‚ Mâ‚‚ : Matroid.Matroidáµ£ Î±}, Mâ‚.toMatroid = Mâ‚‚.toMatroid â†” Mâ‚ = Mâ‚‚
Result.success

Testing || CategoryTheory.ShortComplex.LeftHomologyData.f'_i_assoc : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {S : CategoryTheory.ShortComplex C} (h : S.LeftHomologyData) {Z : C} (h_1 : S.Xâ‚‚ âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp h.f' (CategoryTheory.CategoryStruct.comp h.i h_1) =
    CategoryTheory.CategoryStruct.comp S.f h_1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.f`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubgroup.isComplement'_comm : âˆ€ {G : Type u_1} [inst : AddGroup G] {H K : AddSubgroup G}, H.IsComplement' K â†” K.IsComplement' H
Result.success

Testing || Equiv.mul_swap_involutive : âˆ€ {Î± : Type u} [inst : DecidableEq Î±] (i j : Î±), Function.Involutive fun x => x * Equiv.swap i j
Result.exception ::
Duper saturated

Testing || AddMonoid.not_isTorsion_iff : âˆ€ (G : Type u_1) [inst : AddMonoid G], Â¬AddMonoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinAddOrder g
Result.success

Testing || Set.mem_iInter_of_mem : âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {s : Î¹ â†’ Set Î±} {a : Î±}, (âˆ€ (i : Î¹), a âˆˆ s i) â†’ a âˆˆ â‹‚ i, s i
Result.success

Testing || FirstOrder.Language.LHom.id_onTerm : âˆ€ {L : FirstOrder.Language} {Î± : Type u'}, (FirstOrder.Language.LHom.id L).onTerm = id
Result.exception ::
Duper saturated

Testing || Mod_.hom_ext : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {A : Mon_ C}
  {M N : Mod_ A} (fâ‚ fâ‚‚ : M âŸ¶ N), fâ‚.hom = fâ‚‚.hom â†’ fâ‚ = fâ‚‚
Result.success

Testing || Matrix.permanent_zero : âˆ€ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type u_2} [inst_2 : CommSemiring R]
  [inst_3 : Nonempty n], Matrix.permanent 0 = 0
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `âˆ€`

Testing || Ideal.radical_eq_iff : âˆ€ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, I.radical = I â†” I.IsRadical
Result.success

Testing || NonemptyInterval.coe_pure : âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] (a : Î±), â†‘(NonemptyInterval.pure a) = {a}
Result.exception ::
Duper saturated

Testing || exists_Ioo_extr_on_Icc : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : ConditionallyCompleteLinearOrder X] [inst_1 : DenselyOrdered X]
  [inst_2 : TopologicalSpace X] [inst_3 : OrderTopology X] [inst_4 : LinearOrder Y] [inst_5 : TopologicalSpace Y]
  [inst_6 : OrderTopology Y] {f : X â†’ Y} {a b : X},
  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c âˆˆ Set.Ioo a b, IsExtrOn f (Set.Icc a b) c
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 (Î»x0 : #0, ((!9 (!10 !4 !5) x0) âˆ§ (!11 !7 (!8 !4 !5) x0)))) = (âˆƒ x0 : #0, ((!9 (!10 !4 !5) x0) âˆ§ (!11 !7 (!8 !4 !5) x0)))) is not type correct

Testing || PrimeSpectrum.comap_basicOpen : âˆ€ {R : Type u} {S : Type v} [inst : CommSemiring R] [inst_1 : CommSemiring S] (f : R â†’+* S) (x : R),
  (TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) (PrimeSpectrum.basicOpen x) = PrimeSpectrum.basicOpen (f x)
Result.success

Testing || CategoryTheory.HasExactLimitsOfShape.of_codomain_equivalence : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : Type u_1) [inst_1 : CategoryTheory.Category.{u_3, u_1} J]
  {D : Type u_2} [inst_2 : CategoryTheory.Category.{u_4, u_2} D] (e : C â‰Œ D)
  [inst_3 : CategoryTheory.Limits.HasLimitsOfShape J C] [inst_4 : CategoryTheory.HasExactLimitsOfShape J C],
  CategoryTheory.HasExactLimitsOfShape J D
Result.exception ::
Duper saturated

Testing || IsCyclotomicExtension.Rat.absdiscr_prime : âˆ€ (p : â„•+) (K : Type u) [inst : Field K] [hp : Fact (Nat.Prime â†‘p)] [inst_1 : CharZero K]
  [inst_2 : IsCyclotomicExtension {p} â„š K], NumberField.discr K = (-1) ^ ((â†‘p - 1) / 2) * â†‘â†‘p ^ (â†‘p - 2)
Result.exception ::
Duper saturated

Testing || span_gramSchmidt_Iio : âˆ€ (ğ•œ : Type u_1) {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]
  {Î¹ : Type u_3} [inst_3 : LinearOrder Î¹] [inst_4 : LocallyFiniteOrderBot Î¹] [inst_5 : WellFoundedLT Î¹] (f : Î¹ â†’ E)
  (c : Î¹), Submodule.span ğ•œ (gramSchmidt ğ•œ f '' Set.Iio c) = Submodule.span ğ•œ (f '' Set.Iio c)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.Iic x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Equiv.continuous_symm_iff : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (e : X â‰ƒ Y),
  Continuous â‡‘e.symm â†” IsOpenMap â‡‘e
Result.exception ::
Duper saturated

Testing || SimpleGraph.instInhabited_default : âˆ€ (V : Type u), default = âŠ¥
Result.success

Testing || Nat.exists_not_and_succ_of_not_zero_of_exists : âˆ€ {p : â„• â†’ Prop}, Â¬p 0 â†’ (âˆƒ n, p n) â†’ âˆƒ n, Â¬p n âˆ§ p (n + 1)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ConvexOn.le_left_of_right_le' : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]
  [inst_2 : LinearOrderedCancelAddCommMonoid Î²] [inst_3 : SMul ğ•œ E] [inst_4 : _root_.Module ğ•œ Î²]
  [inst_5 : OrderedSMul ğ•œ Î²] {s : Set E} {f : E â†’ Î²},
  ConvexOn ğ•œ s f â†’
    âˆ€ {x y : E},
      x âˆˆ s â†’ y âˆˆ s â†’ âˆ€ {a b : ğ•œ}, 0 < a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ f y â‰¤ f (a â€¢ x + b â€¢ y) â†’ f (a â€¢ x + b â€¢ y) â‰¤ f x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLT`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NormedAddGroupHom.Equalizer.Î¹_comp_lift : âˆ€ {V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]
  [inst_2 : SeminormedAddCommGroup Vâ‚] {f g : NormedAddGroupHom V W} (Ï† : NormedAddGroupHom Vâ‚ V)
  (h : f.comp Ï† = g.comp Ï†), (NormedAddGroupHom.Equalizer.Î¹ f g).comp (NormedAddGroupHom.Equalizer.lift Ï† h) = Ï†
Result.success

Testing || CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_functor : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MultispanIndex C)
  [inst_1 : CategoryTheory.Limits.HasCoproduct I.left] [inst_2 : CategoryTheory.Limits.HasCoproduct I.right],
  I.multicoforkEquivSigmaCofork.functor = I.toSigmaCoforkFunctor
Result.success

Testing || CategoryTheory.Limits.instEpiFactorThruImageOfHasLimitWalkingParallelPairParallelPair : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y)
  [inst_1 : CategoryTheory.Limits.HasImage f]
  [inst_2 :
    âˆ€ {Z : C} (g h : CategoryTheory.Limits.image f âŸ¶ Z),
      CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair g h)],
  CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)
Result.exception ::
Duper saturated

Testing || Submonoid.unop_closure : âˆ€ {M : Type u_2} [inst : MulOneClass M] (s : Set Máµáµ’áµ–),
  (Submonoid.closure s).unop = Submonoid.closure (MulOpposite.op â»Â¹' s)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Pi.ringHom_apply : âˆ€ {I : Type u} {f : I â†’ Type v} {Î³ : Type w} [inst : (i : I) â†’ NonAssocSemiring (f i)] [inst_1 : NonAssocSemiring Î³]
  (g : (i : I) â†’ Î³ â†’+* f i) (x : Î³) (b : I), (Pi.ringHom g) x b = (g b) x
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || ProbabilityTheory.Kernel.indepSet_zero_right : âˆ€ {Î± : Type u_1} {Î© : Type u_2} {_mÎ± : MeasurableSpace Î±} {_mÎ© : MeasurableSpace Î©} {Îº : ProbabilityTheory.Kernel Î± Î©}
  {s t : Set Î©}, ProbabilityTheory.Kernel.IndepSet s t Îº 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasurableSpace.generateFrom
  (cifvar_8 x_0)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || InnerProductSpace.Core.sqrt_normSq_eq_norm : âˆ€ {ğ•œ : Type u_1} {F : Type u_3} [inst : RCLike ğ•œ] [inst_1 : AddCommGroup F] [inst_2 : _root_.Module ğ•œ F]
  [c : PreInnerProductSpace.Core ğ•œ F] (x : F), âˆš(InnerProductSpace.Core.normSq x) = â€–xâ€–
Result.success

Testing || Cardinal.natCast_le_toENat_iff : âˆ€ {n : â„•} {c : Cardinal.{u_3}}, â†‘n â‰¤ Cardinal.toENat c â†” â†‘n â‰¤ c
Result.exception ::
Duper saturated

Testing || AddSubsemigroup.mem_comap : âˆ€ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {S : AddSubsemigroup N} {f : M â†’â‚™+ N} {x : M},
  x âˆˆ AddSubsemigroup.comap f S â†” f x âˆˆ S
Result.success

Testing || Equiv.prodAssoc_symm_apply : âˆ€ (Î± : Type u_9) (Î² : Type u_10) (Î³ : Type u_11) (p : Î± Ã— Î² Ã— Î³), (Equiv.prodAssoc Î± Î² Î³).symm p = ((p.1, p.2.1), p.2.2)
Result.success

Testing || Prop.exists_iff : âˆ€ {p : Prop â†’ Prop}, (âˆƒ h, p h) â†” p False âˆ¨ p True
Result.success

Testing || AntitoneOn.map_bddAbove : âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²} {s t : Set Î±},
  AntitoneOn f t â†’ s âŠ† t â†’ (upperBounds s âˆ© t).Nonempty â†’ BddBelow (f '' s)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Î± â†’
  Prop, type of âˆ€ bound variable is not of sort `Prop`, and depends on bound variables

Testing || add_sSup_distrib : âˆ€ {Î± : Type u_1} {x : Î±} {s : Set Î±} [inst : AddSemigroup Î±] [inst_1 : CompleteLattice Î±] [inst_2 : IsAddQuantale Î±],
  x + sSup s = â¨† y âˆˆ s, x + y
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type y âˆˆ s of Î» binder contains bound variables

Testing || AddChar.sum_apply_eq_ite : âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : Fintype Î±] [inst_2 : DecidableEq Î±] (a : Î±),
  âˆ‘ Ïˆ : AddChar Î± â„‚, Ïˆ a = if a = 0 then â†‘(Fintype.card Î±) else 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finite.of_fintype cifvar_28`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DualNumber.exp_smul_eps : âˆ€ (ğ•œ : Type u_1) {R : Type u_2} [inst : Field ğ•œ] [inst_1 : CharZero ğ•œ] [inst_2 : CommRing R] [inst_3 : Algebra ğ•œ R]
  [inst_4 : UniformSpace R] [inst_5 : TopologicalRing R] [inst_6 : T2Space R] (r : R),
  NormedSpace.exp ğ•œ (r â€¢ DualNumber.eps) = 1 + r â€¢ DualNumber.eps
Result.exception ::
Duper saturated

Testing || QuaternionAlgebra.Basis.liftHom_apply : âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] {câ‚ câ‚‚ : R}
  (q : QuaternionAlgebra.Basis A câ‚ câ‚‚) (a : QuaternionAlgebra R câ‚ câ‚‚), q.liftHom a = q.lift a
Result.success

Testing || EReal.inductionâ‚‚ : âˆ€ {P : EReal â†’ EReal â†’ Prop},
  P âŠ¤ âŠ¤ â†’
    (âˆ€ (x : â„), 0 < x â†’ P âŠ¤ â†‘x) â†’
      P âŠ¤ 0 â†’
        (âˆ€ x < 0, P âŠ¤ â†‘x) â†’
          P âŠ¤ âŠ¥ â†’
            (âˆ€ (x : â„), 0 < x â†’ P â†‘x âŠ¤) â†’
              (âˆ€ (x : â„), 0 < x â†’ P â†‘x âŠ¥) â†’
                P 0 âŠ¤ â†’
                  (âˆ€ (x y : â„), P â†‘x â†‘y) â†’
                    P 0 âŠ¥ â†’
                      (âˆ€ x < 0, P â†‘x âŠ¤) â†’
                        (âˆ€ x < 0, P â†‘x âŠ¥) â†’
                          P âŠ¥ âŠ¤ â†’
                            (âˆ€ (x : â„), 0 < x â†’ P âŠ¥ â†‘x) â†’ P âŠ¥ 0 â†’ (âˆ€ x < 0, P âŠ¥ â†‘x) â†’ P âŠ¥ âŠ¥ â†’ âˆ€ (x y : EReal), P x y
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || intervalIntegral.deriv_integral_right : âˆ€ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {f : â„ â†’ E}
  {a b : â„},
  IntervalIntegrable f MeasureTheory.volume a b â†’
    StronglyMeasurableAtFilter f (nhds b) MeasureTheory.volume â†’
      ContinuousAt f b â†’ deriv (fun u => âˆ« (x : â„) in a..u, f x) b = f b
Result.success

Testing || Finset.compls_subset_compls : âˆ€ {Î± : Type u_2} [inst : BooleanAlgebra Î±] {sâ‚ sâ‚‚ : Finset Î±}, sâ‚.compls âŠ† sâ‚‚.compls â†” sâ‚ âŠ† sâ‚‚
Result.success

Testing || Sbtw.oangle_eq_right : âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (Module.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]
  {pâ‚ pâ‚‚ pâ‚ƒ pâ‚ƒ' : P}, Sbtw â„ pâ‚‚ pâ‚ƒ pâ‚ƒ' â†’ EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ'
Result.success

Testing || CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_i : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C]
  (S : CategoryTheory.ShortComplex C),
  (CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian S).i = CategoryTheory.Limits.kernel.Î¹ S.g
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.g`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || UV.disjoint_of_mem_compression_of_not_mem : âˆ€ {Î± : Type u_1} [inst : GeneralizedBooleanAlgebra Î±] [inst_1 : DecidableRel Disjoint]
  [inst_2 : DecidableRel fun x1 x2 => x1 â‰¤ x2] {s : Finset Î±} {u v a : Î±} [inst_3 : DecidableEq Î±],
  a âˆˆ UV.compression u v s â†’ a âˆ‰ s â†’ Disjoint v a
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.StructuredArrow.post_obj : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {B : Type uâ‚„} [inst_2 : CategoryTheory.Category.{vâ‚„, uâ‚„} B] (S : C) (F : CategoryTheory.Functor B C)
  (G : CategoryTheory.Functor C D) (X : CategoryTheory.StructuredArrow S F),
  (CategoryTheory.StructuredArrow.post S F G).obj X = CategoryTheory.StructuredArrow.mk (G.map X.hom)
Result.success

Testing || Equiv.Perm.VectorsProdEqOne.rotate_zero : âˆ€ {G : Type u_2} [inst : Group G] {n : â„•} (v : â†‘(Equiv.Perm.vectorsProdEqOne G n)),
  Equiv.Perm.VectorsProdEqOne.rotate v 0 = v
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!2 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || TrivSqZeroExt.instTopologicalRingOfTopologicalAddGroupOfContinuousSMulMulOpposite : âˆ€ {R : Type u_3} {M : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace M] [inst_2 : Ring R]
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Ráµáµ’áµ– M] [inst_6 : TopologicalRing R]
  [inst_7 : TopologicalAddGroup M] [inst_8 : ContinuousSMul R M] [inst_9 : ContinuousSMul Ráµáµ’áµ– M],
  TopologicalRing (TrivSqZeroExt R M)
Result.exception ::
failed to synthesize
  SMul (TrivSqZeroExt R M) M
(deterministic) timeout at `typeclass`, maximum number of heartbeats (20000) has been reached
Use `set_option synthInstance.maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
Additional diagnostic information may be available using the `set_option diagnostics true` command.

Testing || LipschitzWith.dist_right : âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (x : Î±), LipschitzWith 1 (dist x)
Result.success

Testing || Set.Finite.powerset : âˆ€ {Î± : Type u} {s : Set Î±}, s.Finite â†’ (ğ’« s).Finite
Result.success

Testing || contDiff_iff_forall_nat_le : âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}
  {n : â„•âˆ}, ContDiff ğ•œ (â†‘n) f â†” âˆ€ (m : â„•), â†‘m â‰¤ n â†’ ContDiff ğ•œ (â†‘m) f
Result.success

Testing || CategoryTheory.Limits.compReflectsLimitsOfShape : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {J : Type w} [inst_2 : CategoryTheory.Category.{w', w} J] {E : Type uâ‚ƒ} [â„° : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E]
  (F : CategoryTheory.Functor C D) (G : CategoryTheory.Functor D E)
  [inst_3 : CategoryTheory.Limits.ReflectsLimitsOfShape J F] [inst_4 : CategoryTheory.Limits.ReflectsLimitsOfShape J G],
  CategoryTheory.Limits.ReflectsLimitsOfShape J (F.comp G)
Result.success

Testing || SimpleGraph.IsNClique.insert : âˆ€ {Î± : Type u_1} {G : SimpleGraph Î±} {n : â„•} {s : Finset Î±} {a : Î±} [inst : DecidableEq Î±],
  G.IsNClique n s â†’ (âˆ€ b âˆˆ s, G.Adj a b) â†’ G.IsNClique (n + 1) (insert a s)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 (!0 !1 !2) !3) = (!0 !1 !2 !3)) is not type correct

Testing || DilationEquiv.ratio_zpow : âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] (e : X â‰ƒáµˆ X) (n : â„¤), Dilation.ratio (e ^ n) = Dilation.ratio e ^ n
Result.exception ::
Duper saturated

Testing || instIsSuccArchimedeanMultiplicative : âˆ€ {X : Type u_1} [inst : Preorder X] [inst_1 : SuccOrder X] [h : IsSuccArchimedean X],
  IsSuccArchimedean (Multiplicative X)
Result.success

Testing || Stream'.WSeq.liftRel_append : âˆ€ {Î± : Type u} {Î² : Type v} (R : Î± â†’ Î² â†’ Prop) {s1 s2 : Stream'.WSeq Î±} {t1 t2 : Stream'.WSeq Î²},
  Stream'.WSeq.LiftRel R s1 t1 â†’ Stream'.WSeq.LiftRel R s2 t2 â†’ Stream'.WSeq.LiftRel R (s1.append s2) (t1.append t2)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TopologicalSpace.isTopologicalBasis_of_subbasis_of_inter : âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {r : Set (Set Î±)},
  t = TopologicalSpace.generateFrom r â†’
    (âˆ€ â¦ƒs : Set Î±â¦„, s âˆˆ r â†’ âˆ€ â¦ƒt : Set Î±â¦„, t âˆˆ r â†’ s âˆ© t âˆˆ r) â†’ TopologicalSpace.IsTopologicalBasis (insert Set.univ r)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `TopologicalSpace.generateFrom x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LieSubmodule.le_normalizer : âˆ€ {R : Type u_1} {L : Type u_2} {M : Type u_3} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : LieRingModule L M] [inst_6 : LieModule R L M]
  (N : LieSubmodule R L M), N â‰¤ N.normalizer
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.exists_of_mem_keys : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {a : Î±} {l : List (Sigma Î²)}, a âˆˆ l.keys â†’ âˆƒ b, âŸ¨a, bâŸ© âˆˆ l
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq : âˆ€ {A : Type u_1} {A' : Type u_2} {B : Type u_3} {B' : Type u_4} [inst : CategoryTheory.Category.{u_6, u_1} A]
  [inst_1 : CategoryTheory.Category.{u_5, u_2} A'] [inst_2 : CategoryTheory.Category.{u_8, u_3} B]
  [inst_3 : CategoryTheory.Category.{u_7, u_4} B'] {eA : A â‰Œ A'} {eB : B â‰Œ B'} {e' : A' â‰Œ B'}
  {F : CategoryTheory.Functor A B'} {hF : eA.functor.comp e'.functor â‰… F} {G : CategoryTheory.Functor B A}
  {hG : eB.functor.comp e'.inverse â‰… G.comp eA.functor} {Îµ : eA.functor â‰… F.comp e'.inverse},
  AlgebraicTopology.DoldKan.Compatibility.Ï… hF = Îµ â†’
    (AlgebraicTopology.DoldKan.Compatibility.equivalence hF hG).unitIso =
      AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso hG Îµ
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AffineEquiv.pointReflection_apply : âˆ€ (k : Type u_1) {Pâ‚ : Type u_2} {Vâ‚ : Type u_6} [inst : Ring k] [inst_1 : AddCommGroup Vâ‚]
  [inst_2 : _root_.Module k Vâ‚] [inst_3 : AddTorsor Vâ‚ Pâ‚] (x y : Pâ‚),
  (AffineEquiv.pointReflection k x) y = (x -áµ¥ y) +áµ¥ x
Result.success

Testing || RCLike.nonpos_iff_exists_ofReal : âˆ€ {K : Type u_1} [inst : RCLike K] {z : K}, z â‰¤ 0 â†” âˆƒ x â‰¤ 0, â†‘x = z
Result.success

Testing || generateFrom_iUnion : âˆ€ {Î± : Type u} {Î¹ : Sort v} {f : Î¹ â†’ Set (Set Î±)},
  TopologicalSpace.generateFrom (â‹ƒ i, f i) = â¨… i, TopologicalSpace.generateFrom (f i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `TopologicalSpace.generateFrom
  (cifvar_4 i)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Adjunction.counit_epi_of_R_faithful : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {L : CategoryTheory.Functor C D} {R : CategoryTheory.Functor D C} (h : L âŠ£ R) [inst_2 : R.Faithful] (X : D),
  CategoryTheory.Epi (h.counit.app X)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_9 x_2).map`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContinuousSup.measurableSupâ‚‚ : âˆ€ {Î³ : Type u_3} [inst : TopologicalSpace Î³] {mÎ³ : MeasurableSpace Î³} [inst_1 : BorelSpace Î³]
  [inst_2 : SecondCountableTopology Î³] [inst_3 : Max Î³] [inst : ContinuousSup Î³], MeasurableSupâ‚‚ Î³
Result.exception ::
Duper saturated

Testing || BoxIntegral.TaggedPrepartition.unionComplToSubordinate_boxes : âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] {I : BoxIntegral.Box Î¹} (Ï€â‚ : BoxIntegral.TaggedPrepartition I)
  (Ï€â‚‚ : BoxIntegral.Prepartition I) (hU : Ï€â‚‚.iUnion = â†‘I \ Ï€â‚.iUnion) (r : (Î¹ â†’ â„) â†’ â†‘(Set.Ioi 0)),
  (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).boxes = Ï€â‚.boxes âˆª (Ï€â‚‚.toSubordinate r).boxes
Result.success

Testing || CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom'_assoc : âˆ€ {C : Type u} [ğ’ : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (X : C) {Y Z : C}
  (f : Y âŸ¶ Z) [inst_1 : CategoryTheory.IsIso f] {Z_1 : C} (h : CategoryTheory.MonoidalCategory.tensorObj X Z âŸ¶ Z_1),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft X (CategoryTheory.inv f))
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft X f) h) =
    h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerLeft
  x_0 (cifvar_7 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SpectrumRestricts.nnreal_iff_spectralRadius_le : âˆ€ {A : Type u_3} [inst : Ring A] [inst_1 : Algebra â„ A] {a : A} {t : NNReal},
  spectralRadius â„ a â‰¤ â†‘t â†’
    (SpectrumRestricts a â‡‘ContinuousMap.realToNNReal â†” spectralRadius â„ ((algebraMap â„ A) â†‘t - a) â‰¤ â†‘t)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i âˆˆ spectrum â„ a of Î» binder contains bound variables

Testing || Real.sin_nat_mul_pi_sub : âˆ€ (x : â„) (n : â„•), Real.sin (â†‘n * Real.pi - x) = -((-1) ^ n * Real.sin x)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #0, (âˆ€ x1 : #0, ((!33 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || IsNonarchimedean.multiset_image_add : âˆ€ {F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : AddCommGroup Î±] [inst_1 : FunLike F Î± â„]
  [inst_2 : AddGroupSeminormClass F Î± â„] [inst_3 : Nonempty Î²] {f : F},
  IsNonarchimedean â‡‘f â†’ âˆ€ (g : Î² â†’ Î±) (s : Multiset Î²), âˆƒ b, (s â‰  0 â†’ b âˆˆ s) âˆ§ f (Multiset.map g s).sum â‰¤ f (g b)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `SeminormedAddCommGroup.toNorm`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DirectSum.of_eq_of_gradedMonoid_eq : âˆ€ {Î¹ : Type u_1} [inst : DecidableEq Î¹] {A : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)] {i j : Î¹} {a : A i}
  {b : A j}, GradedMonoid.mk i a = GradedMonoid.mk j b â†’ (DirectSum.of A i) a = (DirectSum.of A j) b
Result.success

Testing || IsMinOn.of_isLocalMinOn_of_convexOn : âˆ€ {E : Type u_1} {Î² : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : _root_.Module â„ E]
  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] [inst_5 : OrderedAddCommGroup Î²]
  [inst_6 : _root_.Module â„ Î²] [inst_7 : OrderedSMul â„ Î²] {s : Set E} {f : E â†’ Î²} {a : E},
  a âˆˆ s â†’ IsLocalMinOn f s a â†’ ConvexOn â„ s f â†’ IsMinOn f s a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!21 !22 !23) = !0) is not type correct

Testing || List.mapâ‚‚Right'_nil_right : âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Option Î± â†’ Î² â†’ Î³) (as : List Î±), List.mapâ‚‚Right' f as [] = ([], as)
Result.success

Testing || Set.mulIndicator_one_preimage : âˆ€ {Î± : Type u_1} {M : Type u_3} [inst : _root_.One M] {t : Set Î±} (s : Set M), t.mulIndicator 1 â»Â¹' s âˆˆ {Set.univ, âˆ…}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || strictAntiOn_of_add_one_lt : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : PartialOrder Î±] [inst_1 : Preorder Î²] [inst_2 : Add Î±] [inst_3 : _root_.One Î±]
  [inst_4 : SuccAddOrder Î±] [inst_5 : IsSuccArchimedean Î±] {s : Set Î±} {f : Î± â†’ Î²},
  s.OrdConnected â†’ (âˆ€ (a : Î±), Â¬IsMax a â†’ a âˆˆ s â†’ a + 1 âˆˆ s â†’ f (a + 1) < f a) â†’ StrictAntiOn f s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!14 !15 !16) = !0) is not type correct

Testing || orderOf_eq_prime : âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {p : â„•} [hp : Fact (Nat.Prime p)], x ^ p = 1 â†’ x â‰  1 â†’ orderOf x = p
Result.success

Testing || Polynomial.leadingCoeff_det_X_one_add_C : âˆ€ {n : Type u_1} {Î± : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Î±] (A : Matrix n n Î±),
  (Polynomial.X â€¢ 1 + A.map â‡‘Polynomial.C).det.leadingCoeff = 1
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (Â¬ ((!0 (!1 !2 (!3 (!4 !5 !6) (!7 !8 (!9 !10))))) = !11)) is not type correct

Testing || Quaternion.normSq_coe : âˆ€ {R : Type u_3} [inst : CommRing R] (x : R), Quaternion.normSq â†‘x = x ^ 2
Result.success

Testing || Ideal.comap_comap : âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {T : Type u_3} [inst_2 : Semiring T] {I : Ideal T}
  (f : R â†’+* S) (g : S â†’+* T), Ideal.comap f (Ideal.comap g I) = Ideal.comap (g.comp f) I
Result.success

Testing || MulHom.srange_top_of_surjective : âˆ€ {M : Type u_1} [inst : Mul M] {N : Type u_5} [inst_1 : Mul N] (f : M â†’â‚™* N), Function.Surjective â‡‘f â†’ f.srange = âŠ¤
Result.success

Testing || ContinuousLinearMap.proj_apply : âˆ€ {R : Type u_1} [inst : Semiring R] {Î¹ : Type u_4} {Ï† : Î¹ â†’ Type u_5} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Ï† i)]
  [inst_2 : (i : Î¹) â†’ AddCommMonoid (Ï† i)] [inst_3 : (i : Î¹) â†’ _root_.Module R (Ï† i)] (i : Î¹) (b : (i : Î¹) â†’ Ï† i),
  (ContinuousLinearMap.proj i) b = b i
Result.success

Testing || Order.Ioo_succ_right : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : SuccOrder Î±] [inst_2 : NoMaxOrder Î±] (a b : Î±),
  Set.Ioo a (Order.succ b) = Set.Ioc a b
Result.success

Testing || Sym2.GameAdd.fix_eq : âˆ€ {Î± : Type u_1} {rÎ± : Î± â†’ Î± â†’ Prop} {C : Î± â†’ Î± â†’ Sort u_3} (hr : WellFounded rÎ±)
  (IH : (aâ‚ bâ‚ : Î±) â†’ ((aâ‚‚ bâ‚‚ : Î±) â†’ Sym2.GameAdd rÎ± s(aâ‚‚, bâ‚‚) s(aâ‚, bâ‚) â†’ C aâ‚‚ bâ‚‚) â†’ C aâ‚ bâ‚) (a b : Î±),
  Sym2.GameAdd.fix hr IH a b = IH a b fun a' b' x => Sym2.GameAdd.fix hr IH a' b'
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Sym2.GameAdd rÎ± (Quot.mk (Sym2.Rel Î±) (a', b'))
  (Quot.mk (Sym2.Rel Î±) (a, b)) of Î» binder contains bound variables

Testing || UniqueSums.of_same : âˆ€ {G : Type u_1} [inst : AddSemigroup G] [inst_1 : IsCancelAdd G],
  (âˆ€ {A : Finset G}, A.Nonempty â†’ âˆƒ a1 âˆˆ A, âˆƒ a2 âˆˆ A, UniqueAdd A A a1 a2) â†’ UniqueSums G
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.add`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FreeAbelianGroup.add_bind : âˆ€ {Î± Î² : Type u} (f : Î± â†’ FreeAbelianGroup Î²) (x y : FreeAbelianGroup Î±), x + y >>= f = (x >>= f) + (y >>= f)
Result.success

Testing || CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_snd_assoc : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ChosenFiniteProducts C] (X : C)
  {Z : C} (h : X âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (ğŸ™_ C) X) h) =
    h
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ENNReal.log_strictMono : StrictMono ENNReal.log
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `BoundedOrder.toOrderBot`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || OrderMonoidHom.copy_eq : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : MulOneClass Î±]
  [inst_3 : MulOneClass Î²] (f : Î± â†’*o Î²) (f' : Î± â†’ Î²) (h : f' = â‡‘f), f.copy f' h = f
Result.exception ::
Duper saturated

Testing || LowerSemicontinuous.add' : âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {Î³ : Type u_4} [inst_1 : LinearOrderedAddCommMonoid Î³]
  [inst_2 : TopologicalSpace Î³] [inst_3 : OrderTopology Î³] {f g : Î± â†’ Î³},
  LowerSemicontinuous f â†’
    LowerSemicontinuous g â†’
      (âˆ€ (x : Î±), ContinuousAt (fun p => p.1 + p.2) (f x, g x)) â†’ LowerSemicontinuous fun z => f z + g z
Result.exception ::
Duper saturated

Testing || Vector.continuous_insertNth : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {n : â„•} {i : Fin (n + 1)}
  {f : Î² â†’ Î±} {g : Î² â†’ List.Vector Î± n},
  Continuous f â†’ Continuous g â†’ Continuous fun b => List.Vector.insertIdx (f b) i (g b)
Result.success

Testing || RatFunc.algebraMap_apply_div : âˆ€ {F : Type u} [inst : Field F] (p q : Polynomial F),
  (algebraMap (RatFunc F) (LaurentSeries F))
      ((algebraMap (Polynomial F) (RatFunc F)) p / (algebraMap (Polynomial F) (RatFunc F)) q) =
    (algebraMap (Polynomial F) (LaurentSeries F)) p / (algebraMap (Polynomial F) (LaurentSeries F)) q
Result.exception ::
Duper saturated

Testing || CategoryTheory.braiding_inv_apply : âˆ€ {X Y : Type u} {x : X} {y : Y}, (Î²_ X Y).inv (y, x) = (x, y)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MonoidalCategory.tensorObj Y X âŸ¶
  CategoryTheory.MonoidalCategory.tensorObj X Y is not a `âˆ€`

Testing || instOrderedSubPrimeMultiset : OrderedSub PrimeMultiset
Result.exception ::
Duper saturated

Testing || IntermediateField.map_le_iff_le_comap : âˆ€ {K : Type u_1} {L : Type u_2} {L' : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : Field L']
  [inst_3 : Algebra K L] [inst_4 : Algebra K L'] {f : L â†’â‚[K] L'} {s : IntermediateField K L}
  {t : IntermediateField K L'}, IntermediateField.map f s â‰¤ t â†” s â‰¤ IntermediateField.comap f t
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Functor.mapTriangle_map_homâ‚ : âˆ€ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_5, u_2} D] [inst_2 : CategoryTheory.HasShift C â„¤]
  [inst_3 : CategoryTheory.HasShift D â„¤] (F : CategoryTheory.Functor C D) [inst_4 : F.CommShift â„¤]
  {X Y : CategoryTheory.Pretriangulated.Triangle C} (f : X âŸ¶ Y), (F.mapTriangle.map f).homâ‚ = F.map f.homâ‚
Result.success

Testing || ZNum.cmp_to_int : âˆ€ (m n : ZNum), Ordering.casesOn (m.cmp n) (â†‘m < â†‘n) (m = n) (â†‘n < â†‘m)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubtractionMonoid`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || isLocalHomeomorphOn_iff_isOpenEmbedding_restrict : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (s : Set X) {f : X â†’ Y},
  IsLocalHomeomorphOn f s â†” âˆ€ x âˆˆ s, âˆƒ U âˆˆ nhds x, Topology.IsOpenEmbedding (U.restrict f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceSubtype`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Commute.invOf_left : âˆ€ {Î± : Type u} [inst : Monoid Î±] {a b : Î±} [inst_1 : Invertible b], Commute b a â†’ Commute (â…Ÿb) a
Result.success

Testing || Rat.canLift : CanLift â„š â„¤ Int.cast fun q => q.den = 1
Result.exception ::
Duper saturated

Testing || Subring.mem_pointwise_smul_iff_inv_smul_mem : âˆ€ {M : Type u_1} {R : Type u_2} [inst : Group M] [inst_1 : Ring R] [inst_2 : MulSemiringAction M R] {a : M}
  {S : Subring R} {x : R}, x âˆˆ a â€¢ S â†” aâ»Â¹ â€¢ x âˆˆ S
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MulAction.toSMul`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubgroup.card_dvd_of_surjective : âˆ€ {G : Type u_1} {G' : Type u_2} [inst : AddGroup G] [inst_1 : AddGroup G'] (f : G â†’+ G'),
  Function.Surjective â‡‘f â†’ Nat.card G' âˆ£ Nat.card G
Result.exception ::
Duper saturated

Testing || Subalgebra.topologicalClosure_minimal : âˆ€ {R : Type u_1} [inst : CommSemiring R] {A : Type u} [inst_1 : TopologicalSpace A] [inst_2 : Semiring A]
  [inst_3 : Algebra R A] [inst_4 : TopologicalSemiring A] (s : Subalgebra R A) {t : Subalgebra R A},
  s â‰¤ t â†’ IsClosed â†‘t â†’ s.topologicalClosure â‰¤ t
Result.success

Testing || Valuation.isEquiv_iff_val_eq_one : âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_4} {Î“'â‚€ : Type u_5} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]
  [inst_2 : LinearOrderedCommGroupWithZero Î“'â‚€] {v : Valuation K Î“â‚€} {v' : Valuation K Î“'â‚€},
  v.IsEquiv v' â†” âˆ€ {x : K}, v x = 1 â†” v' x = 1
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.ofJ0_câ‚„ : âˆ€ (R : Type u_1) [inst : CommRing R], (WeierstrassCurve.ofJ0 R).câ‚„ = 0
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Limits.id_preservesColimitsOfSize : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C],
  CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.Functor.id C)
Result.exception ::
Duper saturated

Testing || Finsupp.sumFinsuppAddEquivProdFinsupp_apply : âˆ€ {M : Type u_5} [inst : AddMonoid M] {Î± : Type u_13} {Î² : Type u_14} (f : Î± âŠ• Î² â†’â‚€ M),
  Finsupp.sumFinsuppAddEquivProdFinsupp f = (Finsupp.comapDomain Sum.inl f â‹¯, Finsupp.comapDomain Sum.inr f â‹¯)
Result.success

Testing || WithBot.unbot_coe : âˆ€ {Î± : Type u_1} (x : Î±) (h : optParam (â†‘x â‰  âŠ¥) â‹¯), (â†‘x).unbot h = x
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (a : â†‘x â‰  âŠ¥),
  x = (â†‘x).unbot a, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || Normal.minpoly_eq_iff_mem_orbit : âˆ€ {F : Type u_1} [inst : Field F] (E : Type u_6) [inst_1 : Field E] [inst_2 : Algebra F E] [h : Normal F E] {x y : E},
  minpoly F x = minpoly F y â†” x âˆˆ MulAction.orbit (E â‰ƒâ‚[F] E) y
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!4 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || HahnSeries.SummableFamily.ext : âˆ€ {Î“ : Type u_1} {R : Type u_3} {Î± : Type u_5} [inst : PartialOrder Î“] [inst_1 : AddCommMonoid R]
  {s t : HahnSeries.SummableFamily Î“ R Î±}, (âˆ€ (a : Î±), s a = t a) â†’ s = t
Result.success

Testing || Bool.cond_pos : âˆ€ {Î± : Type u_1} {b : Bool} {a a' : Î±}, b = true â†’ (bif b then a else a') = a
Result.success

Testing || AddUnits.neg_add_eq_iff_eq_add : âˆ€ {Î± : Type u} [inst : AddMonoid Î±] (a : AddUnits Î±) {b c : Î±}, â†‘(-a) + b = c â†” b = â†‘a + c
Result.success

Testing || Polynomial.isRoot_cyclotomic_iff : âˆ€ {R : Type u_1} [inst : CommRing R] {n : â„•} [inst_1 : IsDomain R] [inst_2 : NeZero â†‘n] {Î¼ : R},
  (Polynomial.cyclotomic n R).IsRoot Î¼ â†” IsPrimitiveRoot Î¼ n
Result.exception ::
Duper saturated

Testing || SimplexCategory.Truncated.instFullInclusion : âˆ€ (n : â„•), (SimplexCategory.Truncated.inclusion n).Full
Result.success

Testing || Ordinal.nfp_le_fp : âˆ€ {f : Ordinal.{u_1} â†’ Ordinal.{u_1}}, Monotone f â†’ âˆ€ {a b : Ordinal.{u_1}}, a â‰¤ b â†’ f b â‰¤ b â†’ Ordinal.nfp f a â‰¤ b
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.length_eraseP_add_one : âˆ€ {Î± : Type u} {p : Î± â†’ Bool} {l : List Î±} {a : Î±}, a âˆˆ l â†’ p a = true â†’ (List.eraseP p l).length + 1 = l.length
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.eq_sub_iff_add_eq : âˆ€ {w : â„•} {x y z : BitVec w}, x = z - y â†” x + y = z
Result.success

Testing || EuclideanGeometry.collinear_of_angle_eq_zero : âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ = 0 â†’ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ}
Result.success

Testing || MeasureTheory.Measure.instNeZeroOfNonempty : âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {m : MeasurableSpace X} (Î¼ : MeasureTheory.Measure X)
  [inst : Î¼.IsOpenPosMeasure] [inst : Nonempty X], NeZero Î¼
Result.exception ::
Duper saturated

Testing || AddAction.IsFixedBlock.univ : âˆ€ {G : Type u_1} [inst : AddGroup G] {X : Type u_2} [inst_1 : AddAction G X], AddAction.IsFixedBlock G Set.univ
Result.exception ::
Duper saturated

Testing || FreeGroup.invRev_involutive : âˆ€ {Î± : Type u}, Function.Involutive FreeGroup.invRev
Result.exception ::
Duper saturated

Testing || CategoryTheory.Adjunction.unit_rightAdjointUniq_hom_app_assoc : âˆ€ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_4, u_2} D] {F : CategoryTheory.Functor C D} {G G' : CategoryTheory.Functor D C}
  (adj1 : F âŠ£ G) (adj2 : F âŠ£ G') (x : C) {Z : C} (h : G'.obj (F.obj x) âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (adj1.unit.app x)
      (CategoryTheory.CategoryStruct.comp ((adj1.rightAdjointUniq adj2).hom.app (F.obj x)) h) =
    CategoryTheory.CategoryStruct.comp (adj2.unit.app x) h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.CategoryStruct.id
  x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.Primes.coe_nat_injective : Function.Injective fun a => â†‘a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of Î» binder contains bound variables

Testing || Affine.Simplex.circumcenter_eq_affineCombination_of_pointsWithCircumcenter : âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n),
  s.circumcenter =
    (Finset.affineCombination â„ Finset.univ s.pointsWithCircumcenter)
      (Affine.Simplex.circumcenterWeightsWithCircumcenter n)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || covBy_iff_lt_covBy_grade : âˆ€ {ğ•† : Type u_1} {Î± : Type u_3} [inst : Preorder ğ•†] [inst_1 : Preorder Î±] [inst_2 : GradeOrder ğ•† Î±] {a b : Î±},
  a â‹– b â†” a < b âˆ§ grade ğ•† a â‹– grade ğ•† b
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `grade cifvar_11 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.range'_subset_right_1 : âˆ€ {s m n : â„•}, List.range' s m âŠ† List.range' s n â†” m â‰¤ n
Result.exception ::
Duper saturated

Testing || AffineSubspace.SSameSide.trans : âˆ€ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : LinearOrderedField R] [inst_1 : AddCommGroup V]
  [inst_2 : _root_.Module R V] [inst_3 : AddTorsor V P] {s : AffineSubspace R P} {x y z : P},
  s.SSameSide x y â†’ s.SSameSide y z â†’ s.SSameSide x z
Result.exception ::
Duper saturated

Testing || Finset.dens_lt_dens : âˆ€ {Î± : Type u_2} [inst : Fintype Î±] {s t : Finset Î±}, s âŠ‚ t â†’ s.dens < t.dens
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toDivInvMonoid`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submonoid.closure_eq_of_le : âˆ€ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {S : Submonoid M},
  s âŠ† â†‘S â†’ S â‰¤ Submonoid.closure s â†’ Submonoid.closure s = S
Result.success

Testing || SetLike.prod_mem_graded : âˆ€ {Î¹ : Type u_2} {R : Type u_3} {S : Type u_4} [inst : SetLike S R] [inst_1 : CommMonoid R] [inst_2 : AddCommMonoid Î¹]
  (A : Î¹ â†’ S) [inst_3 : SetLike.GradedMonoid A] {Îº : Type u_5} (i : Îº â†’ Î¹) (g : Îº â†’ R) {F : Finset Îº},
  (âˆ€ k âˆˆ F, g k âˆˆ A (i k)) â†’ âˆ k âˆˆ F, g k âˆˆ A (âˆ‘ k âˆˆ F, i k)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.instInsert`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Pi.mulSupport_mulSingle_one : âˆ€ {A : Type u_1} {B : Type u_2} [inst : DecidableEq A] [inst_1 : _root_.One B] {a : A},
  Function.mulSupport (Pi.mulSingle a 1) = âˆ…
Result.exception ::
Duper saturated

Testing || CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {X Y : C} (f g : X âŸ¶ Y),
  f + g =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X))
      (CategoryTheory.Limits.biprod.desc f g)
Result.success

Testing || RCLike.nonneg_iff : âˆ€ {K : Type u_1} [inst : RCLike K] {z : K}, 0 â‰¤ z â†” 0 â‰¤ RCLike.re z âˆ§ RCLike.im z = 0
Result.success

Testing || Finset.sup'_mono : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SemilatticeSup Î±] (f : Î² â†’ Î±) {sâ‚ sâ‚‚ : Finset Î²} (h : sâ‚ âŠ† sâ‚‚)
  (hâ‚ : sâ‚.Nonempty), sâ‚.sup' hâ‚ f â‰¤ sâ‚‚.sup' â‹¯ f
Result.exception ::
Duper saturated

Testing || WithBot.zero_ne_bot : âˆ€ {Î± : Type u} [inst : _root_.Zero Î±], 0 â‰  âŠ¥
Result.success

Testing || IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow : âˆ€ {p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]
  [inst_3 : IsCyclotomicExtension {p ^ k} K L] [hp : Fact (Nat.Prime â†‘p)] (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)),
  Irreducible (Polynomial.cyclotomic (â†‘(p ^ k)) K) â†’
    âˆƒ u n, Algebra.discr K â‡‘(IsPrimitiveRoot.powerBasis K hÎ¶).basis = â†‘â†‘u * â†‘â†‘p ^ n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TopHom.comp_apply : âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : Top Î±] [inst_1 : Top Î²] [inst_2 : Top Î³] (f : TopHom Î² Î³)
  (g : TopHom Î± Î²) (a : Î±), (f.comp g) a = f (g a)
Result.success

Testing || Basis.finTwoProd_zero : âˆ€ (R : Type u_7) [inst : Semiring R], (Basis.finTwoProd R) 0 = (1, 0)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.piecewise_neg : âˆ€ {I : Type u} {f : I â†’ Type v} [inst : (i : I) â†’ Neg (f i)] (s : Set I) [inst_1 : (i : I) â†’ Decidable (i âˆˆ s)]
  (fâ‚ gâ‚ : (i : I) â†’ f i), s.piecewise (-fâ‚) (-gâ‚) = -s.piecewise fâ‚ gâ‚
Result.exception ::
Duper saturated

Testing || CategoryTheory.Adjunction.toEquivalence_inverse : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F âŠ£ G)
  [inst_2 : âˆ€ (X : C), CategoryTheory.IsIso (adj.unit.app X)]
  [inst_3 : âˆ€ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)], adj.toEquivalence.inverse = G
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_7 cifvar_8).app x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Units.val_inv_ofPowEqOne : âˆ€ {M : Type u_1} [inst : Monoid M] (a : M) (n : â„•) (ha : a ^ n = 1) (hn : n â‰  0),
  â†‘(Units.ofPowEqOne a n ha hn)â»Â¹ = a ^ (n - 1)
Result.success

Testing || EMetric.diam_closedBall : âˆ€ {Î± : Type u_1} {x : Î±} [inst : PseudoEMetricSpace Î±] {r : ENNReal}, EMetric.diam (EMetric.closedBall x r) â‰¤ 2 * r
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `EMetric.diam x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || minpoly.coeff_zero_eq_zero : âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},
  IsIntegral A x â†’ ((minpoly A x).coeff 0 = 0 â†” x = 0)
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.bijOn_iInter : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_5} [hi : Nonempty Î¹] {s : Î¹ â†’ Set Î±} {t : Î¹ â†’ Set Î²} {f : Î± â†’ Î²},
  (âˆ€ (i : Î¹), Set.BijOn f (s i) (t i)) â†’ Set.InjOn f (â‹ƒ i, s i) â†’ Set.BijOn f (â‹‚ i, s i) (â‹‚ i, t i)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 (!5 (Î»x0 : #0, (!2 x0))) (Î»x0 : #1, (âˆ€ x1 : #1, ((!22 (!5 (Î»x2 : #0, (!2 x2))) x1) â†’ (((!1 x0) = (!1 x1)) â†’ (x0 = x1)))))) = (!4 !1 (!5 (Î»x0 : #0, (!2 x0))))) is not type correct

Testing || Module.End.HasUnifEigenvalue.lt : âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {f : Module.End R M} {Î¼ : R} {k m : â„•âˆ}, 0 < m â†’ f.HasUnifEigenvalue Î¼ k â†’ f.HasUnifEigenvalue Î¼ m
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearMap.instFunLike`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Comonad.ComonadicityInternal.main_pair_F_cosplit : âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Category.{vâ‚, uâ‚‚} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F âŠ£ G) (A : adj.toComonad.Coalgebra),
  F.IsCosplitPair (G.map A.a) (adj.unit.app (G.obj A.A))
Result.exception ::
Duper saturated

Testing || AddSubgroup.map_eq_bot_iff : âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_5} [inst_1 : AddGroup N] (H : AddSubgroup G) {f : G â†’+ N},
  AddSubgroup.map f H = âŠ¥ â†” H â‰¤ f.ker
Result.exception ::
Duper saturated

Testing || CategoryTheory.hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete : âˆ€ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C] [inst_3 : CategoryTheory.Limits.HasFiniteLimits C]
  (J : Type u_1) [inst_4 : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete J) C]
  [inst_5 : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete J)) C]
  [inst_6 : CategoryTheory.HasExactColimitsOfShape (Finset (CategoryTheory.Discrete J)) C],
  CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete J) C
Result.exception ::
Duper saturated

Testing || NumberField.mixedEmbedding.fundamentalCone.normAtPlace_pos_of_mem : âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NumberField K] {x : NumberField.mixedEmbedding.mixedSpace K},
  x âˆˆ NumberField.mixedEmbedding.fundamentalCone K â†’
    âˆ€ (w : NumberField.InfinitePlace K), 0 < (NumberField.mixedEmbedding.normAtPlace w) x
Result.exception ::
Duper saturated

Testing || Filter.disjoint_cocompact_left : âˆ€ {X : Type u} [inst : TopologicalSpace X] (f : Filter X), Disjoint (Filter.cocompact X) f â†” âˆƒ K âˆˆ f, IsCompact K
Result.success

Testing || List.dlookup_kerase_ne : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : DecidableEq Î±] {a a' : Î±} {l : List (Sigma Î²)},
  a â‰  a' â†’ List.dlookup a (List.kerase a' l) = List.dlookup a l
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `List.dlookup x_1
  (cifvar_12 x_2 x_0)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || iteratedFDerivWithin_comp_add_left' : âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {s : Set E}
  {f : E â†’ F} (n : â„•) (a : E),
  iteratedFDerivWithin ğ•œ n (fun z => f (a + z)) s = fun x => iteratedFDerivWithin ğ•œ n f (a +áµ¥ s) (a + x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MonotoneOn.Ioc : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f g : Î± â†’ Î²} {s : Set Î±},
  MonotoneOn f s â†’ AntitoneOn g s â†’ AntitoneOn (fun x => Set.Ioc (f x) (g x)) s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!5 (Î»x0 : #0, (!7 (!17 (!1 x0)) (Î»x1 : #1, (!18 x1 (!4 x0))))) !2) = (!5 (Î»x0 : #0, (!6 (!1 x0) (!4 x0))) !2)) is not type correct

Testing || AlgebraicGeometry.StructureSheaf.comap_const : âˆ€ {R : Type u} [inst : CommRing R] {S : Type u} [inst_1 : CommRing S] (f : R â†’+* S)
  (U : TopologicalSpace.Opens â†‘(AlgebraicGeometry.PrimeSpectrum.Top R))
  (V : TopologicalSpace.Opens â†‘(AlgebraicGeometry.PrimeSpectrum.Top S))
  (hUV : V.carrier âŠ† â‡‘(PrimeSpectrum.comap f) â»Â¹' U.carrier) (a b : R) (hb : âˆ€ x âˆˆ U, b âˆˆ x.asIdeal.primeCompl),
  (AlgebraicGeometry.StructureSheaf.comap f U V hUV) (AlgebraicGeometry.StructureSheaf.const R a b U hb) =
    AlgebraicGeometry.StructureSheaf.const S (f a) (f b) V â‹¯
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: V.carrier âŠ† â‡‘(PrimeSpectrum.comap f) â»Â¹' U.carrier is not a `âˆ€`

Testing || ContinuousLinearMap.restrictScalars_zero : âˆ€ {A : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring A] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]
  [inst_3 : _root_.Module A M] [inst_4 : _root_.Module A Mâ‚‚] [inst_5 : TopologicalSpace M]
  [inst_6 : TopologicalSpace Mâ‚‚] {R : Type u_4} [inst_7 : Ring R] [inst_8 : _root_.Module R M]
  [inst_9 : _root_.Module R Mâ‚‚] [inst_10 : LinearMap.CompatibleSMul M Mâ‚‚ R A],
  ContinuousLinearMap.restrictScalars R 0 = 0
Result.success

Testing || CategoryTheory.Limits.colimit.Î¹_pre : âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} J] {K : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K]
  {C : Type u} [inst_2 : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor J C)
  [inst_3 : CategoryTheory.Limits.HasColimit F] (E : CategoryTheory.Functor K J)
  [inst_4 : CategoryTheory.Limits.HasColimit (E.comp F)] (k : K),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (E.comp F) k)
      (CategoryTheory.Limits.colimit.pre F E) =
    CategoryTheory.Limits.colimit.Î¹ F (E.obj k)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_21.app x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Module.AEval'_def : âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  (Ï† : M â†’â‚—[R] M), Module.AEval' Ï† = Module.AEval R M Ï†
Result.success

Testing || MeasureTheory.Measure.integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport : âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] (Î¼' Î¼ : MeasureTheory.Measure G) [inst_5 : Î¼.IsAddHaarMeasure]
  [inst_6 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'] [inst_7 : Î¼'.IsAddLeftInvariant] {f : G â†’ â„},
  Continuous f â†’ HasCompactSupport f â†’ âˆ« (x : G), f x âˆ‚Î¼' = âˆ« (x : G), f x âˆ‚Î¼'.addHaarScalarFactor Î¼ â€¢ Î¼
Result.exception ::
Duper saturated

Testing || Sublattice.mem_comap : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Lattice Î±] [inst_1 : Lattice Î²] {f : LatticeHom Î± Î²} {a : Î±} {L : Sublattice Î²},
  a âˆˆ Sublattice.comap f L â†” f a âˆˆ L
Result.success

Testing || ContinuousAlgHom.uniformContinuous : âˆ€ {R : Type u_1} [inst : CommSemiring R] {Eâ‚ : Type u_4} {Eâ‚‚ : Type u_5} [inst_1 : UniformSpace Eâ‚]
  [inst_2 : UniformSpace Eâ‚‚] [inst_3 : Ring Eâ‚] [inst_4 : Ring Eâ‚‚] [inst_5 : Algebra R Eâ‚] [inst_6 : Algebra R Eâ‚‚]
  [inst_7 : UniformAddGroup Eâ‚] [inst_8 : UniformAddGroup Eâ‚‚] (f : Eâ‚ â†’A[R] Eâ‚‚), UniformContinuous â‡‘f
Result.success

Testing || CategoryTheory.ShortComplex.rightHomologyFunctor_obj : âˆ€ (C : Type u_1) [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]
  (S : CategoryTheory.ShortComplex C), (CategoryTheory.ShortComplex.rightHomologyFunctor C).obj S = S.rightHomology
Result.success

Testing || Opposite.equivToOpposite_symm_coe : âˆ€ {Î± : Sort u}, â‡‘Opposite.equivToOpposite.symm = Opposite.unop
Result.exception ::
Duper saturated

Testing || tendsto_nhdsWithin_iff : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] {a : Î±} {l : Filter Î²} {s : Set Î±} {f : Î² â†’ Î±},
  Filter.Tendsto f l (nhdsWithin a s) â†” Filter.Tendsto f l (nhds a) âˆ§ âˆ€á¶  (n : Î²) in l, f n âˆˆ s
Result.success

Testing || Complex.integerComplement_eq : Complex.integerComplement = {z | Â¬âˆƒ n, â†‘n = z}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!1 (!3 (!4 !5))) = !0) is not type correct

Testing || CategoryTheory.Limits.hasImage_zero : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] {X Y : C}, CategoryTheory.Limits.HasImage 0
Result.exception ::
Duper saturated

Testing || Std.DHashMap.getD_eq_fallback : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {x : BEq Î±} {x_1 : Hashable Î±} {m : Std.DHashMap Î± Î²} [inst : LawfulBEq Î±] {a : Î±}
  {fallback : Î² a}, a âˆ‰ m â†’ m.getD a fallback = fallback
Result.success

Testing || ULift.addRightCancelSemigroup.proof_2 : âˆ€ {Î± : Type u_2} [inst : AddRightCancelSemigroup Î±] (x x_1 : ULift.{u_1, u_2} Î±),
  Equiv.ulift (x + x_1) = Equiv.ulift (x + x_1)
Result.success

Testing || CategoryTheory.Functor.CoreMonoidal.Î¼Iso_hom_natural_right_assoc : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}
  [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] [inst_3 : CategoryTheory.MonoidalCategory D]
  {F : CategoryTheory.Functor C D} (self : F.CoreMonoidal) {X Y : C} (X' : C) (f : X âŸ¶ Y) {Z : D}
  (h : F.obj (CategoryTheory.MonoidalCategory.tensorObj X' Y) âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft (F.obj X') (F.map f))
      (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X' Y).hom h) =
    CategoryTheory.CategoryStruct.comp (self.Î¼Iso X' X).hom
      (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategory.whiskerLeft X' f)) h)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CircleDeg1Lift.translate_zpow : âˆ€ (x : â„) (n : â„¤),
  CircleDeg1Lift.translate (Multiplicative.ofAdd x) ^ n = CircleDeg1Lift.translate (Multiplicative.ofAdd (â†‘n * x))
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TopologicalSpace.Compacts.equiv_symm : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²),
  TopologicalSpace.Compacts.equiv f.symm = (TopologicalSpace.Compacts.equiv f).symm
Result.success

Testing || OrderDual.instPosSMulReflectLE : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : SMul Î± Î²] [inst_3 : _root_.Zero Î±]
  [inst_4 : PosSMulReflectLE Î± Î²], PosSMulReflectLE Î± Î²áµ’áµˆ
Result.exception ::
Duper saturated

Testing || lowerClosure_vadd : âˆ€ {Î± : Type u_1} [inst : OrderedAddCommGroup Î±] (s : Set Î±) (a : Î±), lowerClosure (a +áµ¥ s) = a +áµ¥ lowerClosure s
Result.exception ::
Duper saturated

Testing || LTSeries.mk_length : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (length : â„•) (toFun : Fin (length + 1) â†’ Î±) (strictMono : StrictMono toFun),
  (LTSeries.mk length toFun strictMono).length = length
Result.success

Testing || tendsto_neg_nhdsWithin_Iio : âˆ€ {H : Type x} [inst : TopologicalSpace H] [inst_1 : OrderedAddCommGroup H] [inst_2 : ContinuousNeg H] {a : H},
  Filter.Tendsto Neg.neg (nhdsWithin a (Set.Iio a)) (nhdsWithin (-a) (Set.Ioi (-a)))
Result.success

Testing || Prod.instAddRightCancelMonoid.proof_5 : âˆ€ {M : Type u_1} {N : Type u_2} [inst : AddRightCancelMonoid M] [inst_1 : AddRightCancelMonoid N] (a a_1 a_2 : M Ã— N),
  a + a_1 = a_2 + a_1 â†’ a = a_2
Result.success

Testing || Set.pairwise_disjoint_Ioc_intCast : âˆ€ (Î± : Type u_1) [inst : OrderedRing Î±], Pairwise (Disjoint on fun n => Set.Ioc (â†‘n) (â†‘n + 1))
Result.exception ::
(deterministic) timeout at `fluidSup`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_map : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (A : CategoryTheory.Functor Cáµ’áµ– (Type v))
  {X Y : CategoryTheory.Functor (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)áµ’áµ– (Type v)} (Î· : X âŸ¶ Y),
  (CategoryTheory.OverPresheafAux.yonedaCollectionFunctor A).map Î· =
    CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMapâ‚ Î·
Result.success

Testing || CategoryTheory.Limits.MulticospanIndex.sndPiMap_Ï€_assoc : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MulticospanIndex C)
  [inst_1 : CategoryTheory.Limits.HasProduct I.left] [inst_2 : CategoryTheory.Limits.HasProduct I.right] (b : I.R)
  {Z : C} (h : I.right b âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp I.sndPiMap
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.right b) h) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.left (I.sndTo b))
      (CategoryTheory.CategoryStruct.comp (I.snd b) h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.limit.lift
  (cifvar_1 cifvar_2) x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LieEquiv.symm_trans : âˆ€ {R : Type u} {Lâ‚ : Type v} {Lâ‚‚ : Type w} {Lâ‚ƒ : Type wâ‚} [inst : CommRing R] [inst_1 : LieRing Lâ‚]
  [inst_2 : LieRing Lâ‚‚] [inst_3 : LieRing Lâ‚ƒ] [inst_4 : LieAlgebra R Lâ‚] [inst_5 : LieAlgebra R Lâ‚‚]
  [inst_6 : LieAlgebra R Lâ‚ƒ] (eâ‚ : Lâ‚ â‰ƒâ‚—â…Râ† Lâ‚‚) (eâ‚‚ : Lâ‚‚ â‰ƒâ‚—â…Râ† Lâ‚ƒ), (eâ‚.trans eâ‚‚).symm = eâ‚‚.symm.trans eâ‚.symm
Result.success

Testing || Computable.option_bind : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Ïƒ : Type u_4} [inst : Primcodable Î±] [inst_1 : Primcodable Î²] [inst_2 : Primcodable Ïƒ]
  {f : Î± â†’ Option Î²} {g : Î± â†’ Î² â†’ Option Ïƒ}, Computable f â†’ Computableâ‚‚ g â†’ Computable fun a => (f a).bind (g a)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || tsum_setProd_singleton_left : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] (b : Î²)
  (t : Set Î³) (f : Î² Ã— Î³ â†’ Î±), âˆ‘' (x : â†‘({b} Ã—Ë¢ t)), f â†‘x = âˆ‘' (c : â†‘t), f (b, â†‘c)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type { x // x âˆˆ x_1 } of Î» binder contains bound variables

Testing || CategoryTheory.Comma.instIsIsoRight : âˆ€ {A : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} A] {B : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B]
  {T : Type uâ‚ƒ} [inst_2 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T] {L : CategoryTheory.Functor A T}
  {R : CategoryTheory.Functor B T} {X Y : CategoryTheory.Comma L R} (e : X âŸ¶ Y) [inst_3 : CategoryTheory.IsIso e],
  CategoryTheory.IsIso e.right
Result.exception ::
Duper saturated

Testing || SemidirectProduct.map_comp_inr : âˆ€ {Nâ‚ : Type u_4} {Gâ‚ : Type u_5} {Nâ‚‚ : Type u_6} {Gâ‚‚ : Type u_7} [inst : Group Nâ‚] [inst_1 : Group Gâ‚]
  [inst_2 : Group Nâ‚‚] [inst_3 : Group Gâ‚‚] {Ï†â‚ : Gâ‚ â†’* MulAut Nâ‚} {Ï†â‚‚ : Gâ‚‚ â†’* MulAut Nâ‚‚} (fn : Nâ‚ â†’* Nâ‚‚) (fg : Gâ‚ â†’* Gâ‚‚)
  (h : âˆ€ (g : Gâ‚), fn.comp (MulEquiv.toMonoidHom (Ï†â‚ g)) = (MulEquiv.toMonoidHom (Ï†â‚‚ (fg g))).comp fn),
  (SemidirectProduct.map fn fg h).comp SemidirectProduct.inr = SemidirectProduct.inr.comp fg
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `{ left := x_2, right := x_1 }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.any_toArray' : âˆ€ {Î± : Type u_1} {stop : â„•} (p : Î± â†’ Bool) (l : List Î±), stop = l.toArray.size â†’ l.toArray.any p 0 stop = l.any p
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.any x_0 cifvar_8
  (cifvar_2 (cifvar_10 x_1))`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Batteries.HashMap.Imp.expand_size : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {sz : â„•} [inst : Hashable Î±] {buckets : Batteries.HashMap.Imp.Buckets Î± Î²},
  (Batteries.HashMap.Imp.expand sz buckets).buckets.size = buckets.size
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Batteries.HashMap.Imp.expand.proof_1
  x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.takeD_eq_take : âˆ€ {Î± : Type u} {n : â„•} {l : List Î±} (a : Î±), n â‰¤ l.length â†’ List.takeD n l a = List.take n l
Result.exception ::
Duper saturated

Testing || emultiplicity_mul : âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] {p a b : Î±},
  Prime p â†’ emultiplicity p (a * b) = emultiplicity p a + emultiplicity p b
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordnode.findMin'_dual : âˆ€ {Î± : Type u_1} (t : Ordnode Î±) (x : Î±), t.dual.findMin' x = Ordnode.findMax' x t
Result.exception ::
Duper saturated

Testing || Submodule.map_coe : âˆ€ {R : Type u_1} {Râ‚‚ : Type u_3} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]
  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ïƒâ‚â‚‚] {F : Type u_9} [inst_7 : FunLike F M Mâ‚‚]
  [inst_8 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚] (f : F) (p : Submodule R M), â†‘(Submodule.map f p) = â‡‘f '' â†‘p
Result.success

Testing || CategoryTheory.skeletonEquivalence_unitIso : âˆ€ (C : Type uâ‚) [inst : CategoryTheory.Category.{vâ‚, uâ‚} C],
  (CategoryTheory.skeletonEquivalence C).unitIso =
    CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.InducedCategory.isoMk (Nonempty.some â‹¯).symm) â‹¯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€
  (naturality :
    autoParam
      (âˆ€ {X Y : CategoryTheory.Skeleton C} (f : X âŸ¶ Y),
        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.id (CategoryTheory.Skeleton C)).map f)
            (CategoryTheory.InducedCategory.isoMk (Classical.choice â‹¯).symm).hom =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.InducedCategory.isoMk (Classical.choice â‹¯).symm).hom
            (((CategoryTheory.fromSkeleton C).comp (CategoryTheory.toSkeletonFunctor C)).map f))
      _autoâœ),
  (CategoryTheory.skeletonEquivalence C).unitIso =
    CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.InducedCategory.isoMk (Classical.choice â‹¯).symm)
      naturality, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || LaurentSeries.tendsto_valuation : âˆ€ (K : Type u_2) [inst : Field K]
  (a : IsDedekindDomain.HeightOneSpectrum.adicCompletion (RatFunc K) (Polynomial.idealX K)),
  Filter.Tendsto (â‡‘Valued.v) (Filter.comap (â†‘(RatFunc K)) (nhds a)) (nhds (Valued.v a))
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Order.Ico_pred_right_eq_insert : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : PredOrder Î±] {a b : Î±} [inst_2 : NoMinOrder Î±],
  a â‰¤ b â†’ Set.Ioc (Order.pred a) b = insert a (Set.Ioc a b)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.Iic exfvar_6`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Elapsed time: 230143 ms

Summary:

0 E FiniteDimensional.trans
1 E Complex.instIsComplete
2 E ContDiffOn.norm_sq
3 E PartialHomeomorph.isOpen_image_iff_of_subset_source
4 E CategoryTheory.Functor.IsEventuallyConstantTo.coneÏ€App_eq_id
5 E CompHausLike.hasPullbacksOfInclusions
6 E List.mem_flatten
7 S Polynomial.cyclotomic_two
8 E BoxIntegral.Box.dist_le_distortion_mul
9 S mul_le_of_le_of_le_one_of_nonneg
10 E CategoryTheory.Limits.hasCoequalizers_of_hasPushouts_and_binary_coproducts
11 E Function.OfArity.uncurry_two_eq_uncurry
12 E mem_own_rightAddCoset
13 E Ideal.isHomogeneous_iff_forall_subset
14 E AlgebraicGeometry.Scheme.evaluation_naturality
15 S CategoryTheory.SingleObj.mapHom_comp
16 S isAddUnit_of_add_isAddUnit_right
17 E PMF.toOuterMeasure_uniformOfFintype_apply
18 E AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand
19 E CircleDeg1Lift.le_iterate_of_add_int_le_map
20 E ProbabilityTheory.Kernel.iIndepFun.meas_biInter
21 S CategoryTheory.Functor.comp_obj
22 E genericPoint_closure
23 S AddMonoidHom.noncommCoprod.proof_2
24 E Finset.coe_mem
25 S Real.nat_cast_lt_toNNReal
26 E AddMonoidAlgebra.lift_apply
27 S Finset.sup_singleton
28 E Complex.I_mul_im
29 E Option.orElse_none'
30 E Module.Flat.iff_lTensor_exact
31 S Int.emod_negSucc
32 E Set.preimage_injective
33 S HurwitzZeta.completedCosZeta_one_sub
34 E List.TFAE.out
35 S CommRingCat.Under.equalizerFork'_Î¹
36 S OrderIso.map_csSup'
37 E Nat.ofDigits_lt_base_pow_length
38 S EMetric.preimage_add_left_ball
39 E Cardinal.induction_on_pi
40 S Turing.PartrecToTM2.tr_move
41 E Array.reflBEq_iff
42 S LinearMap.finiteDimensional
43 E sum_conjClasses_card_eq_card
44 S nonempty_Prop
45 E WithTop.instOrderedSub
46 E Ideal.comap_map_mk
47 E Std.DHashMap.Internal.Rawâ‚€.contains_insertIfNew
48 E CategoryTheory.ShortComplex.opcyclesMap'_g'_assoc
49 S act_rel_of_act_rel_of_rel_act_rel
50 E hasContinuousInvâ‚€_of_hasSmoothInvâ‚€
51 E BitVec.msb_eq_getLsbD_last
52 E WittVector.mul_polyOfInterest_aux5
53 E CategoryTheory.MorphismProperty.pullback_fst
54 S Eq.ge
55 S Set.infinite_prod
56 E IsLocalization.submonoid_map_le_is_unit
57 E instNontrivialStalkPresheafSmoothSheaf
58 E CategoryTheory.Limits.colimitYonedaHomIsoLimitOp_Ï€_apply
59 E Asymptotics.isEquivalent_iff_exists_eq_mul
60 E norm_add_sq_real
61 S Polynomial.natDegree_pos_of_not_isUnit_of_dvd_monic
62 E MeasureTheory.SimpleFunc.measurableSet_preimage
63 E EMetric.tendsto_nhds_nhds
64 S QuadraticModuleCat.forgetâ‚‚_map
65 S ZeroHom.comp.proof_1
66 E Turing.PartrecToTM2.supports_insert
67 E ContinuousLinearEquiv.isOpen
68 E MeasureTheory.StronglyMeasurable.measurableSet_mulSupport
69 E DirichletCharacter.isMultiplicative_toArithmeticFunction
70 E mem_perms_of_finset_iff
71 E _private.Mathlib.Data.Real.Pi.Irrational.0.is_integer
72 E Order.height_eq_top_iff
73 S List.getD_map
74 E FiniteDimensional.exists_is_basis_integral
75 E LinearMap.prod_eq_inf_comap
76 E HahnSeries.toPowerSeriesAlg_apply
77 E Order.Iic_pred_of_not_isMin
78 S Complex.abs_of_nonneg
79 E eventually_uniformity_iterate_comp_subset
80 E Sum.Lex.Icc_inr_inr
81 E AlgebraicGeometry.LocallyRingedSpace.stalkMap_inv_hom_assoc
82 S Nat.even_sub
83 S List.mem_of_mem_inter_right
84 E Set.Finite.toFinset_insert
85 S QuotientAddGroup.quotientEquivSelf.proof_3
86 S List.eq_nil_of_map_eq_nil
87 S NumberField.InfinitePlace.comap_id
88 E RelIso.cast_trans
89 E Set.nontrivial_of_lt
90 S CategoryTheory.Groupoid.Free.of_eq
91 E Antitone.iUnion_comp_tendsto_atBot
92 E Filter.map_sigma_mk_comap
93 E ProbabilityTheory.mgf_smul_left
94 E CategoryTheory.ShortComplex.SnakeInput.Lâ‚ƒ_exact
95 E PartialHomeomorph.eventually_left_inverse'
96 E CategoryTheory.ComposableArrows.homMkâ‚ƒ_app_zero
97 S ProbabilityTheory.Kernel.condKernelCountable_apply
98 S MonoidHom.submonoidComap_apply_coe
99 E Batteries.instTransCmpFlipOrdering
100 E LinearMap.BilinForm.nondegenerate_of_det_ne_zero
101 E NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top
102 E translate_neg_right
103 S ContDiff.of_succ
104 E Matrix.det_updateCol_add_self
105 S uniformContinuous_const
106 E CategoryTheory.Adjunction.compPreadditiveYonedaIso_hom_app_app_apply
107 S ContinuousLinearEquiv.compContinuousMultilinearMapL_apply
108 E conjneg_conjneg
109 S ProbabilityTheory.Kernel.IsSFiniteKernel.snd
110 E CategoryTheory.preserves_mono_of_preservesLimit
111 E AddGroupNormClass.toNormedAddGroup.proof_1
112 S PadicInt.nonarchimedean
113 E CategoryTheory.Pretriangulated.instIsHomologicalOppositeAddCommGrpObjFunctorPreadditiveYoneda
114 E StrictConvexOn.lt_on_open_segment'
115 E OrderedCommGroup.toMulLeftReflectLE
116 E neg_of_smul_neg_right'
117 E Std.DHashMap.Internal.Rawâ‚€.size_le_size_insert
118 E CategoryTheory.Zigzag.of_zag
119 E HomogeneousIdeal.toIdeal_iSupâ‚‚
120 E CategoryTheory.GrothendieckTopology.sheafifyLift_unique
121 E Asymptotics.IsBigO.eventually_integrableOn
122 S Associates.le_singleton_iff
123 E Subgroup.op_iInf
124 S mul_nsmul'
125 S Multiset.coe_eq_singleton
126 E Polynomial.opRingEquiv_op_monomial
127 E Monotone.map_liminf_of_continuousAt
128 E Set.ball_empty_iff
129 E AddSubmonoid.prod_le_iff
130 E Real.sin_pos_of_mem_Ioo
131 E Equiv.Perm.commute_of_mem_cycleFactorsFinset_commute
132 E Submonoid.prod_eq_bot_iff
133 E SatisfiesM_Option_eq
134 E WeierstrassCurve.variableChange_Î”
135 E RelEmbedding.toEmbedding_inj
136 S Fin.rev_bot
137 E CategoryTheory.Limits.hasBiproductsOfShape_finite
138 E Std.DHashMap.Internal.List.getValueCast!_eraseKey_self
139 S tsum_const_smul
140 E Finset.subset_singleton_iff
141 E PowerSeries.WithPiTopology.continuous_constantCoeff
142 E Submodule.comap_surjective_of_injective
143 E Ordnode.Valid'.of_lt
144 E Heyting.Regular.coe_injective
145 E CauchySeq.prod
146 S exists_le_le
147 E List.init_eq_of_concat_eq
148 E Fin.ofNat'_sub
149 S Equiv.Perm.SameCycle.extendDomain
150 E CategoryTheory.IsUniversalColimit.of_mapCocone
151 E hasSum_single
152 S MagmaCat.ofHom_apply
153 E ContMDiffMap.mdifferentiableAt
154 E MeasureTheory.levyProkhorovDist_self
155 S AddHom.fst_comp_prod
156 E AddMonoidHom.coe_ofClosureMEqTopLeft
157 E CategoryTheory.ShortComplex.Exact.epi_f
158 S AddMonoidHom.inverse.proof_3
159 E Auto.Embedding.Lam.LamEquiv.congr
160 E CategoryTheory.SingleFunctors.shiftIso_add'_inv_app
161 S Duper.rule15bTheorem
162 E Multiset.card_coe
163 E List.pairwise_iff
164 E AddSubgroup.isOpen_of_isClosed_of_finiteIndex
165 E parallelogram_law_with_norm
166 S MvPolynomial.evalâ‚‚_map
167 E Set.indicator_le_indicator
168 S AddHom.restrict_apply
169 E Part.Ï‰Sup_eq_none
170 E SimpleGraph.Connected.mono
171 E CochainComplex.mappingCone.lift_snd
172 E Submonoid.mem_prod
173 E CategoryTheory.sheafifyMap_sheafifyLift
174 E UniformOnFun.toFun_zero
175 E EuclideanGeometry.Sphere.secondInter_smul
176 S disjoint_sdiff_comm
177 E compl_add_closure_zero_eq
178 S Polynomial.Monic.natDegree_pos_of_not_isUnit
179 E AddSubgroup.eq_of_le_of_card_ge
180 E WittVector.mulN_coeff
181 E isIntegralCurveAt_comp_mul_ne_zero
182 E DomAddAct.instAddActionSubtypeAEEqFunMemAddAddSubgroupLp.proof_2
183 E AddSubmonoid.le_op_iff
184 S LinOrd.dualEquiv_inverse
185 E Complex.nnnorm_real
186 E Sublattice.mem_sInf
187 E CategoryTheory.ChosenFiniteProducts.lift_snd
188 E Cardinal.mk_quotient_le
189 E TrivSqZeroExt.snd_exp
190 E AlgebraicTopology.DoldKan.Q_f_idem
191 E Isometry.mapsTo_perpBisector
192 E CategoryTheory.Discrete.monoidal_leftUnitor
193 S contravariant_lt_of_contravariant_le
194 E Int.eq_mul_div_of_mul_eq_mul_of_dvd_left
195 E pointedToPartialFun_map
196 E MulRingSeminormClass.toRingSeminormClass
197 E CategoryTheory.ThinSkeleton.map_id_eq
198 E Ordinal.pred_lt_iff_is_succ
199 S Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors
200 E List.Vector.mem_iff_get
201 E Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem
202 E HomologicalComplexâ‚‚.d_f_comp_d_f
203 S grade_lt_grade_iff
204 E Matrix.vecMulVec_empty
205 S List.join_map_filter
206 S Matrix.circulant_add
207 S CategoryTheory.CostructuredArrow.map_obj_hom
208 E LinearMap.range_toContinuousLinearMap
209 E LinearEquiv.isUnit_det
210 E riemannZeta_eulerProduct_hasProd
211 E FiniteDimensional.finiteDimensional_subalgebra
212 E Set.iUnion_vadd_left_image
213 S SimpleGraph.edgeSet_ssubset_edgeSet
214 S isAtomic_iff_isCoatomic
215 E AlgebraicGeometry.isSurjectiveOnStalks_isLocalAtTarget
216 E hasGroupoid_continuousGroupoid
217 E SimpleGraph.Walk.reverse_singleton
218 S divp_assoc'
219 S Set.add_iUnion
220 S PiToModule.fromEnd_apply
221 E ContextFreeGrammar.derives_reverse_comm
222 E AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_compHom
223 E CochainComplex.HomComplex.Î´_comp_zero_cocycle
224 E NumberField.mixedEmbedding.instIsZLatticeRealMixedSpaceIntegerLattice
225 S addEquivOfAddOrderOfEq.proof_1
226 S kstar_mul_kstar
227 S Real.rpow_eq_zero
228 E MvPowerSeries.coeff_mul_left_one_sub_of_lt_weightedOrder
229 S CategoryTheory.Arrow.w_mk_right_assoc
230 S CommRingCat.isLocalRingHom_comp
231 E Nat.eq_of_dvd_of_lt_two_mul
232 E Finsupp.Lex.single_strictAnti
233 S neg_iff_neg_of_mul_pos
234 E Derivation.coe_neg
235 E Quotient.finChoiceEquiv_symm_apply
236 S Filter.add_neBot_iff
237 E Filter.cocardinal_aleph0_eq_cofinite
238 S ContDiffAt.snd
239 E stdSimplex_unique
240 E Matrix.UnitaryGroup.star_mul_self
241 S List.find?_replicate_of_neg
242 E covBy_iff_wcovBy_and_ne
243 E MeasureTheory.toReal_laverage
244 E CofiniteTopology.nhds_eq
245 E ENat.one_lt_card_iff_nontrivial
246 E SetTheory.PGame.lf_of_le_moveLeft
247 S Finset.sdiff_empty
248 E Vector.continuous_insertIdx'
249 E Polynomial.nontrivial_iff
250 E AlgebraicGeometry.AffineScheme.Î“_preservesLimits
251 S Int.fract_sub_self
252 E OrderIso.bddBelow_image
253 S ContinuousMap.comp_id
254 E MvPolynomial.joinâ‚‚_comp_map
255 E CircleDeg1Lift.map_sub_int
256 S Polynomial.natDegree_hermite
257 E Monotone.map_sInf_of_continuousAt
258 E MemHolder.nnHolderNorm_nsmul
259 S Int.lt.intro
260 S IsOpen.mul_left
261 E MulAction.IsBlock.empty
262 E MonoidAlgebra.opRingEquiv_single
263 E TwoSidedIdeal.mem_ker
264 E CategoryTheory.GradedObject.Î¹_mapBifunctorAssociator_inv
265 E AddSubmonoid.toAddZeroClass.proof_1
266 S List.subset_append_of_subset_left
267 E CompHausLike.instHasPropSigma
268 E tsupport_smul_subset_right
269 S NONote.NF
270 E Primrec.cond
271 E Submodule.Quotient.equiv_apply
272 E BitVec.neg_neg
273 S List.finRange_zero
274 S Finset.sups_nonempty
275 S Ordnode.Valid.merge
276 E SzemerediRegularity.increment_isEquipartition
277 E ChainComplex.quasiIsoAtâ‚€_iff
278 S Vector.indexOf?_mk
279 S UpperSet.coe_compl
280 E Equiv.Perm.IsCycle.support_pow_eq_iff
281 E joinM_map_map
282 S Filter.ZeroAtFilter.neg
283 E Nimber.add_nat
284 E Grp.FilteredColimits.forgetâ‚‚Mon_preservesFilteredColimits
285 E Auto.Embedding.Lam.LamBaseSort.eq_of_beq_eq_true
286 S HahnSeries.isWF_support
287 E PrimeSpectrum.localization_away_comap_range
288 S AddSubgroup.map.proof_2
289 E Small.trans_univLE
290 S ContinuousMap.addUnitsLift_symm_apply_apply_neg'
291 S CategoryTheory.ShortComplex.SnakeInput.id_fâ‚
292 E TensorProduct.piScalarRight_apply
293 S RootPairing.reflection_perm_involutive
294 E Set.instLawfulMonad
295 S decide_True'
296 E LSeries.abscissaOfAbsConv_one
297 E isLittleO_pow_pow_of_lt_left
298 E Ordinal.iSup_lt_lift
299 S SeparationQuotient.inducing_mk
300 S div_two_sub_self
301 S aestronglyMeasurable_lineDeriv_uncurry
302 S Int.Prime.dvd_pow'
303 E Filter.blimsup_not_sup
304 S Coheyting.boundary_inf_le
305 E CategoryTheory.IsFiltered.coeqâ‚ƒ_conditionâ‚
306 S disjoint_compl_right
307 S Heyting.Regular.coe_sdiff
308 E CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_isAddCommGroup
309 S Polynomial.Chebyshev.aeval_U
310 E lipschitzExtensionConstant_def
311 S SubMulAction.coe_copy
312 E Cardinal.mul_eq_max'
313 S AlgHom.val_comp_codRestrict
314 S CStarRing.norm_one
315 E Cardinal.mk_ne_zero_iff
316 E Fin.Ioi_zero_eq_map
317 E exists_mem_frontier_infDist_compl_eq_dist
318 E Filter.Tendsto.max
319 E List.Pi.forall_rel_cons_ext
320 S WithBot.toDual_lt_toDual_iff
321 E Nat.Partrec.Code.fixed_point
322 E IsAddQuantale.add_bot
323 E CategoryTheory.Equivalence.pi_functor
324 S Matroid.Matroidáµ£.coe_inj
325 E CategoryTheory.ShortComplex.LeftHomologyData.f'_i_assoc
326 S AddSubgroup.isComplement'_comm
327 E Equiv.mul_swap_involutive
328 S AddMonoid.not_isTorsion_iff
329 S Set.mem_iInter_of_mem
330 E FirstOrder.Language.LHom.id_onTerm
331 S Mod_.hom_ext
332 E Matrix.permanent_zero
333 S Ideal.radical_eq_iff
334 E NonemptyInterval.coe_pure
335 E exists_Ioo_extr_on_Icc
336 S PrimeSpectrum.comap_basicOpen
337 E CategoryTheory.HasExactLimitsOfShape.of_codomain_equivalence
338 E IsCyclotomicExtension.Rat.absdiscr_prime
339 E span_gramSchmidt_Iio
340 E Equiv.continuous_symm_iff
341 S SimpleGraph.instInhabited_default
342 E Nat.exists_not_and_succ_of_not_zero_of_exists
343 E ConvexOn.le_left_of_right_le'
344 S NormedAddGroupHom.Equalizer.Î¹_comp_lift
345 S CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_functor
346 E CategoryTheory.Limits.instEpiFactorThruImageOfHasLimitWalkingParallelPairParallelPair
347 E Submonoid.unop_closure
348 E Pi.ringHom_apply
349 E ProbabilityTheory.Kernel.indepSet_zero_right
350 S InnerProductSpace.Core.sqrt_normSq_eq_norm
351 E Cardinal.natCast_le_toENat_iff
352 S AddSubsemigroup.mem_comap
353 S Equiv.prodAssoc_symm_apply
354 S Prop.exists_iff
355 E AntitoneOn.map_bddAbove
356 E add_sSup_distrib
357 E AddChar.sum_apply_eq_ite
358 E DualNumber.exp_smul_eps
359 S QuaternionAlgebra.Basis.liftHom_apply
360 E EReal.inductionâ‚‚
361 S intervalIntegral.deriv_integral_right
362 S Finset.compls_subset_compls
363 S Sbtw.oangle_eq_right
364 E CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_i
365 E UV.disjoint_of_mem_compression_of_not_mem
366 S CategoryTheory.StructuredArrow.post_obj
367 E Equiv.Perm.VectorsProdEqOne.rotate_zero
368 E TrivSqZeroExt.instTopologicalRingOfTopologicalAddGroupOfContinuousSMulMulOpposite
369 S LipschitzWith.dist_right
370 S Set.Finite.powerset
371 S contDiff_iff_forall_nat_le
372 S CategoryTheory.Limits.compReflectsLimitsOfShape
373 E SimpleGraph.IsNClique.insert
374 E DilationEquiv.ratio_zpow
375 S instIsSuccArchimedeanMultiplicative
376 E Stream'.WSeq.liftRel_append
377 E TopologicalSpace.isTopologicalBasis_of_subbasis_of_inter
378 E LieSubmodule.le_normalizer
379 E List.exists_of_mem_keys
380 E AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq
381 S AffineEquiv.pointReflection_apply
382 S RCLike.nonpos_iff_exists_ofReal
383 E generateFrom_iUnion
384 E CategoryTheory.Adjunction.counit_epi_of_R_faithful
385 E ContinuousSup.measurableSupâ‚‚
386 S BoxIntegral.TaggedPrepartition.unionComplToSubordinate_boxes
387 E CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom'_assoc
388 E SpectrumRestricts.nnreal_iff_spectralRadius_le
389 E Real.sin_nat_mul_pi_sub
390 E IsNonarchimedean.multiset_image_add
391 S DirectSum.of_eq_of_gradedMonoid_eq
392 E IsMinOn.of_isLocalMinOn_of_convexOn
393 S List.mapâ‚‚Right'_nil_right
394 E Set.mulIndicator_one_preimage
395 E strictAntiOn_of_add_one_lt
396 S orderOf_eq_prime
397 E Polynomial.leadingCoeff_det_X_one_add_C
398 S Quaternion.normSq_coe
399 S Ideal.comap_comap
400 S MulHom.srange_top_of_surjective
401 S ContinuousLinearMap.proj_apply
402 S Order.Ioo_succ_right
403 E Sym2.GameAdd.fix_eq
404 E UniqueSums.of_same
405 S FreeAbelianGroup.add_bind
406 E CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_snd_assoc
407 E ENNReal.log_strictMono
408 E OrderMonoidHom.copy_eq
409 E LowerSemicontinuous.add'
410 S Vector.continuous_insertNth
411 E RatFunc.algebraMap_apply_div
412 E CategoryTheory.braiding_inv_apply
413 E instOrderedSubPrimeMultiset
414 E IntermediateField.map_le_iff_le_comap
415 S CategoryTheory.Functor.mapTriangle_map_homâ‚
416 E ZNum.cmp_to_int
417 E isLocalHomeomorphOn_iff_isOpenEmbedding_restrict
418 S Commute.invOf_left
419 E Rat.canLift
420 E Subring.mem_pointwise_smul_iff_inv_smul_mem
421 E AddSubgroup.card_dvd_of_surjective
422 S Subalgebra.topologicalClosure_minimal
423 E Valuation.isEquiv_iff_val_eq_one
424 E WeierstrassCurve.ofJ0_câ‚„
425 E CategoryTheory.Limits.id_preservesColimitsOfSize
426 S Finsupp.sumFinsuppAddEquivProdFinsupp_apply
427 E WithBot.unbot_coe
428 E Normal.minpoly_eq_iff_mem_orbit
429 S HahnSeries.SummableFamily.ext
430 S Bool.cond_pos
431 S AddUnits.neg_add_eq_iff_eq_add
432 E Polynomial.isRoot_cyclotomic_iff
433 S SimplexCategory.Truncated.instFullInclusion
434 E Ordinal.nfp_le_fp
435 E List.length_eraseP_add_one
436 S BitVec.eq_sub_iff_add_eq
437 S EuclideanGeometry.collinear_of_angle_eq_zero
438 E MeasureTheory.Measure.instNeZeroOfNonempty
439 E AddAction.IsFixedBlock.univ
440 E FreeGroup.invRev_involutive
441 E CategoryTheory.Adjunction.unit_rightAdjointUniq_hom_app_assoc
442 E Nat.Primes.coe_nat_injective
443 E Affine.Simplex.circumcenter_eq_affineCombination_of_pointsWithCircumcenter
444 E covBy_iff_lt_covBy_grade
445 E List.range'_subset_right_1
446 E AffineSubspace.SSameSide.trans
447 E Finset.dens_lt_dens
448 S Submonoid.closure_eq_of_le
449 E SetLike.prod_mem_graded
450 E Pi.mulSupport_mulSingle_one
451 S CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition
452 S RCLike.nonneg_iff
453 E Finset.sup'_mono
454 S WithBot.zero_ne_bot
455 E IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow
456 S TopHom.comp_apply
457 E Basis.finTwoProd_zero
458 E Set.piecewise_neg
459 E CategoryTheory.Adjunction.toEquivalence_inverse
460 S Units.val_inv_ofPowEqOne
461 E EMetric.diam_closedBall
462 E minpoly.coeff_zero_eq_zero
463 E Set.bijOn_iInter
464 E Module.End.HasUnifEigenvalue.lt
465 E CategoryTheory.Comonad.ComonadicityInternal.main_pair_F_cosplit
466 E AddSubgroup.map_eq_bot_iff
467 E CategoryTheory.hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete
468 E NumberField.mixedEmbedding.fundamentalCone.normAtPlace_pos_of_mem
469 S Filter.disjoint_cocompact_left
470 E List.dlookup_kerase_ne
471 E iteratedFDerivWithin_comp_add_left'
472 E MonotoneOn.Ioc
473 E AlgebraicGeometry.StructureSheaf.comap_const
474 S ContinuousLinearMap.restrictScalars_zero
475 E CategoryTheory.Limits.colimit.Î¹_pre
476 S Module.AEval'_def
477 E MeasureTheory.Measure.integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport
478 S Sublattice.mem_comap
479 S ContinuousAlgHom.uniformContinuous
480 S CategoryTheory.ShortComplex.rightHomologyFunctor_obj
481 E Opposite.equivToOpposite_symm_coe
482 S tendsto_nhdsWithin_iff
483 E Complex.integerComplement_eq
484 E CategoryTheory.Limits.hasImage_zero
485 S Std.DHashMap.getD_eq_fallback
486 S ULift.addRightCancelSemigroup.proof_2
487 E CategoryTheory.Functor.CoreMonoidal.Î¼Iso_hom_natural_right_assoc
488 E CircleDeg1Lift.translate_zpow
489 S TopologicalSpace.Compacts.equiv_symm
490 E OrderDual.instPosSMulReflectLE
491 E lowerClosure_vadd
492 S LTSeries.mk_length
493 S tendsto_neg_nhdsWithin_Iio
494 S Prod.instAddRightCancelMonoid.proof_5
495 E Set.pairwise_disjoint_Ioc_intCast
496 S CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_map
497 E CategoryTheory.Limits.MulticospanIndex.sndPiMap_Ï€_assoc
498 S LieEquiv.symm_trans
499 E Computable.option_bind
500 E tsum_setProd_singleton_left
501 E CategoryTheory.Comma.instIsIsoRight
502 E SemidirectProduct.map_comp_inr
503 E List.any_toArray'
504 E Batteries.HashMap.Imp.expand_size
505 E List.takeD_eq_take
506 E emultiplicity_mul
507 E Ordnode.findMin'_dual
508 S Submodule.map_coe
509 E CategoryTheory.skeletonEquivalence_unitIso
510 E LaurentSeries.tendsto_valuation
511 E Order.Ico_pred_right_eq_insert

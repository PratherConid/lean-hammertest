Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = native, logFile := evalOut.txt}

Testing || AEMeasurable.inf : âˆ€ {M : Type u_1} [inst : MeasurableSpace M] {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}
  {f g : Î± â†’ M} [inst_1 : Min M] [inst_2 : MeasurableInfâ‚‚ M],
  AEMeasurable f Î¼ â†’ AEMeasurable g Î¼ â†’ AEMeasurable (fun a => f a âŠ“ g a) Î¼
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Std.HashSet.getD_insert : âˆ€ {Î± : Type u} {x : BEq Î±} {x_1 : Hashable Î±} {m : Std.HashSet Î±} [inst : EquivBEq Î±] [inst : LawfulHashable Î±]
  {k a fallback : Î±}, (m.insert k).getD a fallback = if (k == a) = true âˆ§ k âˆ‰ m then k else m.getD a fallback
Result.autoException ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinOrd.Iso.mk_inv : âˆ€ {Î± Î² : LinOrd} (e : â†‘Î± â‰ƒo â†‘Î²), (LinOrd.Iso.mk e).inv = â†‘e.symm
Result.autoException ::
Duper saturated

Testing || List.sublistsLen_length : âˆ€ {Î± : Type u} (l : List Î±), List.sublistsLen l.length l = [l]
Result.autoException ::
Duper saturated

Testing || GenContFract.zeroth_contAux_eq_one_zero : âˆ€ {K : Type u_1} {g : GenContFract K} [inst : DivisionRing K], g.contsAux 0 = { a := 1, b := 0 }
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Stream' (GenContFract.Pair K) is not a `âˆ€`

Testing || Rat.cast_sub_of_ne_zero : âˆ€ {Î± : Type u_3} [inst : DivisionRing Î±] {p q : â„š}, â†‘p.den â‰  0 â†’ â†‘q.den â‰  0 â†’ â†‘(p - q) = â†‘p - â†‘q
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || _private.Mathlib.Combinatorics.SimpleGraph.Triangle.Counting.0.SimpleGraph.edgeDensity_badVertices_le : âˆ€ {Î± : Type u_1} (G : SimpleGraph Î±) [inst : DecidableRel G.Adj] {Îµ : â„} {s t : Finset Î±},
  0 â‰¤ Îµ â†’ 2 * Îµ â‰¤ â†‘(G.edgeDensity s t) â†’ â†‘(G.edgeDensity (SimpleGraph.badVertices G Îµ s t) t) â‰¤ â†‘(G.edgeDensity s t) - Îµ
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || _private.Mathlib.Combinatorics.Additive.SmallTripling.0.Finset.small_pos_neg_pos_add : âˆ€ {G : Type u_1} [inst : DecidableEq G] [inst_1 : AddGroup G] {A : Finset G} {K : â„},
  â†‘(3 â€¢ A).card â‰¤ K * â†‘A.card â†’ â†‘(A + -A + A).card â‰¤ K ^ 3 * â†‘A.card
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AddMonoid.exponent_pi_eq_zero : âˆ€ {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ AddMonoid (M i)] {j : Î¹},
  AddMonoid.exponent (M j) = 0 â†’ AddMonoid.exponent ((i : Î¹) â†’ M i) = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `n â€¢ g`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || isLUB_sSup : âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeSup Î±] (s : Set Î±), IsLUB s (sSup s)
Result.autoException ::
Duper saturated

Testing || Algebra.coe_sInf : âˆ€ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  (S : Set (Subalgebra R A)), â†‘(sInf S) = â‹‚ s âˆˆ S, â†‘s
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.image_mul_left_Ioo : âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±},
  0 < a â†’ âˆ€ (b c : Î±), (fun x => a * x) '' Set.Ioo b c = Set.Ioo (a * b) (a * c)
Result.autoException ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || FirstOrder.Language.ElementaryEmbedding.map_rel : âˆ€ {L : FirstOrder.Language} {M : Type u_1} {N : Type u_2} [inst : L.Structure M] [inst_1 : L.Structure N]
  (Ï† : L.ElementaryEmbedding M N) {n : â„•} (r : L.Relations n) (x : Fin n â†’ M),
  FirstOrder.Language.Structure.RelMap r (â‡‘Ï† âˆ˜ x) â†” FirstOrder.Language.Structure.RelMap r x
Result.autoException ::
Duper saturated

Testing || hnot_le_iff_codisjoint_left : âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] {a b : Î±}, ï¿¢a â‰¤ b â†” Codisjoint b a
Result.success

Testing || SemistandardYoungTableau.copy_eq : âˆ€ {Î¼ : YoungDiagram} (T : SemistandardYoungTableau Î¼) (entry' : â„• â†’ â„• â†’ â„•) (h : entry' = â‡‘T), T.copy entry' h = T
Result.autoException ::
Duper saturated

Testing || CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map' : âˆ€ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_3, u_2} D] {G : CategoryTheory.Functor C D} {A : Type w}
  [inst_2 : CategoryTheory.Category.{w', w} A] {J : CategoryTheory.GrothendieckTopology C}
  {K : CategoryTheory.GrothendieckTopology D} [inst_3 : G.IsCocontinuous J K] {F : CategoryTheory.Functor Cáµ’áµ– A}
  (hF : CategoryTheory.Presheaf.IsSheaf J F) {R : CategoryTheory.Functor Dáµ’áµ– A} (Î± : G.op.comp R âŸ¶ F) {X : D}
  {S : K.Cover X} (s : CategoryTheory.Limits.Multifork (S.index R)) {Y Y' : C} (f : G.obj Y âŸ¶ X) (f' : G.obj Y' âŸ¶ X)
  {W : C} (a : W âŸ¶ Y) (b : W âŸ¶ Y'),
  CategoryTheory.CategoryStruct.comp (G.map a) f = CategoryTheory.CategoryStruct.comp (G.map b) f' â†’
    CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Î± s f) (F.map a.op) =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Î± s f') (F.map b.op)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_29 x_0).map
  (cifvar_7 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || AlgebraicGeometry.Spec.toSheafedSpace_obj : âˆ€ (R : CommRingCatáµ’áµ–),
  AlgebraicGeometry.Spec.toSheafedSpace.obj R = AlgebraicGeometry.Spec.sheafedSpaceObj (Opposite.unop R)
Result.autoException ::
application type mismatch
  CommRingCat = Opposite.unop (Opposite.op (CategoryTheory.Bundled CommRing))
argument
  Opposite.unop (Opposite.op (CategoryTheory.Bundled CommRing))
has type
  CommRingCat : Type (u + 1)
but is expected to have type
  Type (u + 1) : Type (u + 2)

Testing || Set.image_preimage : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²}, GaloisConnection (Set.image f) (Set.preimage f)
Result.autoException ::
Duper saturated

Testing || deriv_sinh : âˆ€ {f : â„ â†’ â„} {x : â„}, DifferentiableAt â„ f x â†’ deriv (fun x => Real.sinh (f x)) x = Real.cosh (f x) * deriv f x
Result.success

Testing || WCovBy.le_of_lt : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b c : Î±}, a â©¿ b â†’ c < b â†’ c â‰¤ a
Result.autoException ::
Duper saturated

Testing || Bool.not_eq_not : âˆ€ {a b : Bool}, Â¬a = !b â†” a = b
Result.success

Testing || CategoryTheory.Limits.coneOfSectionCompYoneda_pt : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J : Type w} [inst_1 : CategoryTheory.Category.{t, w} J]
  (F : CategoryTheory.Functor J Cáµ’áµ–) (X : C) (s : â†‘(F.comp (CategoryTheory.yoneda.obj X)).sections),
  (CategoryTheory.Limits.coneOfSectionCompYoneda F X s).pt = Opposite.op X
Result.autoException ::
Duper saturated

Testing || WittVector.wittMul_vars : âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), (WittVector.wittMul p n).vars âŠ† Finset.univ Ã—Ë¢ Finset.range (n + 1)
Result.autoException ::
Duper saturated

Testing || Real.borel_eq_generateFrom_Ioi_rat : borel â„ = MeasurableSpace.generateFrom (â‹ƒ a, {Set.Ioi â†‘a})
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x âˆˆ x_0 of Î» binder contains bound variables

Testing || HomologicalComplexâ‚‚.comm_f : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {Iâ‚ : Type u_2} {Iâ‚‚ : Type u_3} {câ‚ : ComplexShape Iâ‚} {câ‚‚ : ComplexShape Iâ‚‚} {K L : HomologicalComplexâ‚‚ C câ‚ câ‚‚}
  (f : K âŸ¶ L) (iâ‚ iâ‚' : Iâ‚) (iâ‚‚ : Iâ‚‚),
  CategoryTheory.CategoryStruct.comp ((f.f iâ‚).f iâ‚‚) ((L.d iâ‚ iâ‚').f iâ‚‚) =
    CategoryTheory.CategoryStruct.comp ((K.d iâ‚ iâ‚').f iâ‚‚) ((f.f iâ‚').f iâ‚‚)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_17.d cifvar_16 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Asymptotics.IsBigO.comp_tendsto : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : Î± â†’ E} {g : Î± â†’ F}
  {l : Filter Î±}, f =O[l] g â†’ âˆ€ {k : Î² â†’ Î±} {l' : Filter Î²}, Filter.Tendsto k l' l â†’ (f âˆ˜ k) =O[l'] (g âˆ˜ k)
Result.success

Testing || Filter.Tendsto.cexp : âˆ€ {Î± : Type u_1} {l : Filter Î±} {f : Î± â†’ â„‚} {z : â„‚},
  Filter.Tendsto f l (nhds z) â†’ Filter.Tendsto (fun x => Complex.exp (f x)) l (nhds (Complex.exp z))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `nhds x`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || IsLocalizedModule.fromLocalizedModule'_add : âˆ€ {R : Type u_1} [inst : CommSemiring R] (S : Submonoid R) {M : Type u_2} {M' : Type u_3} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M'] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M'] (f : M â†’â‚—[R] M')
  [inst_5 : IsLocalizedModule S f] (x y : LocalizedModule S M),
  IsLocalizedModule.fromLocalizedModule' S f (x + y) =
    IsLocalizedModule.fromLocalizedModule' S f x + IsLocalizedModule.fromLocalizedModule' S f y
Result.autoException ::
Duper saturated

Testing || AffineSubspace.affineSpan_coe : âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s
Result.autoException ::
Duper saturated

Testing || ENat.mem_nhds_natCast_iff : âˆ€ (n : â„•) {s : Set â„•âˆ}, s âˆˆ nhds â†‘n â†” â†‘n âˆˆ s
Result.success

Testing || HasProd.div : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : CommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalGroup Î±]
  {f g : Î² â†’ Î±} {aâ‚ aâ‚‚ : Î±}, HasProd f aâ‚ â†’ HasProd g aâ‚‚ â†’ HasProd (fun b => f b / g b) (aâ‚ / aâ‚‚)
Result.success

Testing || IsLocalization.coeSubmodule_fg : âˆ€ {R : Type u_1} [inst : CommSemiring R] (S : Type u_2) [inst_1 : CommSemiring S] [inst_2 : Algebra R S],
  Function.Injective â‡‘(algebraMap R S) â†’ âˆ€ (I : Ideal R), (IsLocalization.coeSubmodule S I).FG â†” Submodule.FG I
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.IsPullback.of_right : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚}
  {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ},
  CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp hâ‚â‚ hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ
      (CategoryTheory.CategoryStruct.comp hâ‚‚â‚ hâ‚‚â‚‚) â†’
    CategoryTheory.CategoryStruct.comp hâ‚â‚ vâ‚â‚‚ = CategoryTheory.CategoryStruct.comp vâ‚â‚ hâ‚‚â‚ â†’
      CategoryTheory.IsPullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚ â†’ CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Nat.nonempty_properDivisors : âˆ€ {n : â„•}, n.properDivisors.Nonempty â†” 1 < n
Result.autoException ::
Duper saturated

Testing || RingEquiv.map_prod : âˆ€ {Î± : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommSemiring R] [inst_1 : CommSemiring S] (g : R â‰ƒ+* S)
  (f : Î± â†’ R) (s : Finset Î±), g (âˆ x âˆˆ s, f x) = âˆ x âˆˆ s, g (f x)
Result.success

Testing || dist_smul : âˆ€ {M : Type u} {X : Type w} [inst : PseudoMetricSpace X] [inst_1 : SMul M X] [inst_2 : IsometricSMul M X] (c : M)
  (x y : X), dist (c â€¢ x) (c â€¢ y) = dist x y
Result.success

Testing || map_mul_right_nhdsâ‚€ : âˆ€ {Gâ‚€ : Type u_3} [inst : TopologicalSpace Gâ‚€] [inst_1 : GroupWithZero Gâ‚€] [inst_2 : ContinuousMul Gâ‚€] {a : Gâ‚€},
  a â‰  0 â†’ âˆ€ (b : Gâ‚€), Filter.map (fun x => x * a) (nhds b) = nhds (b * a)
Result.autoException ::
Duper saturated

Testing || Nat.find_le : âˆ€ {n : â„•} {p : â„• â†’ Prop} [inst : DecidablePred p] {h : âˆƒ n, p n}, p n â†’ Nat.find h â‰¤ n
Result.autoException ::
Duper saturated

Testing || Finset.subset_mul_left : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : MulOneClass Î±] (s : Finset Î±) {t : Finset Î±}, 1 âˆˆ t â†’ s âŠ† s * t
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.decidableEq b`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || IterateAddAct.ext : âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x y : IterateAddAct f}, x.val = y.val â†’ x = y
Result.autoException ::
application type mismatch
  x = { val := x }.val
argument
  { val := x }.val
has type
  â„• : Type
but is expected to have type
  IterateAddAct f : Type

Testing || Mathlib.Vector.mem_cons_of_mem : âˆ€ {Î± : Type u_1} {n : â„•} (a a' : Î±) (v : Mathlib.Vector Î± n), a' âˆˆ v.toList â†’ a' âˆˆ (a ::áµ¥ v).toList
Result.success

Testing || Measurable.set_lintegral_kernel : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Îº : ProbabilityTheory.Kernel Î± Î²}
  [inst : ProbabilityTheory.IsSFiniteKernel Îº] {f : Î² â†’ ENNReal},
  Measurable f â†’ âˆ€ {s : Set Î²}, MeasurableSet s â†’ Measurable fun a => âˆ«â» (b : Î²) in s, f b âˆ‚Îº a
Result.success

Testing || Nat.dvd_zero : âˆ€ (a : â„•), a âˆ£ 0
Result.autoException ::
Duper saturated

Testing || Function.Embedding.toEquivRange_symm_apply_self : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Fintype Î±] [inst_1 : DecidableEq Î²] (f : Î± â†ª Î²) (a : Î±),
  f.toEquivRange.symm âŸ¨f a, â‹¯âŸ© = a
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Matrix.star_dotProduct_star : âˆ€ {m : Type u_2} {Î± : Type v} [inst : Fintype m] [inst_1 : NonUnitalSemiring Î±] [inst_2 : StarRing Î±] (v w : m â†’ Î±),
  Matrix.dotProduct (star v) (star w) = star (Matrix.dotProduct w v)
Result.autoException ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.singleton_infs_singleton : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : SemilatticeInf Î±] {a b : Î±}, {a} âŠ¼ {b} = {a âŠ“ b}
Result.success

Testing || IsConjRoot.isIntegral : âˆ€ {R : Type u_1} {A : Type u_5} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] {x y : A},
  IsIntegral R x â†’ IsConjRoot R x y â†’ IsIntegral R y
Result.autoException ::
Duper saturated

Testing || SimpleGraph.Walk.transfer_transfer : âˆ€ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : âˆ€ e âˆˆ p.edges, e âˆˆ H.edgeSet)
  {K : SimpleGraph V} (hp' : âˆ€ e âˆˆ (p.transfer H hp).edges, e âˆˆ K.edgeSet),
  (p.transfer H hp).transfer K hp' = p.transfer K â‹¯
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type (p.transfer H hp).edges =
  xâœ of Î» binder contains bound variables

Testing || CategoryTheory.ofTypeMonad_Î¼_app : âˆ€ (m : Type u â†’ Type u) [inst : Monad m] [inst_1 : LawfulMonad m] {Î± : Type u} (a : m (m Î±)),
  (CategoryTheory.ofTypeMonad m).Î¼.app Î± a = joinM a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: ((CategoryTheory.ofTypeMonad m).comp
        (CategoryTheory.ofTypeMonad m).toFunctor).obj
    Î± âŸ¶
  (CategoryTheory.ofTypeMonad m).obj Î± is not a `âˆ€`

Testing || measure_Ioc_lt_top : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : CompactIccSpace Î±] {m : MeasurableSpace Î±}
  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {a b : Î±}, Î¼ (Set.Ioc a b) < âŠ¤
Result.success

Testing || List.takeDTR_go_eq : âˆ€ {Î± : Type u_1} {dflt : Î±} {acc : Array Î±} (n : â„•) (l : List Î±),
  List.takeDTR.go dflt n l acc = acc.toList ++ List.takeD n l dflt
Result.autoException ::
application type mismatch
  dflt = { toList := dflt }.toList
argument
  { toList := dflt }.toList
has type
  List Î±âœ : Type u_1
but is expected to have type
  Î±âœ : Type u_1

Testing || Symmetric.iff : âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Symmetric r â†’ âˆ€ (x y : Î±), r x y â†” r y x
Result.autoException ::
Duper saturated

Testing || LieModuleEquiv.symm_apply_apply : âˆ€ {R : Type u} {L : Type v} {M : Type w} {N : Type wâ‚} [inst : CommRing R] [inst_1 : LieRing L]
  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R N]
  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (e : M â‰ƒâ‚—â…R,Lâ† N) (x : M), e.symm (e x) = x
Result.autoException ::
Duper saturated

Testing || AffineIndependent.mem_affineSpan_iff : âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [inst_3 : AddTorsor V P] {Î¹ : Type u_4} [inst_4 : Nontrivial k] {p : Î¹ â†’ P},
  AffineIndependent k p â†’ âˆ€ (i : Î¹) (s : Set Î¹), p i âˆˆ affineSpan k (p '' s) â†” i âˆˆ s
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (#1 â†’ Prop), ((âˆƒx1 : #1, x0 x1) = (!19 x0))) is not type correct

Testing || CategoryTheory.ofTypeMonad_obj : âˆ€ (m : Type u â†’ Type u) [inst : Monad m] [inst_1 : LawfulMonad m] (a : Type u),
  (CategoryTheory.ofTypeMonad m).obj a = m a
Result.autoException ::
Duper saturated

Testing || Set.center_eq_univ : âˆ€ (M : Type u_1) [inst : CommSemigroup M], Set.center M = Set.univ
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearIsometryEquiv.differentiableOn : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {s : Set E}
  (iso : E â‰ƒâ‚—áµ¢[ğ•œ] F), DifferentiableOn ğ•œ (â‡‘iso) s
Result.success

Testing || TwoUniqueSums.of_addHom : âˆ€ {G : Type u} {H : Type v} [inst : Add G] [inst_1 : Add H] (f : H â†’â‚™+ G),
  (âˆ€ â¦ƒa b c d : Hâ¦„, a + b = c + d â†’ f a = f c âˆ§ f b = f d â†’ a = c âˆ§ b = d) â†’ âˆ€ [inst : TwoUniqueSums G], TwoUniqueSums H
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image (cifvar_3 x_5) x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || SimpleGraph.Walk.map_toDeleteEdges_eq : âˆ€ {V : Type u} {G : SimpleGraph V} {v w : V} (s : Set (Sym2 V)) {p : G.Walk v w} (hp : âˆ€ e âˆˆ p.edges, e âˆ‰ s),
  SimpleGraph.Walk.map (SimpleGraph.Hom.mapSpanningSubgraphs â‹¯) (SimpleGraph.Walk.toDeleteEdges s p hp) = p
Result.autoException ::
Duper saturated

Testing || LinearEquiv.symm_apply_apply : âˆ€ {R : Type u_1} {S : Type u_5} {M : Type u_6} {Mâ‚‚ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] {module_M : _root_.Module R M}
  {module_S_Mâ‚‚ : _root_.Module S Mâ‚‚} {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} {reâ‚ : RingHomInvPair Ïƒ Ïƒ'}
  {reâ‚‚ : RingHomInvPair Ïƒ' Ïƒ} (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) (b : M), e.symm (e b) = b
Result.autoException ::
Duper saturated

Testing || Valuation.IsEquiv.ne_zero : âˆ€ {R : Type u_3} {Î“â‚€ : Type u_4} {Î“'â‚€ : Type u_5} [inst : Ring R] [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]
  [inst_2 : LinearOrderedCommMonoidWithZero Î“'â‚€] {vâ‚ : Valuation R Î“â‚€} {vâ‚‚ : Valuation R Î“'â‚€},
  vâ‚.IsEquiv vâ‚‚ â†’ âˆ€ {r : R}, vâ‚ r â‰  0 â†” vâ‚‚ r â‰  0
Result.success

Testing || List.pwFilter_map : âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {Î² : Type u_2} [inst : DecidableRel R] (f : Î² â†’ Î±) (l : List Î²),
  List.pwFilter R (List.map f l) = List.map f (List.pwFilter (fun x y => R (f x) (f y)) l)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Relator.RightUnique.forallâ‚‚ : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {R : Î± â†’ Î² â†’ Prop}, Relator.RightUnique R â†’ Relator.RightUnique (List.Forallâ‚‚ R)
Result.autoException ::
Duper saturated

Testing || CFC.quasispectrum_zero_eq : âˆ€ {R : Type u_1} {A : Type u_2} {p : A â†’ Prop} [inst : CommSemiring R] [inst_1 : Nontrivial R] [inst_2 : StarRing R]
  [inst_3 : MetricSpace R] [inst_4 : TopologicalSemiring R] [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A]
  [inst_7 : StarRing A] [inst_8 : TopologicalSpace A] [inst_9 : _root_.Module R A] [inst_10 : IsScalarTower R A A]
  [inst_11 : SMulCommClass R A A] [instCFCâ‚™ : NonUnitalContinuousFunctionalCalculus R p], quasispectrum R 0 = {0}
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || taylor_mean_remainder_cauchy : âˆ€ {f : â„ â†’ â„} {x xâ‚€ : â„} {n : â„•},
  xâ‚€ < x â†’
    ContDiffOn â„ (â†‘n) f (Set.Icc xâ‚€ x) â†’
      DifferentiableOn â„ (iteratedDerivWithin n f (Set.Icc xâ‚€ x)) (Set.Ioo xâ‚€ x) â†’
        âˆƒ x' âˆˆ Set.Ioo xâ‚€ x,
          f x - taylorWithinEval f n (Set.Icc xâ‚€ x) xâ‚€ x =
            iteratedDerivWithin (n + 1) f (Set.Icc xâ‚€ x) x' * (x - x') ^ n / â†‘n.factorial * (x - xâ‚€)
Result.autoException ::
(deterministic) timeout at `Â«forward demodulationÂ»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Idempotents.DoldKan.N_obj : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.IsIdempotentComplete C] [inst_3 : CategoryTheory.Limits.HasFiniteCoproducts C]
  (X : CategoryTheory.SimplicialObject C),
  CategoryTheory.Idempotents.DoldKan.N.obj X =
    (CategoryTheory.Idempotents.toKaroubiEquivalence (ChainComplex C â„•)).inverse.obj
      (AlgebraicTopology.DoldKan.Nâ‚.obj X)
Result.autoException ::
Duper saturated

Testing || HomogeneousLocalization.val_zsmul : âˆ€ {Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]
  {ğ’œ : Î¹ â†’ Submodule R A} (x : Submonoid A) (n : â„¤) (y : HomogeneousLocalization ğ’œ x), (n â€¢ y).val = n â€¢ y.val
Result.success

Testing || Filter.NeBot.mul_zero_nonneg : âˆ€ {Î± : Type u_2} [inst : MulZeroClass Î±] {f : Filter Î±}, f.NeBot â†’ 0 â‰¤ f * 0
Result.autoException ::
Duper saturated

Testing || sdiff_sdiff : âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] (a b c : Î±), (a \ b) \ c = a \ (b âŠ” c)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Rat.ofInt_eq_cast : âˆ€ (n : â„¤), Rat.ofInt n = â†‘n
Result.success

Testing || QPF.Fix.ind_rec : âˆ€ {F : Type u â†’ Type u} [q : QPF F] {Î± : Type u} (gâ‚ gâ‚‚ : QPF.Fix F â†’ Î±),
  (âˆ€ (x : F (QPF.Fix F)), gâ‚ <$> x = gâ‚‚ <$> x â†’ gâ‚ (QPF.Fix.mk x) = gâ‚‚ (QPF.Fix.mk x)) â†’ âˆ€ (x : QPF.Fix F), gâ‚ x = gâ‚‚ x
Result.autoException ::
Duper saturated

Testing || Polynomial.eval_one_cyclotomic_not_prime_pow : âˆ€ {R : Type u_1} [inst : Ring R] {n : â„•},
  (âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (k : â„•), p ^ k â‰  n) â†’ Polynomial.eval 1 (Polynomial.cyclotomic n R) = 1
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Decidable
  (Â¬p = 1 âˆ§ 0 < n) of Î» binder contains bound variables

Testing || leibniz_cross : âˆ€ {R : Type u_1} [inst : CommRing R] (u v w : Fin 3 â†’ R),
  (crossProduct u) ((crossProduct v) w) = (crossProduct ((crossProduct u) v)) w + (crossProduct v) ((crossProduct u) w)
Result.autoException ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Real.one_sub_le_exp_neg : âˆ€ (x : â„), 1 - x â‰¤ Real.exp (-x)
Result.success

Testing || Monovary.sum_smul_comp_perm_le_sum_smul : âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : LinearOrderedSemiring Î±] [inst_1 : ExistsAddOfLE Î±]
  [inst_2 : LinearOrderedCancelAddCommMonoid Î²] [inst_3 : _root_.Module Î± Î²] [inst_4 : PosSMulMono Î± Î²]
  {Ïƒ : Equiv.Perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [inst_5 : Fintype Î¹],
  Monovary f g â†’ âˆ‘ i : Î¹, f i â€¢ g (Ïƒ i) â‰¤ âˆ‘ i : Î¹, f i â€¢ g i
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : (#0 â†’ #1), (âˆ€ x1 : (#0 â†’ #2), (âˆ€ x2 : #5, ((!11 x0 x1 x2) = (!13 x2 (Î»x3 : #0, (âˆ€ x4 : #0, ((!16 x2 x4) â†’ ((!17 (x1 x3) (x1 x4)) â†’ (!18 (x0 x3) (x0 x4))))))))))) is not type correct

Testing || IndexedPartition.disjoint : âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±}, IndexedPartition s â†’ Pairwise (Disjoint on s)
Result.autoException ::
Duper saturated

Testing || isConjRoot_iff_mem_minpoly_rootSet : âˆ€ {K : Type u_2} {S : Type u_4} [inst : CommRing S] [inst_1 : Field K] [inst_2 : Algebra K S] [inst_3 : IsDomain S]
  {x y : S}, IsIntegral K x â†’ (IsConjRoot K x y â†” y âˆˆ (minpoly K x).rootSet S)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_2.toFinset`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || List.Perm.eraseP : âˆ€ {Î± : Type u_1} (f : Î± â†’ Bool) {lâ‚ lâ‚‚ : List Î±},
  List.Pairwise (fun a b => f a = true â†’ f b = true â†’ False) lâ‚ â†’
    lâ‚.Perm lâ‚‚ â†’ (List.eraseP f lâ‚).Perm (List.eraseP f lâ‚‚)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Fin.appendIsometry_symm_apply : âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] (m n : â„•) (f : Fin (m + n) â†’ Î±),
  (Fin.appendIsometry m n).symm f = (fun i => f (Fin.castAdd n i), fun i => f (Fin.natAdd m i))
Result.autoException ::
Duper saturated

Testing || AddUnits.addRight_bijective : âˆ€ {M : Type u_3} [inst : AddMonoid M] (a : AddUnits M), Function.Bijective fun x => x + â†‘a
Result.autoException ::
Duper saturated

Testing || SimpleGraph.Walk.length_transfer : âˆ€ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : âˆ€ e âˆˆ p.edges, e âˆˆ H.edgeSet),
  (p.transfer H hp).length = p.length
Result.autoException ::
Duper saturated

Testing || CliffordAlgebra.forall_mul_self_eq_iff : âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {Q : QuadraticForm R M} {A : Type u_4} [inst_3 : Ring A] [inst_4 : Algebra R A],
  IsUnit 2 â†’
    âˆ€ (f : M â†’â‚—[R] A),
      (âˆ€ (x : M), f x * f x = (algebraMap R A) (Q x)) â†”
        (LinearMap.mul R A).complâ‚‚ f âˆ˜â‚— f + (LinearMap.mul R A).flip.complâ‚‚ f âˆ˜â‚— f =
          LinearMap.comprâ‚‚ (QuadraticMap.polarBilin Q) (Algebra.linearMap R A)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Topology.IsQuotientMap.image_connectedComponent : âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},
  Topology.IsQuotientMap f â†’
    (âˆ€ (y : Î²), IsConnected (f â»Â¹' {y})) â†’ âˆ€ (a : Î±), f '' connectedComponent a = connectedComponent (f a)
Result.success

Testing || isPiSystem_iUnion_of_monotone : âˆ€ {Î± : Type u_3} {Î¹ : Type u_4} [inst : SemilatticeSup Î¹] (p : Î¹ â†’ Set (Set Î±)),
  (âˆ€ (n : Î¹), IsPiSystem (p n)) â†’ Monotone p â†’ IsPiSystem (â‹ƒ n, p n)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, ((!0 x0) = (!5 x0 (Î»x1 : #2, (âˆ€ x2 : #2, ((!14 x0 x2) â†’ ((!15 (!16 x1 x2)) â†’ (!14 x0 (!16 x1 x2))))))))) is not type correct

Testing || Setoid.eq_of_mem_eqv_class : âˆ€ {Î± : Type u_1} {c : Set (Set Î±)},
  (âˆ€ (a : Î±), âˆƒ! b, b âˆˆ c âˆ§ a âˆˆ b) â†’ âˆ€ {x : Î±} {b b' : Set Î±}, b âˆˆ c â†’ x âˆˆ b â†’ b' âˆˆ c â†’ x âˆˆ b' â†’ b = b'
Result.success

Testing || univLE_max : UnivLE.{u, max u v}
Result.autoException ::
Duper saturated

Testing || hasLineDerivAt_zero : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {F : Type u_2} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ğ•œ F] {E : Type u_3} [inst_3 : AddCommGroup E] [inst_4 : _root_.Module ğ•œ E] {f : E â†’ F} {x : E},
  HasLineDerivAt ğ•œ f 0 x 0
Result.autoException ::
Duper saturated

Testing || Complex.polarCoord_apply : âˆ€ (a : â„‚), â†‘Complex.polarCoord a = (Complex.abs a, a.arg)
Result.autoException ::
Duper saturated

Testing || Complex.cosh_sub : âˆ€ (x y : â„‚), Complex.cosh (x - y) = Complex.cosh x * Complex.cosh y - Complex.sinh x * Complex.sinh y
Result.success

Testing || MeasureTheory.Measure.restrict_apply' : âˆ€ {Î± : Type u_2} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},
  MeasurableSet s â†’ (Î¼.restrict s) t = Î¼ (t âˆ© s)
Result.success

Testing || Inseparable.mem_open_iff : âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X} {s : Set X}, Inseparable x y â†’ IsOpen s â†’ (x âˆˆ s â†” y âˆˆ s)
Result.success

Testing || CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_base : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor C CategoryTheory.Cat)
  {X Y : CategoryTheory.Grothendieck F} (f : X âŸ¶ Y),
  ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).map f).base = f.base
Result.autoException ::
Duper saturated

Testing || UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors : âˆ€ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R]
  [inst_2 : NormalizationMonoid R] {x : R},
  x â‰  0 â†’ (Squarefree x â†” (UniqueFactorizationMonoid.normalizedFactors x).Nodup)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Multiset.count a x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || ContDiffAt.prod_map : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {n : WithTop â„•âˆ}
  {E' : Type u_3} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace ğ•œ E'] {F' : Type u_4}
  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace ğ•œ F'] {f : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'},
  ContDiffAt ğ•œ n f x â†’ ContDiffAt ğ•œ n g y â†’ ContDiffAt ğ•œ n (Prod.map f g) (x, y)
Result.success

Testing || MeasureTheory.isClosed_aeStronglyMeasurable' : âˆ€ {Î± : Type u_1} {F : Type u_2} {p : ENNReal} [inst : NormedAddCommGroup F] {m m0 : MeasurableSpace Î±}
  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : Fact (1 â‰¤ p)] [inst_2 : CompleteSpace F],
  m â‰¤ m0 â†’ IsClosed {f | MeasureTheory.AEStronglyMeasurable' m (â†‘â†‘f) Î¼}
Result.autoException ::
Duper saturated

Testing || ProbabilityTheory.Kernel.fst_comp : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Î³ : Type u_3} {Î´ : Type u_4}
  {mÎ³ : MeasurableSpace Î³} {mÎ´ : MeasurableSpace Î´} (Îº : ProbabilityTheory.Kernel Î± Î²)
  (Î· : ProbabilityTheory.Kernel Î² (Î³ Ã— Î´)), (Î·.comp Îº).fst = Î·.fst.comp Îº
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TypeVec.dropFun_id : âˆ€ {n : â„•} {Î± : TypeVec.{u_1} (n + 1)}, TypeVec.dropFun TypeVec.id = TypeVec.id
Result.autoException ::
Duper saturated

Testing || Real.cos_sq_add_sin_sq : âˆ€ (x : â„), Real.cos x ^ 2 + Real.sin x ^ 2 = 1
Result.success

Testing || Equiv.addCommSemigroup.proof_1 : âˆ€ {Î± : Type u_2} {Î² : Type u_1} (e : Î± â‰ƒ Î²) [inst : AddCommSemigroup Î²] (x y : Î±), e (e.symm (e x + e y)) = e x + e y
Result.success

Testing || Nat.lcm_pos : âˆ€ {m n : â„•}, 0 < m â†’ 0 < n â†’ 0 < m.lcm n
Result.success

Testing || PProd.exists' : âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop}, (âˆƒ x, p x.fst x.snd) â†” âˆƒ a b, p a b
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || div_le_div_left : âˆ€ {Î± : Type u_2} [inst : LinearOrderedSemifield Î±] {a b c : Î±}, 0 < a â†’ 0 < b â†’ 0 < c â†’ (a / b â‰¤ a / c â†” c â‰¤ b)
Result.success

Testing || Set.Finite.induction_to_univ : âˆ€ {Î± : Type u} [inst : Finite Î±] {C : Set Î± â†’ Prop} (S0 : Set Î±),
  C S0 â†’ (âˆ€ (S : Set Î±), S â‰  Set.univ â†’ C S â†’ âˆƒ a âˆ‰ S, C (insert a S)) â†’ C Set.univ
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || VectorBundleCore.continuous_proj : âˆ€ {R : Type u_1} {B : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField R] [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace R F] [inst_3 : TopologicalSpace B] {Î¹ : Type u_5} (Z : VectorBundleCore R B F Î¹),
  Continuous Z.proj
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.toTopologicalSpace`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || CategoryTheory.equivYoneda'_inv_val : âˆ€ (S : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)),
  (CategoryTheory.equivYoneda' S).inv.val = (CategoryTheory.equivYoneda S.val â‹¯).inv
Result.autoException ::
application type mismatch
  (Â¬a) = { val := a â†’ False }.val
argument
  { val := a â†’ False }.val
has type
  (CategoryTheory.yoneda'.obj (S.val.obj (Opposite.op PUnit.{u + 1}))).val âŸ¶ S.val : Type (u + 1)
but is expected to have type
  Prop : Type

Testing || Fintype.decidableEqAddEquivFintype.proof_1 : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Add Î±] [inst_1 : Add Î²] (a b : Î± â‰ƒ+ Î²), â‡‘a = â‡‘b â†” a = b
Result.success

Testing || intervalIntegral.intervalIntegrable_log : âˆ€ {a b : â„} {Î¼ : MeasureTheory.Measure â„} [inst : MeasureTheory.IsLocallyFiniteMeasure Î¼],
  0 âˆ‰ Set.uIcc a b â†’ IntervalIntegrable Real.log Î¼ a b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x.decidableEq cifvar_7`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || StrictConcaveOn.concaveOn : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]
  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : _root_.Module ğ•œ E] [inst_4 : _root_.Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},
  StrictConcaveOn ğ•œ s f â†’ ConcaveOn ğ•œ s f
Result.success

Testing || ProbabilityTheory.Kernel.ae_compProd_iff : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Î³ : Type u_3}
  {mÎ³ : MeasurableSpace Î³} {Îº : ProbabilityTheory.Kernel Î± Î²} [inst : ProbabilityTheory.IsSFiniteKernel Îº]
  {Î· : ProbabilityTheory.Kernel (Î± Ã— Î²) Î³} [inst : ProbabilityTheory.IsSFiniteKernel Î·] {a : Î±} {p : Î² Ã— Î³ â†’ Prop},
  MeasurableSet {x | p x} â†’
    ((âˆ€áµ (bc : Î² Ã— Î³) âˆ‚(Îº.compProd Î·) a, p bc) â†” âˆ€áµ (b : Î²) âˆ‚Îº a, âˆ€áµ (c : Î³) âˆ‚Î· (a, b), p (b, c))
Result.autoException ::
(deterministic) timeout at `printProof`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || SMulPosReflectLT.toSMulPosMono : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : SMul Î± Î²] [inst_1 : Preorder Î±] [inst_2 : LinearOrder Î²]
  [inst_3 : _root_.Zero Î²] [inst_4 : SMulPosReflectLT Î± Î²], SMulPosMono Î± Î²
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Zero.toOfNat0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || MeasureTheory.withDensity_indicator_one : âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},
  MeasurableSet s â†’ Î¼.withDensity (s.indicator 1) = Î¼.restrict s
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || add_halves' : âˆ€ {R : Type u_1} [inst : DivisionSemiring R] [inst_1 : NeZero 2] (a : R), a / 2 + a / 2 = a
Result.success

Testing || CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {D : Type u'}
  [inst_2 : CategoryTheory.Category.{v', u'} D] [inst_3 : CategoryTheory.Preadditive D] (F : CategoryTheory.Functor C D)
  [inst_4 : F.PreservesZeroMorphisms] {J : Type} [inst_5 : Fintype J]
  [inst_6 : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F],
  CategoryTheory.Limits.PreservesBiproductsOfShape J F
Result.autoException ::
Duper saturated

Testing || WithTop.image_coe_Ioi : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a : Î±}, WithTop.some '' Set.Ioi a = Set.Ioo â†‘a âŠ¤
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #1, ((!24 x0 x1) = (!22 (!26 x0) (Î»x2 : #1, (!26 x2 x1)))))) is not type correct

Testing || CategoryTheory.forgetEnrichment_id : âˆ€ {C : Type uâ‚} (W : Type v) [inst : CategoryTheory.Category.{w, v} W] [inst_1 : CategoryTheory.MonoidalCategory W]
  [inst_2 : CategoryTheory.EnrichedCategory W C] (X : CategoryTheory.ForgetEnrichment W C),
  CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.id X) =
    CategoryTheory.eId W (CategoryTheory.ForgetEnrichment.to W X)
Result.autoException ::
Duper saturated

Testing || CategoryTheory.Comma.mapLeftComp_inv_app_left : âˆ€ {A : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} A] {B : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B]
  {T : Type uâ‚ƒ} [inst_2 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T] (R : CategoryTheory.Functor B T)
  {Lâ‚ Lâ‚‚ Lâ‚ƒ : CategoryTheory.Functor A T} (l : Lâ‚ âŸ¶ Lâ‚‚) (l' : Lâ‚‚ âŸ¶ Lâ‚ƒ) (X : CategoryTheory.Comma Lâ‚ƒ R),
  ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).left = CategoryTheory.CategoryStruct.id X.left
Result.autoException ::
Duper saturated

Testing || Order.pred_lt : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : PredOrder Î±] [inst_2 : NoMinOrder Î±] (a : Î±), Order.pred a < a
Result.success

Testing || isOfFinAddOrder_zero : âˆ€ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0
Result.success

Testing || gradient_eq : âˆ€ {ğ•œ : Type u_1} {F : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace ğ•œ F]
  [inst_3 : CompleteSpace F] {f : F â†’ ğ•œ} {f' : F â†’ F}, (âˆ€ (x : F), HasGradientAt f (f' x) x) â†’ gradient f = f'
Result.success

Testing || padicNorm.int_lt_one_iff : âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m < 1 â†” â†‘p âˆ£ m
Result.success

Testing || FiberBundle.mem_baseSet_trivializationAt : âˆ€ {B : Type u_2} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : B â†’ Type u_5)
  [inst_2 : TopologicalSpace (Bundle.TotalSpace F E)] [inst_3 : (b : B) â†’ TopologicalSpace (E b)]
  [inst_4 : FiberBundle F E] (b : B), b âˆˆ (trivializationAt F E b).baseSet
Result.success

Testing || Multiset.map_add_left_Ioc : âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] [inst_1 : ExistsAddOfLE Î±] [inst_2 : LocallyFiniteOrder Î±]
  (a b c : Î±), Multiset.map (fun x => c + x) (Multiset.Ioc a b) = Multiset.Ioc (c + a) (c + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image
  (fun x => cifvar_4 x_3 x) (cifvar_10 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || IsOpen.div_right : âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {s t : Set G},
  IsOpen s â†’ IsOpen (s / t)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a âˆˆ x_1 of Î» binder contains bound variables

Testing || ZModModule.add_add_add_cancel : âˆ€ {G : Type u_2} [inst : AddCommGroup G] [inst_1 : _root_.Module (ZMod 2) G] (x y z : G), x + y + (y + z) = x + z
Result.success

Testing || ProbabilityTheory.centralMoment_one' : âˆ€ {Î© : Type u_1} {m : MeasurableSpace Î©} {X : Î© â†’ â„} {Î¼ : MeasureTheory.Measure Î©}
  [inst : MeasureTheory.IsFiniteMeasure Î¼],
  MeasureTheory.Integrable X Î¼ â†’ ProbabilityTheory.centralMoment X 1 Î¼ = (1 - (Î¼ Set.univ).toReal) * âˆ« (x : Î©), X x âˆ‚Î¼
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b âŸ¶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a âŸ¶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful] {Z : C} (h : a âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.fst' f') h) =
    CategoryTheory.CategoryStruct.comp (hf'.snd g) h
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `âˆ€`

Testing || Duper.rule15bTheorem : âˆ€ (b : Bool), (!!b) = b
Result.success

Testing || Real.summable_cexp_multipliable : âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} (f : Î¹ â†’ Î± â†’ â„),
  (âˆ€ (x : Î±) (n : Î¹), 0 < f n x) â†’
    (âˆ€ (x : Î±), Summable fun n => Real.log (f n x)) â†’ âˆ€ (a : Î±), Multipliable fun b => f b a
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Elapsed time: 82344 ms

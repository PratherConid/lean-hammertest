Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = smt cvc5, logFile := evalOut.txt}

Testing || AlgebraicGeometry.LocallyRingedSpace.restrictStalkIso_hom_eq_germ_apply : ‚àÄ {U : TopCat} (X : AlgebraicGeometry.LocallyRingedSpace) {f : U ‚ü∂ X.toTopCat} (h : IsOpenEmbedding ‚áëf)
  (V : TopologicalSpace.Opens ‚ÜëU) (x : ‚ÜëU) (hx : x ‚àà V) (y : ‚Üë((X.restrict h).presheaf.obj (Opposite.op V))),
  (X.restrictStalkIso h x).hom (((X.restrict h).presheaf.germ V x hx) y) = (X.presheaf.germ (‚ãØ.functor.obj V) (f x) ‚ãØ) y
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Module.Quotient.mk_smul_mk : ‚àÄ {R : Type u_1} (M : Type u_2) [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (I : Ideal R)
  (r : R) (m : M), (Ideal.Quotient.mk I) r ‚Ä¢ Submodule.Quotient.mk m = Submodule.Quotient.mk (r ‚Ä¢ m)
Result.autoException ::
Auto failed to find proof

Testing || BoundedLatticeHom.asBoolRing_id : ‚àÄ {Œ± : Type u_1} [inst : BooleanAlgebra Œ±], (BoundedLatticeHom.id Œ±).asBoolRing = RingHom.id (AsBoolRing Œ±)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_BoundedLatticeHom_Œ±_Œ±| is 1
; rep: (as @|_BoundedLatticeHom_Œ±_Œ±|_0 |_BoundedLatticeHom_Œ±_Œ±|)
; cardinality of |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±| is 2
; rep: (as @|_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|_0 |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|)
; rep: (as @|_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|_1 |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|)
(define-fun |_BoundedLatticeHom.id_Œ±| () |_BoundedLatticeHom_Œ±_Œ±| (as @|_BoundedLatticeHom_Œ±_Œ±|_0 |_BoundedLatticeHom_Œ±_Œ±|))
(define-fun _BoundedLatticeHom.asBoolRing ((_arg_1 |_BoundedLatticeHom_Œ±_Œ±|)) |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±| (as @|_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|_1 |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|))
(define-fun |_RingHom.id_AsBoolRing_Œ±| () |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±| (as @|_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|_0 |_AsBoolRing_Œ±__+*_AsBoolRing_Œ±|))
)


Testing || ofAdd_list_prod : ‚àÄ {Œ± : Type u_3} [inst : AddMonoid Œ±] (s : List Œ±),
  Multiplicative.ofAdd s.sum = (List.map (‚áëMultiplicative.ofAdd) s).prod
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Multiplicative_Œ±| is 3
; rep: (as @|_Multiplicative_Œ±|_0 |_Multiplicative_Œ±|)
; rep: (as @|_Multiplicative_Œ±|_1 |_Multiplicative_Œ±|)
; rep: (as @|_Multiplicative_Œ±|_2 |_Multiplicative_Œ±|)
; cardinality of |_Œ±___Multiplicative_Œ±| is 1
; rep: (as @|_Œ±___Multiplicative_Œ±|_0 |_Œ±___Multiplicative_Œ±|)
(define-fun _Multiplicative.ofAdd () |_Œ±___Multiplicative_Œ±| (as @|_Œ±___Multiplicative_Œ±|_0 |_Œ±___Multiplicative_Œ±|))
(define-fun _s () |_List_Œ±| _pl___)
(define-fun _List.sum ((_arg_1 |_List_Œ±|)) |_Multiplicative_Œ±| (as @|_Multiplicative_Œ±|_0 |_Multiplicative_Œ±|))
(define-fun _DFunLike.coe ((_arg_1 |_Œ±___Multiplicative_Œ±|) (_arg_2 |_Multiplicative_Œ±|)) |_Multiplicative_Œ±| (as @|_Multiplicative_Œ±|_1 |_Multiplicative_Œ±|))
(define-fun _List.map__Multiplicative.ofAdd ((_arg_1 |_List_Œ±|)) |_List_Œ±| (_List.cons (as @|_Multiplicative_Œ±|_0 |_Multiplicative_Œ±|) _pl___))
(define-fun _List.prod ((_arg_1 |_List_Œ±|)) |_Multiplicative_Œ±| (as @|_Multiplicative_Œ±|_2 |_Multiplicative_Œ±|))
(define-fun _List.map_fun_a_=>_a_=_id () Bool true)
)


Testing || CategoryTheory.HasSheafify.isLeftExact : ‚àÄ {C : Type u‚ÇÅ} {inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C} {J : CategoryTheory.GrothendieckTopology C} {A : Type u‚ÇÇ}
  {inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A} [self : CategoryTheory.HasSheafify J A],
  Nonempty (CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.sheafToPresheaf J A).leftAdjoint)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of _C is 1
; rep: (as @_C_0 _C)
; cardinality of _CategoryTheory.GrothendieckTopology_C is 1
; rep: (as @_CategoryTheory.GrothendieckTopology_C_0 _CategoryTheory.GrothendieckTopology_C)
; cardinality of _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A is 1
; rep: (as @_CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A_0 _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A)
; cardinality of |_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_| is 1
; rep: (as @|_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_|_0 |_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_|)
(define-fun _J () _CategoryTheory.GrothendieckTopology_C (as @_CategoryTheory.GrothendieckTopology_C_0 _CategoryTheory.GrothendieckTopology_C))
(define-fun _fun_J_=>_CategoryTheory.HasSheafify_J_A ((_arg_1 _CategoryTheory.GrothendieckTopology_C)) Bool true)
(define-fun _CategoryTheory.sheafToPresheaf_J_A.leftAdjoint () _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A (as @_CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A_0 _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A))
(define-fun _CategoryTheory.Limits.PreservesFiniteLimits ((_arg_1 _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A)) |_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_| (as @|_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_|_0 |_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_|))
(define-fun _Nonempty ((_arg_1 |_Type__max__max_1__max__max_u‚ÇÅ_u‚ÇÇ__v‚ÇÅ__v‚ÇÇ__u‚ÇÅ_v‚ÇÇ_|)) Bool false)
)


Testing || MvPolynomial.cardinal_mk_eq_max_lift : ‚àÄ {œÉ : Type u} {R : Type v} [inst : CommSemiring R] [inst_1 : Nonempty œÉ] [inst_2 : Nontrivial R],
  Cardinal.mk (MvPolynomial œÉ R) =
    max (max (Cardinal.lift.{u, v} (Cardinal.mk R)) (Cardinal.lift.{v, u} (Cardinal.mk œÉ))) Cardinal.aleph0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || ContinuousMap.Homotopy.apply_one : ‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)}
  (F : f‚ÇÄ.Homotopy f‚ÇÅ) (x : X), F (1, x) = f‚ÇÅ x
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of _CauSeq.Completion.Cauchy_abs is 1
; rep: (as @_CauSeq.Completion.Cauchy_abs_0 _CauSeq.Completion.Cauchy_abs)
; cardinality of _X is 1
; rep: (as @_X_0 _X)
; cardinality of ___x_//_x___Set.Icc_0_1__ is 1
; rep: (as @___x_//_x___Set.Icc_0_1___0 ___x_//_x___Set.Icc_0_1__)
; cardinality of |_f‚ÇÄ.Homotopy_f‚ÇÅ| is 1
; rep: (as @|_f‚ÇÄ.Homotopy_f‚ÇÅ|_0 |_f‚ÇÄ.Homotopy_f‚ÇÅ|)
; cardinality of _Y is 2
; rep: (as @_Y_0 _Y)
; rep: (as @_Y_1 _Y)
; cardinality of _C_X__Y_ is 1
; rep: (as @_C_X__Y__0 _C_X__Y_)
(define-fun _F () |_f‚ÇÄ.Homotopy_f‚ÇÅ| (as @|_f‚ÇÄ.Homotopy_f‚ÇÅ|_0 |_f‚ÇÄ.Homotopy_f‚ÇÅ|))
(define-fun _1_ () ___x_//_x___Set.Icc_0_1__ (as @___x_//_x___Set.Icc_0_1___0 ___x_//_x___Set.Icc_0_1__))
(define-fun _x () _X (as @_X_0 _X))
(define-fun _DFunLike.coe ((_arg_1 |_f‚ÇÄ.Homotopy_f‚ÇÅ|) (_arg_2 ___x_//_x___Set.Icc_0_1_____X)) _Y (as @_Y_0 _Y))
(define-fun |_f‚ÇÅ| () _C_X__Y_ (as @_C_X__Y__0 _C_X__Y_))
(define-fun _DFunLike.coe_0 ((_arg_1 _C_X__Y_) (_arg_2 _X)) _Y (as @_Y_1 _Y))
)


Testing || Asymptotics.IsBigOWith.const_mul_right : ‚àÄ {Œ± : Type u_1} {E : Type u_3} {ùïú : Type u_15} [inst : Norm E] [inst_1 : NormedDivisionRing ùïú] {f : Œ± ‚Üí E}
  {l : Filter Œ±} {g : Œ± ‚Üí ùïú} {c : ùïú},
  c ‚â† 0 ‚Üí
    ‚àÄ {c' : ‚Ñù}, 0 ‚â§ c' ‚Üí Asymptotics.IsBigOWith c' l f g ‚Üí Asymptotics.IsBigOWith (c' * ‚Äñc‚Äñ‚Åª¬π) l f fun x => c * g x
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || CategoryTheory.GradedObject.TriangleIndexData.hp‚ÇÅ‚ÇÇ : ‚àÄ {I‚ÇÅ : Type u_1} {I‚ÇÇ : Type u_2} {I‚ÇÉ : Type u_3} {J : Type u_4} [inst : Zero I‚ÇÇ] {r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J}
  {œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J} (self : CategoryTheory.GradedObject.TriangleIndexData r œÄ) (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ),
  œÄ (self.p‚ÇÅ‚ÇÇ (i.1, i.2.1), i.2.2) = r i
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_I‚ÇÇ| is 1
; rep: (as @|_I‚ÇÇ|_0 |_I‚ÇÇ|)
; cardinality of |_I‚ÇÅ| is 2
; rep: (as @|_I‚ÇÅ|_0 |_I‚ÇÅ|)
; rep: (as @|_I‚ÇÅ|_1 |_I‚ÇÅ|)
; cardinality of |_I‚ÇÉ| is 1
; rep: (as @|_I‚ÇÉ|_0 |_I‚ÇÉ|)
; cardinality of |_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ| is 1
; rep: (as @|_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ|_0 |_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ|)
; cardinality of _J is 2
; rep: (as @_J_0 _J)
; rep: (as @_J_1 _J)
(define-fun _self () |_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ| (as @|_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ|_0 |_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ|))
(define-fun _i () |_I‚ÇÅ___I‚ÇÇ___I‚ÇÉ| (_Prod.mk_1 (as @|_I‚ÇÅ|_0 |_I‚ÇÅ|) (_Prod.mk_0 (as @|_I‚ÇÇ|_0 |_I‚ÇÇ|) (as @|_I‚ÇÉ|_0 |_I‚ÇÉ|))))
(define-fun |_CategoryTheory.GradedObject.TriangleIndexData.p‚ÇÅ‚ÇÇ| ((_arg_1 |_CategoryTheory.GradedObject.TriangleIndexData_r_œÄ|) (_arg_2 |_I‚ÇÅ___I‚ÇÇ|)) |_I‚ÇÅ| (as @|_I‚ÇÅ|_1 |_I‚ÇÅ|))
(define-fun |_œÄ| ((_arg_1 |_I‚ÇÅ___I‚ÇÉ|)) _J (as @_J_0 _J))
(define-fun _r ((_arg_1 |_I‚ÇÅ___I‚ÇÇ___I‚ÇÉ|)) _J (as @_J_1 _J))
)


Testing || Matrix.toEuclideanLin_piLp_equiv_symm : ‚àÄ {ùïú : Type u_3} [inst : RCLike ùïú] {m : Type u_8} {n : Type u_9} [inst_1 : Fintype n] [inst_2 : DecidableEq n]
  (A : Matrix m n ùïú) (x : n ‚Üí ùïú),
  (Matrix.toEuclideanLin A) ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)).symm x) =
    (WithLp.equiv 2 (m ‚Üí ùïú)).symm ((Matrix.toLin' A) x)
Result.autoException ::
Auto failed to find proof

Testing || CoalgebraCat.of_isAddCommGroup : ‚àÄ (R : Type u) [inst : CommRing R] (X : Type v) [inst_1 : AddCommGroup X] [inst_2 : Module R X]
  [inst_3 : Coalgebra R X], (CoalgebraCat.of R X).isAddCommGroup = inst_1
Result.autoException ::
Auto.Reif.resolveTy :: Unable to resolve AddCommGroup ‚Üë(CoalgebraCat.of R X).toModuleCat

Testing || ContinuousMultilinearMap.iteratedFDerivComponent_apply : ‚àÄ {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type wE‚ÇÅ} {G : Type wG} [inst : NontriviallyNormedField ùïú]
  [inst_1 : (i : Œπ) ‚Üí SeminormedAddCommGroup (E‚ÇÅ i)] [inst_2 : (i : Œπ) ‚Üí NormedSpace ùïú (E‚ÇÅ i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace ùïú G] [inst_5 : Fintype Œπ] {Œ± : Type u_1}
  [inst_6 : Fintype Œ±] (f : ContinuousMultilinearMap ùïú E‚ÇÅ G) {s : Set Œπ} (e : Œ± ‚âÉ ‚Üës)
  [inst_7 : DecidablePred fun x => x ‚àà s] (v : (i : { a // a ‚àâ s }) ‚Üí E‚ÇÅ ‚Üëi) (w : Œ± ‚Üí (i : Œπ) ‚Üí E‚ÇÅ i),
  ((f.iteratedFDerivComponent e) v) w = f fun j => if h : j ‚àà s then w (e.symm ‚ü®j, h‚ü©) j else v ‚ü®j, h‚ü©
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || nontrivial_iff_lt : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±], Nontrivial Œ± ‚Üî ‚àÉ x y, x < y
Result.autoException ::
Auto failed to find proof

Testing || isUniformInducing_iff_uniformSpace : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},
  IsUniformInducing f ‚Üî UniformSpace.comap f inst_1 = inst
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 1
; rep: (as @|_Œ±|_0 |_Œ±|)
; cardinality of |_Œ≤| is 1
; rep: (as @|_Œ≤|_0 |_Œ≤|)
; cardinality of |_Filter_Œ≤___Œ≤| is 1
; rep: (as @|_Filter_Œ≤___Œ≤|_0 |_Filter_Œ≤___Œ≤|)
; cardinality of |_Filter_Œ±___Œ±| is 2
; rep: (as @|_Filter_Œ±___Œ±|_0 |_Filter_Œ±___Œ±|)
; rep: (as @|_Filter_Œ±___Œ±|_1 |_Filter_Œ±___Œ±|)
; cardinality of |_UniformSpace_Œ±| is 1
; rep: (as @|_UniformSpace_Œ±|_0 |_UniformSpace_Œ±|)
; cardinality of |_UniformSpace_Œ≤| is 1
; rep: (as @|_UniformSpace_Œ≤|_0 |_UniformSpace_Œ≤|)
; cardinality of |_Set_Œ≤___Œ≤| is 1
; rep: (as @|_Set_Œ≤___Œ≤|_0 |_Set_Œ≤___Œ≤|)
; cardinality of |_Set_Œ±___Œ±| is 1
; rep: (as @|_Set_Œ±___Œ±|_0 |_Set_Œ±___Œ±|)
(define-fun |_uniformity_Œ≤| () |_Filter_Œ≤___Œ≤| (as @|_Filter_Œ≤___Œ≤|_0 |_Filter_Œ≤___Œ≤|))
(define-fun _Filter.comap_fun_p_=>__f_p.1__f_p.2_ ((_arg_1 |_Filter_Œ≤___Œ≤|)) |_Filter_Œ±___Œ±| (as @|_Filter_Œ±___Œ±|_1 |_Filter_Œ±___Œ±|))
(define-fun |_uniformity_Œ±| () |_Filter_Œ±___Œ±| (as @|_Filter_Œ±___Œ±|_0 |_Filter_Œ±___Œ±|))
(define-fun _UniformSpace.mk_cifvar_7_cifvar_8_cifvar_9_cifvar_10_exfvar_3_ () |_UniformSpace_Œ±| (as @|_UniformSpace_Œ±|_0 |_UniformSpace_Œ±|))
(define-fun _inst.116_ () |_UniformSpace_Œ±| (as @|_UniformSpace_Œ±|_0 |_UniformSpace_Œ±|))
(define-fun _inst.119_ () |_UniformSpace_Œ≤| (as @|_UniformSpace_Œ≤|_0 |_UniformSpace_Œ≤|))
(define-fun _Membership.mem ((BOUND_VARIABLE_557 |_Filter_Œ≤___Œ≤|) (BOUND_VARIABLE_558 |_Set_Œ≤___Œ≤|)) Bool false)
(define-fun _Membership.mem_0 ((BOUND_VARIABLE_561 |_Filter_Œ±___Œ±|) (BOUND_VARIABLE_562 |_Set_Œ±___Œ±|)) Bool false)
)


Testing || Ordinal.lt_omega0_opow_succ : ‚àÄ {a b : Ordinal.{u_1}}, a < Ordinal.omega0 ^ Order.succ b ‚Üî ‚àÉ n, a < Ordinal.omega0 ^ b * ‚Üën
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Affine.Simplex.centroid_eq_affineCombination_of_pointsWithCircumcenter : ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex ‚Ñù P n) (fs : Finset (Fin (n + 1))),
  Finset.centroid ‚Ñù fs s.points =
    (Finset.affineCombination ‚Ñù Finset.univ s.pointsWithCircumcenter)
      (Affine.Simplex.centroidWeightsWithCircumcenter fs)
Result.autoException ::
Auto failed to find proof

Testing || List.prod_inv : ‚àÄ {G : Type u_7} [inst : CommGroup G] (L : List G), L.prod‚Åª¬π = (List.map (fun x => x‚Åª¬π) L).prod
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Filter.BoundedAtFilter.mul : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SeminormedRing Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤},
  l.BoundedAtFilter f ‚Üí l.BoundedAtFilter g ‚Üí l.BoundedAtFilter (f * g)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Filter_Œ±| is 1
; rep: (as @|_Filter_Œ±|_0 |_Filter_Œ±|)
(define-fun _l () |_Filter_Œ±| (as @|_Filter_Œ±|_0 |_Filter_Œ±|))
(define-fun _fun_l_=>_l.BoundedAtFilter_f ((_arg_1 |_Filter_Œ±|)) Bool true)
(define-fun _fun_l_=>_l.BoundedAtFilter_g ((_arg_1 |_Filter_Œ±|)) Bool true)
(define-fun _fun_l_=>_l.BoundedAtFilter_f_*_g ((_arg_1 |_Filter_Œ±|)) Bool false)
)


Testing || connectedComponentIn_mem_nhds : ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyConnectedSpace Œ±] {F : Set Œ±} {x : Œ±},
  F ‚àà nhds x ‚Üí connectedComponentIn F x ‚àà nhds x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_2 x_0).HasBasis
  (fun s => cifvar_9 (cifvar_10 s) (cifvar_9 (cifvar_11 s x_0) (cifvar_12 s))) cifvar_13`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || WithTop.coe_bot : ‚àÄ {Œ± : Type u_1} [inst : Bot Œ±], ‚Üë‚ä• = ‚ä•
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 1
; rep: (as @|_Œ±|_0 |_Œ±|)
; cardinality of |_WithTop_Œ±| is 2
; rep: (as @|_WithTop_Œ±|_0 |_WithTop_Œ±|)
; rep: (as @|_WithTop_Œ±|_1 |_WithTop_Œ±|)
(define-fun _pl__ () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _WithTop.some ((_arg_1 |_Œ±|)) |_WithTop_Œ±| (as @|_WithTop_Œ±|_1 |_WithTop_Œ±|))
(define-fun _pl___0 () |_WithTop_Œ±| (as @|_WithTop_Œ±|_0 |_WithTop_Œ±|))
)


Testing || Sat.Clause.reify_zero : ‚àÄ {v : Sat.Valuation}, Sat.Clause.reify v Sat.Clause.nil True
Result.autoException ::
Auto failed to find proof

Testing || Ordinal.nadd_one : ‚àÄ (a : Ordinal.{u}), a.nadd 1 = Order.succ a
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || QuotientMap.restrictPreimage_isOpen : ‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X ‚Üí Y},
  IsQuotientMap f ‚Üí ‚àÄ {s : Set Y}, IsOpen s ‚Üí IsQuotientMap (s.restrictPreimage f)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_6 (cifvar_7 s) x }`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Equiv.piCongrLeft_apply : ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_4} (P : Œ≤ ‚Üí Sort w) (e : Œ± ‚âÉ Œ≤) (f : (a : Œ±) ‚Üí P (e a)) (b : Œ≤),
  (Equiv.piCongrLeft P e) f b = ‚ãØ ‚ñ∏ f (e.symm b)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || RingHom.locally_iff_exists : ‚àÄ {P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop} {R S : Type u}
  [inst : CommRing R] [inst_1 : CommRing S],
  (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) ‚Üí
    ‚àÄ (f : R ‚Üí+* S),
      RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f ‚Üî
        ‚àÉ Œπ s,
          ‚àÉ (_ : Ideal.span (Set.range s) = ‚ä§),
            ‚àÉ S‚Çú x x_1, ‚àÉ (_ : ‚àÄ (i : Œπ), IsLocalization.Away (s i) (S‚Çú i)), ‚àÄ (i : Œπ), P ((algebraMap S (S‚Çú i)).comp f)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R‚úù of Œª binder contains bound variables

Testing || OrderIso.refl_toEquiv : ‚àÄ {Œ± : Type u_2} [inst : LE Œ±], (OrderIso.refl Œ±).toEquiv = Equiv.refl Œ±
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_ is 1
; rep: (as @_fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)
; cardinality of |_Œ±___Œ±| is 2
; rep: (as @|_Œ±___Œ±|_0 |_Œ±___Œ±|)
; rep: (as @|_Œ±___Œ±|_1 |_Œ±___Œ±|)
(define-fun |_OrderIso.refl_Œ±| () _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_ (as @_fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_))
(define-fun _RelIso.toEquiv ((_arg_1 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)) |_Œ±___Œ±| (as @|_Œ±___Œ±|_1 |_Œ±___Œ±|))
(define-fun |_Equiv.refl_Œ±| () |_Œ±___Œ±| (as @|_Œ±___Œ±|_0 |_Œ±___Œ±|))
)


Testing || OrderIso.smulRightDual_symm_apply : ‚àÄ {Œ± : Type u_1} (Œ≤ : Type u_2) [inst : LinearOrderedField Œ±] [inst_1 : OrderedAddCommGroup Œ≤] [inst_2 : Module Œ± Œ≤]
  {a : Œ±} [inst_3 : PosSMulMono Œ± Œ≤] (ha : a < 0) (a_1 : Œ≤·µí·µà),
  (RelIso.symm (OrderIso.smulRightDual Œ≤ ha)) a_1 = a‚Åª¬π ‚Ä¢ OrderDual.ofDual a_1
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 3
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
; rep: (as @|_Œ±|_2 |_Œ±|)
; cardinality of _a_<_0_ is 1
; rep: (as @_a_<_0__0 _a_<_0_)
; cardinality of _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_ is 1
; rep: (as @_fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)
; cardinality of _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0 is 1
; rep: (as @_fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0_0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0)
; cardinality of |_Œ≤| is 4
; rep: (as @|_Œ≤|_0 |_Œ≤|)
; rep: (as @|_Œ≤|_1 |_Œ≤|)
; rep: (as @|_Œ≤|_2 |_Œ≤|)
; rep: (as @|_Œ≤|_3 |_Œ≤|)
; cardinality of |_Œ≤_____Œ≤| is 1
; rep: (as @|_Œ≤_____Œ≤|_0 |_Œ≤_____Œ≤|)
(define-fun |_PosSMulMono_Œ±_Œ≤| () Bool true)
(define-fun _a () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _0_ () |_Œ±| (as @|_Œ±|_1 |_Œ±|))
(define-fun _LT.lt ((_arg_1 |_Œ±|) (_arg_2 |_Œ±|)) Bool true)
(define-fun _ha () _a_<_0_ (as @_a_<_0__0 _a_<_0_))
(define-fun |_OrderIso.smulRightDual_Œ≤| ((_arg_1 _a_<_0_)) _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_ (as @_fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_))
(define-fun _RelIso.symm ((_arg_1 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)) _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0 (as @_fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0_0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0))
(define-fun _a.26_ () |_Œ≤| (as @|_Œ≤|_0 |_Œ≤|))
(define-fun _DFunLike.coe ((_arg_1 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0) (_arg_2 |_Œ≤|)) |_Œ≤| (as @|_Œ≤|_1 |_Œ≤|))
(define-fun _Inv.inv ((_arg_1 |_Œ±|)) |_Œ±| (as @|_Œ±|_2 |_Œ±|))
(define-fun _OrderDual.ofDual () |_Œ≤_____Œ≤| (as @|_Œ≤_____Œ≤|_0 |_Œ≤_____Œ≤|))
(define-fun _DFunLike.coe_0 ((_arg_1 |_Œ≤_____Œ≤|) (_arg_2 |_Œ≤|)) |_Œ≤| (as @|_Œ≤|_2 |_Œ≤|))
(define-fun _HSMul.hSMul ((_arg_1 |_Œ±|) (_arg_2 |_Œ≤|)) |_Œ≤| (as @|_Œ≤|_3 |_Œ≤|))
)


Testing || NormedAddGroupHom.completion_id : ‚àÄ {G : Type u_1} [inst : SeminormedAddCommGroup G],
  (NormedAddGroupHom.id G).completion = NormedAddGroupHom.id (UniformSpace.Completion G)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `UniformSpace.Completion.map
  (cifvar_11 x_0) x_1`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen_image_preimage : ‚àÄ {X Y : AlgebraicGeometry.LocallyRingedSpace} (f g : X ‚ü∂ Y)
  (U :
    TopologicalSpace.Opens
      ‚Üë‚Üë(CategoryTheory.Limits.coequalizer (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).toPresheafedSpace)
  (s :
    ‚Üë((CategoryTheory.Limits.coequalizer (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).presheaf.obj
        (Opposite.op U))),
  ‚áë(CategoryTheory.Limits.coequalizer.œÄ (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
            (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).base ‚Åª¬π'
      (‚áë(CategoryTheory.Limits.coequalizer.œÄ (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).base ''
        (AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen f g U s).carrier) =
    (AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen f g U s).carrier
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.max_of_mem : ‚àÄ {Œ± : Type u_2} [inst : LinearOrder Œ±] {s : Finset Œ±} {a : Œ±}, a ‚àà s ‚Üí ‚àÉ b, s.max = ‚Üëb
Result.autoException ::
Auto failed to find proof

Testing || tendsto_integral_exp_smul_cocompact : ‚àÄ {E : Type u_1} {V : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] (f : V ‚Üí E)
  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]
  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ‚Ñù V] [inst_9 : ContinuousSMul ‚Ñù V]
  [inst_10 : FiniteDimensional ‚Ñù V] (Œº : MeasureTheory.Measure V) [inst_11 : Œº.IsAddHaarMeasure],
  Filter.Tendsto (fun w => ‚à´ (v : V), Real.fourierChar (-w v) ‚Ä¢ f v ‚àÇŒº) (Filter.cocompact (V ‚ÜíL[‚Ñù] ‚Ñù)) (nhds 0)
Result.autoException ::
Auto failed to find proof

Testing || Odd.zpow_neg_iff : ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {n : ‚Ñ§}, Odd n ‚Üí (a ^ n < 0 ‚Üî a < 0)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Matrix.mul_kronecker_mul : ‚àÄ {Œ± : Type u_2} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16}
  [inst : Fintype m] [inst_1 : Fintype m'] [inst_2 : CommSemiring Œ±] (A : Matrix l m Œ±) (B : Matrix m n Œ±)
  (A' : Matrix l' m' Œ±) (B' : Matrix m' n' Œ±),
  Matrix.kroneckerMap (fun x1 x2 => x1 * x2) (A * B) (A' * B') =
    Matrix.kroneckerMap (fun x1 x2 => x1 * x2) A A' * Matrix.kroneckerMap (fun x1 x2 => x1 * x2) B B'
Result.autoException ::
Auto failed to find proof

Testing || Finset.sum_card_inter_le : ‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] {s : Finset Œ±} {B : Finset (Finset Œ±)} {n : ‚Ñï},
  (‚àÄ a ‚àà s, (Finset.filter (fun b => a ‚àà b) B).card ‚â§ n) ‚Üí ‚àë t ‚àà B, (s ‚à© t).card ‚â§ s.card * n
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.decidableMem x_0 a`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Finset.div_def : ‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] [inst_1 : Div Œ±] {s t : Finset Œ±},
  s / t = Finset.image (fun p => p.1 / p.2) (s √óÀ¢ t)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 1
; rep: (as @|_Œ±|_0 |_Œ±|)
; cardinality of |_Finset_Œ±| is 4
; rep: (as @|_Finset_Œ±|_0 |_Finset_Œ±|)
; rep: (as @|_Finset_Œ±|_1 |_Finset_Œ±|)
; rep: (as @|_Finset_Œ±|_2 |_Finset_Œ±|)
; rep: (as @|_Finset_Œ±|_3 |_Finset_Œ±|)
; cardinality of |_Finset_Œ±___Œ±| is 1
; rep: (as @|_Finset_Œ±___Œ±|_0 |_Finset_Œ±___Œ±|)
(define-fun _s () |_Finset_Œ±| (as @|_Finset_Œ±|_0 |_Finset_Œ±|))
(define-fun _t () |_Finset_Œ±| (as @|_Finset_Œ±|_1 |_Finset_Œ±|))
(define-fun _HDiv.hDiv ((_arg_1 |_Finset_Œ±|) (_arg_2 |_Finset_Œ±|)) |_Finset_Œ±| (as @|_Finset_Œ±|_2 |_Finset_Œ±|))
(define-fun _SProd.sprod ((_arg_1 |_Finset_Œ±|) (_arg_2 |_Finset_Œ±|)) |_Finset_Œ±___Œ±| (as @|_Finset_Œ±___Œ±|_0 |_Finset_Œ±___Œ±|))
(define-fun _Finset.image_fun_p_=>_p.1_/_p.2_ ((_arg_1 |_Finset_Œ±___Œ±|)) |_Finset_Œ±| (as @|_Finset_Œ±|_3 |_Finset_Œ±|))
)


Testing || Set.inter_sub_union_subset_union : ‚àÄ {Œ± : Type u_2} [inst : Sub Œ±] {s‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : Set Œ±}, s‚ÇÅ ‚à© s‚ÇÇ - (t‚ÇÅ ‚à™ t‚ÇÇ) ‚äÜ s‚ÇÅ - t‚ÇÅ ‚à™ (s‚ÇÇ - t‚ÇÇ)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Set_Œ±| is 10
; rep: (as @|_Set_Œ±|_0 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_1 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_2 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_3 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_4 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_5 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_6 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_7 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_8 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_9 |_Set_Œ±|)
(define-fun |_s‚ÇÅ| () |_Set_Œ±| (as @|_Set_Œ±|_0 |_Set_Œ±|))
(define-fun |_s‚ÇÇ| () |_Set_Œ±| (as @|_Set_Œ±|_1 |_Set_Œ±|))
(define-fun _Inter.inter ((_arg_1 |_Set_Œ±|) (_arg_2 |_Set_Œ±|)) |_Set_Œ±| (as @|_Set_Œ±|_4 |_Set_Œ±|))
(define-fun |_t‚ÇÅ| () |_Set_Œ±| (as @|_Set_Œ±|_2 |_Set_Œ±|))
(define-fun |_t‚ÇÇ| () |_Set_Œ±| (as @|_Set_Œ±|_3 |_Set_Œ±|))
(define-fun _Union.union ((_arg_1 |_Set_Œ±|) (_arg_2 |_Set_Œ±|)) |_Set_Œ±| (ite (= (as @|_Set_Œ±|_2 |_Set_Œ±|) _arg_1) (ite (= (as @|_Set_Œ±|_3 |_Set_Œ±|) _arg_2) (as @|_Set_Œ±|_5 |_Set_Œ±|) (as @|_Set_Œ±|_9 |_Set_Œ±|)) (as @|_Set_Œ±|_9 |_Set_Œ±|)))
(define-fun _HSub.hSub ((_arg_1 |_Set_Œ±|) (_arg_2 |_Set_Œ±|)) |_Set_Œ±| (ite (= (as @|_Set_Œ±|_0 |_Set_Œ±|) _arg_1) (ite (= (as @|_Set_Œ±|_2 |_Set_Œ±|) _arg_2) (as @|_Set_Œ±|_7 |_Set_Œ±|) (as @|_Set_Œ±|_8 |_Set_Œ±|)) (ite (= (as @|_Set_Œ±|_4 |_Set_Œ±|) _arg_1) (ite (= (as @|_Set_Œ±|_5 |_Set_Œ±|) _arg_2) (as @|_Set_Œ±|_6 |_Set_Œ±|) (as @|_Set_Œ±|_8 |_Set_Œ±|)) (as @|_Set_Œ±|_8 |_Set_Œ±|))))
(define-fun _Subset ((_arg_1 |_Set_Œ±|) (_arg_2 |_Set_Œ±|)) Bool false)
)


Testing || Orientation.oangle_sub_right_eq_arccos_of_oangle_eq_pi_div_two : ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [hd2 : Fact (Module.finrank ‚Ñù V = 2)]
  (o : Orientation ‚Ñù V (Fin 2)) {x y : V},
  o.oangle x y = ‚Üë(Real.pi / 2) ‚Üí o.oangle y (y - x) = ‚Üë(Real.arccos (‚Äñy‚Äñ / ‚Äñy - x‚Äñ))
Result.success

Testing || MulAction.isInvariantBlock_iff_isFixedBlock : ‚àÄ {G : Type u_1} [inst : Group G] {X : Type u_2} [inst_1 : MulAction G X] {B : Set X},
  MulAction.IsInvariantBlock G B ‚Üî MulAction.IsFixedBlock G B
Result.autoException ::
Auto failed to find proof

Testing || WithTop.ofNat_eq_coe : ‚àÄ {Œ± : Type u} [inst : AddMonoidWithOne Œ±] (n : ‚Ñï) [inst_1 : n.AtLeastTwo] (m : Œ±),
  OfNat.ofNat n = ‚Üëm ‚Üî OfNat.ofNat n = m
Result.autoException ::
Auto failed to find proof

Testing || IsDedekindDomain.HeightOneSpectrum.intValuation_singleton : ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) {r : R},
  r ‚â† 0 ‚Üí v.asIdeal = Ideal.span {r} ‚Üí v.intValuation r = ‚Üë(Multiplicative.ofAdd (-1))
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬¨ ((!7 (!8 !4) !1) = (!9 (!10 !11 (- (iofNat (1 : Nat))))))) is not type correct

Testing || Action.Hom.comm_assoc : ‚àÄ {V : Type (u + 1)} [inst : CategoryTheory.LargeCategory V] {G : MonCat} {M N : Action V G} (self : M.Hom N) (g : ‚ÜëG)
  {Z : V} (h : N.V ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp (M.œÅ g) (CategoryTheory.CategoryStruct.comp self.hom h) =
    CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (N.œÅ g) h)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || CauchySeq.tendsto_uniformity : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [uniformSpace : UniformSpace Œ±] [inst : Preorder Œ≤] {u : Œ≤ ‚Üí Œ±},
  CauchySeq u ‚Üí Filter.Tendsto (Prod.map u u) Filter.atTop (uniformity Œ±)
Result.autoException ::
Auto failed to find proof

Testing || TrivSqZeroExt.inlAlgHom_apply : ‚àÄ (S : Type u_1) (R : Type u) (M : Type v) [inst : CommSemiring S] [inst_1 : Semiring R] [inst_2 : AddCommMonoid M]
  [inst_3 : Algebra S R] [inst_4 : Module S M] [inst_5 : Module R M] [inst_6 : Module R·µê·µí·µñ M]
  [inst_7 : SMulCommClass R R·µê·µí·µñ M] [inst_8 : IsScalarTower S R M] [inst_9 : IsScalarTower S R·µê·µí·µñ M] (r : R),
  (TrivSqZeroExt.inlAlgHom S R M) r = TrivSqZeroExt.inl r
Result.autoException ::
Auto failed to find proof

Testing || Matroid.StrictRestriction.ssubset : ‚àÄ {Œ± : Type u_1} {M N : Matroid Œ±}, N.StrictRestriction M ‚Üí N.E ‚äÇ M.E
Result.autoException ::
Auto failed to find proof

Testing || RelEmbedding.sumLexInr_apply : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (val : Œ≤),
  (RelEmbedding.sumLexInr r s) val = Sum.inr val
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 1
; rep: (as @|_Œ±|_0 |_Œ±|)
; cardinality of |_Œ≤| is 1
; rep: (as @|_Œ≤|_0 |_Œ≤|)
; cardinality of _s__r_Sum.Lex_r_s is 1
; rep: (as @_s__r_Sum.Lex_r_s_0 _s__r_Sum.Lex_r_s)
(define-fun _RelEmbedding.sumLexInr_r_s () _s__r_Sum.Lex_r_s (as @_s__r_Sum.Lex_r_s_0 _s__r_Sum.Lex_r_s))
(define-fun _val () |_Œ≤| (as @|_Œ≤|_0 |_Œ≤|))
(define-fun _DFunLike.coe ((_arg_1 _s__r_Sum.Lex_r_s) (_arg_2 |_Œ≤|)) |_Œ±___Œ≤| (_Sum.inl (as @|_Œ±|_0 |_Œ±|)))
)


Testing || Algebra.embeddingsMatrix_apply : ‚àÄ {Œ∫ : Type w} (A : Type u) {B : Type v} (C : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]
  [inst_3 : CommRing C] [inst_4 : Algebra A C] (b : Œ∫ ‚Üí B) (i : Œ∫) (œÉ : B ‚Üí‚Çê[A] C),
  Algebra.embeddingsMatrix A C b i œÉ = œÉ (b i)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix Œ∫ (B ‚Üí‚Çê[A] C) C is not a `‚àÄ`

Testing || Quaternion.coe_injective : ‚àÄ {R : Type u_3} [inst : CommRing R], Function.Injective Quaternion.coe
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuaternionAlgebra.coe`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || CategoryTheory.Limits.Cocone.mapCoconeToOver_inv_hom : ‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C]
  {F : CategoryTheory.Functor J C} (c : CategoryTheory.Limits.Cocone F),
  c.mapCoconeToOver.inv.hom = CategoryTheory.CategoryStruct.id c.pt
Result.autoException ::
Auto failed to find proof

Testing || Antivary.inv_right : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : OrderedCommGroup Œ±] [inst_1 : OrderedCommGroup Œ≤] {f : Œπ ‚Üí Œ±}
  {g : Œπ ‚Üí Œ≤}, Antivary f g ‚Üí Monovary f g‚Åª¬π
Result.autoException ::
Auto failed to find proof

Testing || Submonoid.coe_centralizer : ‚àÄ {M : Type u_1} (S : Set M) [inst : Monoid M], ‚Üë(Submonoid.centralizer S) = S.centralizer
Result.autoException ::
Auto failed to find proof

Testing || AddAction.quotient.proof_3 : ‚àÄ {Œ± : Type u_1} (Œ≤ : Type u_2) [inst : AddGroup Œ±] [inst_1 : AddMonoid Œ≤] [inst_2 : AddAction Œ≤ Œ±] (H : AddSubgroup Œ±)
  [inst_3 : AddAction.QuotientAction Œ≤ H] (b b' : Œ≤) (q : Œ± ‚ß∏ H), b + b' +·µ• q = b +·µ• (b' +·µ• q)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Cardinal.mk_pi : ‚àÄ {Œπ : Type u} (Œ± : Œπ ‚Üí Type v), Cardinal.mk ((i : Œπ) ‚Üí Œ± i) = Cardinal.prod fun i => Cardinal.mk (Œ± i)
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamTerm2STermAux :: Unexpected head term Auto.Embedding.Lam.LamTerm.lam (.atom 2) (.app (.atom 2) (.atom 2) (.bvar 0))

Testing || CategoryTheory.Functor.surjective_toEventualRanges : ‚àÄ {J : Type u} [inst : CategoryTheory.Category.{u_1, u} J] (F : CategoryTheory.Functor J (Type v))
  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J],
  F.IsMittagLeffler ‚Üí ‚àÄ ‚¶Éi j : J‚¶Ñ (f : i ‚ü∂ j), Function.Surjective (F.toEventualRanges.map f)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_12 f '' cifvar_13`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Class.coe_union : ‚àÄ (x y : ZFSet), ‚Üë(x ‚à™ y) = ‚Üëx ‚à™ ‚Üëy
Result.autoException ::
Auto failed to find proof

Testing || Matrix.GeneralLinearGroup.coe_mul : ‚àÄ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (A B : GL n R),
  ‚Üë(A * B) = ‚ÜëA * ‚ÜëB
Result.autoException ::
Auto failed to find proof

Testing || WCovBy.ge_of_gt : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b c : Œ±}, a ‚©ø b ‚Üí a < c ‚Üí b ‚â§ c
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 3
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
; rep: (as @|_Œ±|_2 |_Œ±|)
(define-fun _a () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _b () |_Œ±| (as @|_Œ±|_1 |_Œ±|))
(define-fun _WCovBy ((_arg_1 |_Œ±|) (_arg_2 |_Œ±|)) Bool true)
(define-fun _c () |_Œ±| (as @|_Œ±|_2 |_Œ±|))
(define-fun _LT.lt ((_arg_1 |_Œ±|) (_arg_2 |_Œ±|)) Bool true)
)


Testing || IsCyclic.exists_monoid_generator : ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Finite Œ±] [inst_2 : IsCyclic Œ±], ‚àÉ x, ‚àÄ (y : Œ±), y ‚àà Submonoid.powers x
Result.success

Testing || Polynomial.rootOfSplits'_eq_rootOfSplits : ‚àÄ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K ‚Üí+* L) {f : Polynomial K}
  (hf : Polynomial.Splits i f) (hfd : (Polynomial.map i f).degree ‚â† 0),
  Polynomial.rootOfSplits' i hf hfd = Polynomial.rootOfSplits i hf ‚ãØ
Result.autoException ::
Auto failed to find proof

Testing || Booleanisation.comp_sdiff_comp : ‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a b : Œ±),
  Booleanisation.comp a \ Booleanisation.comp b = Booleanisation.lift (b \ a)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 3
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
; rep: (as @|_Œ±|_2 |_Œ±|)
; cardinality of |_Booleanisation_Œ±| is 4
; rep: (as @|_Booleanisation_Œ±|_0 |_Booleanisation_Œ±|)
; rep: (as @|_Booleanisation_Œ±|_1 |_Booleanisation_Œ±|)
; rep: (as @|_Booleanisation_Œ±|_2 |_Booleanisation_Œ±|)
; rep: (as @|_Booleanisation_Œ±|_3 |_Booleanisation_Œ±|)
(define-fun _a () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _Booleanisation.comp ((_arg_1 |_Œ±|)) |_Booleanisation_Œ±| (ite (= (as @|_Œ±|_1 |_Œ±|) _arg_1) (as @|_Booleanisation_Œ±|_1 |_Booleanisation_Œ±|) (as @|_Booleanisation_Œ±|_0 |_Booleanisation_Œ±|)))
(define-fun _b () |_Œ±| (as @|_Œ±|_1 |_Œ±|))
(define-fun _sdiff ((_arg_1 |_Booleanisation_Œ±|) (_arg_2 |_Booleanisation_Œ±|)) |_Booleanisation_Œ±| (as @|_Booleanisation_Œ±|_2 |_Booleanisation_Œ±|))
(define-fun _sdiff_0 ((_arg_1 |_Œ±|) (_arg_2 |_Œ±|)) |_Œ±| (as @|_Œ±|_2 |_Œ±|))
(define-fun _Booleanisation.lift ((_arg_1 |_Œ±|)) |_Booleanisation_Œ±| (as @|_Booleanisation_Œ±|_3 |_Booleanisation_Œ±|))
)


Testing || aemeasurable_lineDeriv : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] [inst_1 : LocallyCompactSpace ùïú] {E : Type u_2}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] [inst_4 : MeasurableSpace E]
  [inst_5 : OpensMeasurableSpace E] {F : Type u_3} [inst_6 : NormedAddCommGroup F] [inst_7 : NormedSpace ùïú F]
  [inst_8 : CompleteSpace F] {f : E ‚Üí F} {v : E} [inst_9 : MeasurableSpace F] [inst_10 : BorelSpace F],
  Continuous f ‚Üí ‚àÄ (Œº : MeasureTheory.Measure E), AEMeasurable (fun x => lineDeriv ùïú f x v) Œº
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Measurable fun x =>
  cifvar_12 x x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || ite_false : ‚àÄ {Œ± : Sort u_1} (a b : Œ±), (if False then a else b) = b
Result.success

Testing || linearEquivIsoModuleIso_hom : ‚àÄ {R : Type u} [inst : Ring R] {X Y : Type u} [inst_1 : AddCommGroup X] [inst_2 : AddCommGroup Y] [inst_3 : Module R X]
  [inst_4 : Module R Y] (e : X ‚âÉ‚Çó[R] Y), linearEquivIsoModuleIso.hom e = e.toModuleIso
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: (X ‚âÉ‚Çó[R] Y) ‚ü∂ ModuleCat.of R X ‚âÖ ModuleCat.of R Y is not a `‚àÄ`

Testing || Function.fixedPoints_subset_range : ‚àÄ {Œ± : Type u} {f : Œ± ‚Üí Œ±}, Function.fixedPoints f ‚äÜ Set.range f
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Set_Œ±| is 2
; rep: (as @|_Set_Œ±|_0 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_1 |_Set_Œ±|)
(define-fun _Function.fixedPoints_f () |_Set_Œ±| (as @|_Set_Œ±|_0 |_Set_Œ±|))
(define-fun _Set.range_f () |_Set_Œ±| (as @|_Set_Œ±|_1 |_Set_Œ±|))
(define-fun _Subset ((_arg_1 |_Set_Œ±|) (_arg_2 |_Set_Œ±|)) Bool false)
)


Testing || Prod.normedAddGroup.proof_2 : ‚àÄ {E : Type u_1} {F : Type u_2} [inst : NormedAddGroup E] [inst_1 : NormedAddGroup F] (x y : E √ó F), dist x y = ‚Äñx - y‚Äñ
Result.success

Testing || Prod.pow_swap : ‚àÄ {E : Type u_4} {Œ± : Type u_5} {Œ≤ : Type u_6} [inst : Pow Œ± E] [inst_1 : Pow Œ≤ E] (p : Œ± √ó Œ≤) (c : E),
  (p ^ c).swap = p.swap ^ c
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ≤| is 3
; rep: (as @|_Œ≤|_0 |_Œ≤|)
; rep: (as @|_Œ≤|_1 |_Œ≤|)
; rep: (as @|_Œ≤|_2 |_Œ≤|)
; cardinality of |_Œ±| is 3
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
; rep: (as @|_Œ±|_2 |_Œ±|)
; cardinality of _E is 1
; rep: (as @_E_0 _E)
(define-fun _p () |_Œ±___Œ≤| (_Prod.mk (as @|_Œ±|_0 |_Œ±|) (as @|_Œ≤|_0 |_Œ≤|)))
(define-fun _c () _E (as @_E_0 _E))
(define-fun _HPow.hPow ((_arg_1 |_Œ±___Œ≤|) (_arg_2 _E)) |_Œ±___Œ≤| (_Prod.mk (as @|_Œ±|_0 |_Œ±|) (as @|_Œ≤|_1 |_Œ≤|)))
(define-fun _Prod.swap ((_arg_1 |_Œ±___Œ≤|)) |_Œ≤___Œ±| (ite (= (_Prod.mk (as @|_Œ±|_0 |_Œ±|) (as @|_Œ≤|_0 |_Œ≤|)) _arg_1) (_Prod.mk_0 (as @|_Œ≤|_0 |_Œ≤|) (as @|_Œ±|_0 |_Œ±|)) (_Prod.mk_0 (as @|_Œ≤|_1 |_Œ≤|) (as @|_Œ±|_1 |_Œ±|))))
(define-fun _HPow.hPow_0 ((_arg_1 |_Œ≤___Œ±|) (_arg_2 _E)) |_Œ≤___Œ±| (_Prod.mk_0 (as @|_Œ≤|_2 |_Œ≤|) (as @|_Œ±|_2 |_Œ±|)))
)


Testing || hasDerivAt_jacobiTheta‚ÇÇ_fst : ‚àÄ (z : ‚ÑÇ) {œÑ : ‚ÑÇ}, 0 < œÑ.im ‚Üí HasDerivAt (fun x => jacobiTheta‚ÇÇ x œÑ) (jacobiTheta‚ÇÇ' z œÑ) z
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasSum
  (fun n => cifvar_13 n x_0 x_1) (cifvar_14 x_0 x_1)`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || _private.Mathlib.Algebra.Lie.BaseChange.0.LieAlgebra.ExtendScalars.bracket'_tmul : ‚àÄ (R : Type u_1) (A : Type u_2) (L : Type u_3) (M : Type u_4) [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A] [inst_3 : LieRing L] [inst_4 : LieAlgebra R L] [inst_5 : AddCommGroup M] [inst_6 : Module R M]
  [inst_7 : LieRingModule L M] [inst_8 : LieModule R L M] (s t : A) (x : L) (m : M),
  ((LieAlgebra.ExtendScalars.bracket' R A L M) (s ‚äó‚Çú[R] x)) (t ‚äó‚Çú[R] m) = (s * t) ‚äó‚Çú[R] ‚ÅÖx, m‚ÅÜ
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.MorphismProperty.Comma.Hom.hom_left : ‚àÄ {A : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} A] {B : Type u_2}
  [inst_1 : CategoryTheory.Category.{u_5, u_2} B] {T : Type u_3} [inst_2 : CategoryTheory.Category.{u_6, u_3} T]
  {L : CategoryTheory.Functor A T} {R : CategoryTheory.Functor B T} {P : CategoryTheory.MorphismProperty T}
  {Q : CategoryTheory.MorphismProperty A} {W : CategoryTheory.MorphismProperty B}
  {X Y : CategoryTheory.MorphismProperty.Comma L R P Q W} (f : X.Hom Y), f.hom.left = f.left
Result.success

Testing || Nat.log_zero_right : ‚àÄ (b : ‚Ñï), Nat.log b 0 = 0
Result.success

Testing || ConvexOn.slope_le_deriv : ‚àÄ {S : Set ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} {x y : ‚Ñù},
  ConvexOn ‚Ñù S f ‚Üí x ‚àà S ‚Üí y ‚àà S ‚Üí x < y ‚Üí DifferentiableAt ‚Ñù f y ‚Üí slope f x y ‚â§ deriv f y
Result.success

Testing || NonemptyFinLinOrd.dualEquiv_functor : NonemptyFinLinOrd.dualEquiv.functor = NonemptyFinLinOrd.dual
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.PreGaloisCategory.toAut_hom_app_apply : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C] (F : CategoryTheory.Functor C FintypeCat) {G : Type u_1}
  [inst_1 : Group G] [inst_2 : (X : C) ‚Üí MulAction G ‚Üë(F.obj X)]
  [inst_3 : CategoryTheory.PreGaloisCategory.IsNaturalSMul F G] (g : G) {X : C} (x : ‚Üë(F.obj X)),
  ((CategoryTheory.PreGaloisCategory.toAut F G) g).hom.app X x = g ‚Ä¢ x
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.obj X ‚ü∂ F.obj X is not a `‚àÄ`

Testing || Std.DHashMap.Internal.List.insertEntry_of_containsKey_eq_false : ‚àÄ {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [inst : BEq Œ±] {l : List ((a : Œ±) √ó Œ≤ a)} {k : Œ±} {v : Œ≤ k},
  Std.DHashMap.Internal.List.containsKey k l = false ‚Üí Std.DHashMap.Internal.List.insertEntry k v l = ‚ü®k, v‚ü© :: l
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |__a___Œ±____Œ≤_a| is 1
; rep: (as @|__a___Œ±____Œ≤_a|_0 |__a___Œ±____Œ≤_a|)
; cardinality of |_Œ±| is 1
; rep: (as @|_Œ±|_0 |_Œ±|)
; cardinality of |_Œ≤_k| is 1
; rep: (as @|_Œ≤_k|_0 |_Œ≤_k|)
(define-fun _k () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _l () |_List__a___Œ±____Œ≤_a| _pl___)
(define-fun _Std.DHashMap.Internal.List.containsKey ((_arg_1 |_Œ±|) (_arg_2 |_List__a___Œ±____Œ≤_a|)) Bool false)
(define-fun _v () |_Œ≤_k| (as @|_Œ≤_k|_0 |_Œ≤_k|))
(define-fun _Std.DHashMap.Internal.List.insertEntry_k ((_arg_1 |_Œ≤_k|) (_arg_2 |_List__a___Œ±____Œ≤_a|)) |_List__a___Œ±____Œ≤_a| (_List.cons (as @|__a___Œ±____Œ≤_a|_0 |__a___Œ±____Œ≤_a|) (_List.cons (as @|__a___Œ±____Œ≤_a|_0 |__a___Œ±____Œ≤_a|) _pl___)))
(define-fun _Sigma.mk_k ((_arg_1 |_Œ≤_k|)) |__a___Œ±____Œ≤_a| (as @|__a___Œ±____Œ≤_a|_0 |__a___Œ±____Œ≤_a|))
)


Testing || AddSubmonoid.toOrderedAddCommMonoid.proof_2 : ‚àÄ {M : Type u_1} [inst : OrderedAddCommMonoid M] (S : AddSubmonoid M), Function.Injective fun a => ‚Üëa
Result.success

Testing || HasFDerivWithinAt.multiset_prod : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {s : Set E} {Œπ : Type u_5} {ùî∏' : Type u_7} [inst_3 : NormedCommRing ùî∏']
  [inst_4 : NormedAlgebra ùïú ùî∏'] {g : Œπ ‚Üí E ‚Üí ùî∏'} {g' : Œπ ‚Üí E ‚ÜíL[ùïú] ùî∏'} [inst_5 : DecidableEq Œπ] {u : Multiset Œπ}
  {x : E},
  (‚àÄ i ‚àà u, HasFDerivWithinAt (fun x => g i x) (g' i) s x) ‚Üí
    HasFDerivWithinAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod)
      (Multiset.map (fun i => (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod ‚Ä¢ g' i) u).sum s x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasFDerivWithinAt
  (fun x => cifvar_3 x_0 x) (cifvar_4 x_0) cifvar_5 cifvar_6`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Complex.map_isometryOfOrthonormal : ‚àÄ {F : Type u_6} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {F' : Type u_7}
  [inst_2 : NormedAddCommGroup F'] [inst_3 : InnerProductSpace ‚Ñù F'] (v : OrthonormalBasis (Fin 2) ‚Ñù F)
  (f : F ‚âÉ‚Çó·µ¢[‚Ñù] F'), Complex.isometryOfOrthonormal (v.map f) = (Complex.isometryOfOrthonormal v).trans f
Result.autoException ::
Auto failed to find proof

Testing || Finset.image_preimage : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] (f : Œ± ‚Üí Œ≤) (s : Finset Œ≤)
  [inst_1 : (x : Œ≤) ‚Üí Decidable (x ‚àà Set.range f)] (hf : Set.InjOn f (f ‚Åª¬π' ‚Üës)),
  Finset.image f (s.preimage f hf) = Finset.filter (fun x => x ‚àà Set.range f) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{x |
  cifvar_22 (cifvar_23 x_0 x) (cifvar_24 cifvar_19 x)}`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || UInt32.toNat_ofNat_of_lt : ‚àÄ {n : ‚Ñï}, n < UInt32.size ‚Üí (UInt32.ofNat n).toNat = n
Result.success

Testing || SimpleGraph.comap_comap : ‚àÄ {V : Type u_1} {W : Type u_2} {X : Type u_3} {G : SimpleGraph X} (f : V ‚Üí W) (g : W ‚Üí X),
  SimpleGraph.comap f (SimpleGraph.comap g G) = SimpleGraph.comap (g ‚àò f) G
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Subobject.ofMkLE_comp_ofLEMk : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [inst_1 : CategoryTheory.Mono f]
  (X : CategoryTheory.Subobject B) (g : A‚ÇÇ ‚ü∂ B) [inst_2 : CategoryTheory.Mono g]
  (h‚ÇÅ : CategoryTheory.Subobject.mk f ‚â§ X) (h‚ÇÇ : X ‚â§ CategoryTheory.Subobject.mk g),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h‚ÇÅ) (X.ofLEMk g h‚ÇÇ) =
    CategoryTheory.Subobject.ofMkLEMk f g ‚ãØ
Result.autoException ::
Auto failed to find proof

Testing || Primrec.option_bind‚ÇÅ : ‚àÄ {Œ± : Type u_1} {œÉ : Type u_3} [inst : Primcodable Œ±] [inst_1 : Primcodable œÉ] {f : Œ± ‚Üí Option œÉ},
  Primrec f ‚Üí Primrec fun o => o.bind f
Result.autoException ::
Auto failed to find proof

Testing || HasStrictFDerivAt.congr_of_eventuallyEq : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f f‚ÇÅ : E ‚Üí F}
  {f' : E ‚ÜíL[ùïú] F} {x : E}, HasStrictFDerivAt f f' x ‚Üí f =·∂†[nhds x] f‚ÇÅ ‚Üí HasStrictFDerivAt f‚ÇÅ f' x
Result.success

Testing || MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_le : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} [inst : TopologicalSpace Œ≤]
  [inst_1 : Preorder Œ≤] [inst_2 : OrderClosedTopology Œ≤] [inst_3 : TopologicalSpace.PseudoMetrizableSpace Œ≤]
  {f g : Œ± ‚Üí Œ≤},
  MeasureTheory.AEStronglyMeasurable f Œº ‚Üí
    MeasureTheory.AEStronglyMeasurable g Œº ‚Üí MeasureTheory.NullMeasurableSet {a | f a ‚â§ g a} Œº
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1 =·∂†[cifvar_9 x_0] x_2`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || List.sorted_mergeSort : ‚àÄ {Œ± : Type u_1} {le : Œ± ‚Üí Œ± ‚Üí Bool},
  (‚àÄ (a b c : Œ±), le a b = true ‚Üí le b c = true ‚Üí le a c = true) ‚Üí
    (‚àÄ (a b : Œ±), (le a b || le b a) = true) ‚Üí ‚àÄ (l : List Œ±), List.Pairwise (fun a b => le a b = true) (l.mergeSort le)
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  ‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (l : { l // l.length = n }),
    (List.splitInTwo l).1 = ‚ü®List.take ((n + 1) / 2) ‚Üël, ‚ãØ‚ü© is not type correct

Testing || List.forall_mem_inter_of_forall_right : ‚àÄ {Œ± : Type u_1} {l‚ÇÇ : List Œ±} {p : Œ± ‚Üí Prop} [inst : DecidableEq Œ±] (l‚ÇÅ : List Œ±), (‚àÄ x ‚àà l‚ÇÇ, p x) ‚Üí ‚àÄ x ‚àà l‚ÇÅ ‚à© l‚ÇÇ, p x
Result.success

Testing || ULift.addCancelMonoid.proof_4 : ‚àÄ {Œ± : Type u_2} [inst : AddCancelMonoid Œ±] (x : ULift.{u_1, u_2} Œ±) (x_1 : ‚Ñï),
  Equiv.ulift (x_1 ‚Ä¢ x) = Equiv.ulift (x_1 ‚Ä¢ x)
Result.success

Testing || List.nextOr_nil : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (x d : Œ±), [].nextOr x d = d
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 3
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
; rep: (as @|_Œ±|_2 |_Œ±|)
(define-fun _x () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _d () |_Œ±| (as @|_Œ±|_1 |_Œ±|))
(define-fun _List.nextOr ((_arg_1 |_List_Œ±|) (_arg_2 |_Œ±|) (_arg_3 |_Œ±|)) |_Œ±| (as @|_Œ±|_2 |_Œ±|))
)


Testing || Std.HashSet.get?_erase_self : ‚àÄ {Œ± : Type u} {x : BEq Œ±} {x_1 : Hashable Œ±} {m : Std.HashSet Œ±} [inst : EquivBEq Œ±] [inst : LawfulHashable Œ±] {k : Œ±},
  (m.erase k).get? k = none
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_| is 1
; rep: (as @|_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_|_0 |_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_|)
; cardinality of |_Œ±| is 2
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
(define-fun |_EquivBEq_Œ±| () Bool true)
(define-fun _m () |_Std.HashSet_Œ±| (_Std.HashSet.mk (_Std.HashMap.mk (as @|_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_|_0 |_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_|))))
(define-fun _k () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _Std.HashSet.erase ((_arg_1 |_Std.HashSet_Œ±|) (_arg_2 |_Œ±|)) |_Std.HashSet_Œ±| (_Std.HashSet.mk (_Std.HashMap.mk (as @|_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_|_1 |_Std.DHashMap_Œ±_fun_x_=>_PUnit._1_|))))
(define-fun _Std.HashSet.get? ((_arg_1 |_Std.HashSet_Œ±|) (_arg_2 |_Œ±|)) |_Option_Œ±| (_some (as @|_Œ±|_1 |_Œ±|)))
)


Testing || Rat.mk'_zero : ‚àÄ (d : ‚Ñï) (h : d ‚â† 0) (w : (Int.natAbs 0).Coprime d), { num := 0, den := d, den_nz := h, reduced := w } = 0
Result.autoException ::
Auto failed to find proof

Testing || Set.prod_univ : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±}, s √óÀ¢ Set.univ = Prod.fst ‚Åª¬π' s
Result.autoException ::
Auto failed to find proof

Testing || tangentMapWithin_id : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ùïú E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : Set M} {p : TangentBundle I M},
  UniqueMDiffWithinAt I s p.proj ‚Üí tangentMapWithin I I id s p = p
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceTangentSpace
  x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || affineSegment_eq_segment : ‚àÄ (R : Type u_1) {V : Type u_2} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V] (x y : V),
  affineSegment R x y = segment R x y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 (cifvar_9 x_0 x_1) ''
  cifvar_10 cifvar_11 cifvar_12`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || RingHom.OfLocalizationSpanTarget.ofIsLocalization : ‚àÄ {P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop},
  (RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => P) ‚Üí
    (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) ‚Üí
      ‚àÄ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S) (s : Set S),
        Ideal.span s = ‚ä§ ‚Üí
          (‚àÄ (r : ‚Üës), ‚àÉ T x x_1, ‚àÉ (_ : IsLocalization.Away (‚Üër) T), P ((algebraMap S T).comp f)) ‚Üí P f
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R‚úù of Œª binder contains bound variables

Testing || CompHausLike.LocallyConstant.functor_obj_val : ‚àÄ (P : TopCat ‚Üí Prop) [inst : CompHausLike.HasExplicitFiniteCoproducts P] [inst_1 : CompHausLike.HasExplicitPullbacks P]
  (hs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : X ‚ü∂ Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf)
  (X : Type (max u w)),
  ((CompHausLike.LocallyConstant.functor P hs).obj X).val = CompHausLike.LocallyConstant.functorToPresheaves.obj X
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet : ‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] [inst_5 : LocallyCompactSpace G] (Œº' Œº : MeasureTheory.Measure G)
  [inst_6 : Œº.IsHaarMeasure] [inst_7 : MeasureTheory.IsFiniteMeasureOnCompacts Œº'] [inst_8 : Œº'.IsMulLeftInvariant]
  {s : Set G}, MeasurableSet s ‚Üí IsCompact (closure s) ‚Üí Œº' s = Œº'.haarScalarFactor Œº ‚Ä¢ Œº s
Result.autoException ::
Auto failed to find proof

Testing || Mod_.comap_obj_X : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {A B : Mon_ C}
  (f : A ‚ü∂ B) (M : Mod_ B), ((Mod_.comap f).obj M).X = M.X
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearMap.coe_zero : ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4}
  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [inst_4 : TopologicalSpace M‚ÇÇ]
  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ], ‚Üë0 = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ| is 1
; rep: (as @|_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|_0 |_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|)
; cardinality of |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ| is 2
; rep: (as @|_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|_0 |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|)
; rep: (as @|_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|_1 |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|)
(define-fun _0_ () |_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ| (as @|_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|_0 |_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|))
(define-fun _ContinuousLinearMap.toLinearMap ((_arg_1 |_M‚ÇÅ__SL_œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|)) |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ| (as @|_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|_1 |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|))
(define-fun _0__0 () |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ| (as @|_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|_0 |_M‚ÇÅ_____œÉ‚ÇÅ‚ÇÇ__M‚ÇÇ|))
)


Testing || Function.Injective2.uncurry : ‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_6} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥},
  Function.Injective2 f ‚Üí Function.Injective (Function.uncurry f)
Result.autoException ::
Auto failed to find proof

Testing || FirstOrder.Language.ElementaryEmbedding.refl_apply : ‚àÄ {L : FirstOrder.Language} {M : Type u_1} [inst : L.Structure M] (x : M),
  (FirstOrder.Language.ElementaryEmbedding.refl L M) x = x
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamSort2SSortAux :: Unexpected error. Higher order input?

Testing || Cycle.isCycle_formPerm : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (s : Cycle Œ±) (h : s.Nodup), s.Nontrivial ‚Üí (s.formPerm h).IsCycle
Result.autoException ::
Auto failed to find proof

Testing || Matrix.inv_subsingleton : ‚àÄ {m : Type u} {Œ± : Type v} [inst : CommRing Œ±] [inst_1 : Subsingleton m] [inst_2 : Fintype m] [inst_3 : DecidableEq m]
  (A : Matrix m m Œ±), A‚Åª¬π = Matrix.diagonal fun i => Ring.inverse (A i i)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m m Œ± is not a `‚àÄ`

Testing || Submodule.dualAnnihilator_sup_eq : ‚àÄ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  (U V : Submodule R M), (U ‚äî V).dualAnnihilator = U.dualAnnihilator ‚äì V.dualAnnihilator
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || not_isMin : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : NoMinOrder Œ±] (a : Œ±), ¬¨IsMin a
Result.success

Testing || Combinatorics.Line.vertical_apply : ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7} (v : Œπ ‚Üí Œ±) (l : Combinatorics.Line Œ± Œπ') (x : Œ±),
  (fun x i => ((Combinatorics.Line.vertical v l).idxFun i).getD x) x = Sum.elim v ((fun x i => (l.idxFun i).getD x) x)
Result.autoException ::
Auto failed to find proof

Testing || QuasiIsoAt.quasiIso : ‚àÄ {Œπ : Type u_1} {C : Type u} {inst : CategoryTheory.Category.{v, u} C}
  {inst_1 : CategoryTheory.Limits.HasZeroMorphisms C} {c : ComplexShape Œπ} {K L : HomologicalComplex C c} {f : K ‚ü∂ L}
  {i : Œπ} {inst_2 : K.HasHomology i} {inst_3 : L.HasHomology i} [self : QuasiIsoAt f i],
  CategoryTheory.ShortComplex.QuasiIso ((HomologicalComplex.shortComplexFunctor C c i).map f)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œπ| is 1
; rep: (as @|_Œπ|_0 |_Œπ|)
; cardinality of _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C is 1
; rep: (as @_CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C_0 _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C)
; cardinality of _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C is 1
; rep: (as @_HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C_0 _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C)
; cardinality of _HomologicalComplex_C_c is 2
; rep: (as @_HomologicalComplex_C_c_0 _HomologicalComplex_C_c)
; rep: (as @_HomologicalComplex_C_c_1 _HomologicalComplex_C_c)
; cardinality of _CategoryTheory.ShortComplex_C is 2
; rep: (as @_CategoryTheory.ShortComplex_C_0 _CategoryTheory.ShortComplex_C)
; rep: (as @_CategoryTheory.ShortComplex_C_1 _CategoryTheory.ShortComplex_C)
; cardinality of _K___L is 1
; rep: (as @_K___L_0 _K___L)
; cardinality of _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L is 1
; rep: (as @_HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L_0 _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L)
(define-fun _i () |_Œπ| (as @|_Œπ|_0 |_Œπ|))
(define-fun _HomologicalComplex.shortComplexFunctor_C_c ((_arg_1 |_Œπ|)) _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C (as @_CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C_0 _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C))
(define-fun _CategoryTheory.Functor.toPrefunctor ((_arg_1 _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C)) _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C (as @_HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C_0 _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C))
(define-fun _K () _HomologicalComplex_C_c (as @_HomologicalComplex_C_c_0 _HomologicalComplex_C_c))
(define-fun _Prefunctor.obj ((_arg_1 _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C) (_arg_2 _HomologicalComplex_C_c)) _CategoryTheory.ShortComplex_C (ite (= (as @_HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C_0 _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C) _arg_1) (ite (= (as @_HomologicalComplex_C_c_1 _HomologicalComplex_C_c) _arg_2) (as @_CategoryTheory.ShortComplex_C_1 _CategoryTheory.ShortComplex_C) (as @_CategoryTheory.ShortComplex_C_0 _CategoryTheory.ShortComplex_C)) (as @_CategoryTheory.ShortComplex_C_0 _CategoryTheory.ShortComplex_C)))
(define-fun _CategoryTheory.ShortComplex.HasHomology ((_arg_1 _CategoryTheory.ShortComplex_C)) Bool true)
(define-fun _L () _HomologicalComplex_C_c (as @_HomologicalComplex_C_c_1 _HomologicalComplex_C_c))
(define-fun _f () _K___L (as @_K___L_0 _K___L))
(define-fun _fun_f_=>_QuasiIsoAt_f_i ((_arg_1 _K___L)) Bool true)
(define-fun _HomologicalComplex.shortComplexFunctor_C_c_i.map ((_arg_1 _K___L)) _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L (as @_HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L_0 _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L))
(define-fun _CategoryTheory.ShortComplex.QuasiIso ((_arg_1 _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L)) Bool false)
)


Testing || Continuous.locallyIntegrable : ‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]
  {f : X ‚Üí E} {Œº : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]
  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Œº] [inst_5 : SecondCountableTopologyEither X E],
  Continuous f ‚Üí MeasureTheory.LocallyIntegrable f Œº
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.simplicialToCosimplicialAugmented_map_right : ‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] {X Y : (CategoryTheory.SimplicialObject.Augmented C)·µí·µñ}
  (f : X ‚ü∂ Y),
  ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).right = CategoryTheory.NatTrans.rightOp f.unop.left
Result.autoException ::
Auto failed to find proof

Testing || contDiffOn_succ_iff_fderiv_apply : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {D : Type uD} [inst_1 : NormedAddCommGroup D]
  [inst_2 : NormedSpace ùïú D] {E : Type uE} [inst_3 : NormedAddCommGroup E] [inst_4 : NormedSpace ùïú E]
  [inst_5 : CompleteSpace ùïú] [inst_6 : FiniteDimensional ùïú D] {n : ‚Ñï} {f : D ‚Üí E} {s : Set D},
  UniqueDiffOn ùïú s ‚Üí
    (ContDiffOn ùïú (‚Üë(n + 1)) f s ‚Üî
      DifferentiableOn ùïú f s ‚àß ‚àÄ (y : D), ContDiffOn ùïú (‚Üën) (fun x => (fderivWithin ùïú f s x) y) s)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `ContDiffOn cifvar_13
  (cifvar_7 cifvar_9) (fun x => cifvar_16 (cifvar_17 cifvar_3 x) y) cifvar_3`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Finset.insert_erase : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {a : Œ±}, a ‚àà s ‚Üí insert a (s.erase a) = s
Result.success

Testing || PartENat.lt_add_one_iff_lt : ‚àÄ {x y : PartENat}, x ‚â† ‚ä§ ‚Üí (x < y + 1 ‚Üî x ‚â§ y)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || CategoryTheory.ShortComplex.Homotopy.refl_h‚ÇÄ : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {S‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C} (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ), (CategoryTheory.ShortComplex.Homotopy.refl œÜ).h‚ÇÄ = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ| is 1
; rep: (as @|_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ|_0 |_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ|)
; cardinality of |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ| is 2
; rep: (as @|_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|_0 |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|)
; rep: (as @|_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|_1 |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|)
(define-fun |_CategoryTheory.ShortComplex.Homotopy.refl_œÜ| () |_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ| (as @|_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ|_0 |_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ|))
(define-fun |_CategoryTheory.ShortComplex.Homotopy.h‚ÇÄ| ((_arg_1 |_CategoryTheory.ShortComplex.Homotopy_œÜ_œÜ|)) |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ| (as @|_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|_1 |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|))
(define-fun _0_ () |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ| (as @|_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|_0 |_S‚ÇÅ.X‚ÇÅ___S‚ÇÇ.X‚ÇÅ|))
)


Testing || NonUnitalContinuousFunctionalCalculus.predicate_zero : ‚àÄ (R : Type u_1) {A : Type u_2} {p : outParam (A ‚Üí Prop)} {inst : CommSemiring R} {inst_1 : Nontrivial R}
  {inst_2 : StarRing R} {inst_3 : MetricSpace R} {inst_4 : TopologicalSemiring R} {inst_5 : ContinuousStar R}
  {inst_6 : NonUnitalRing A} {inst_7 : StarRing A} {inst_8 : TopologicalSpace A} {inst_9 : Module R A}
  {inst_10 : IsScalarTower R A A} {inst_11 : SMulCommClass R A A} [self : NonUnitalContinuousFunctionalCalculus R p],
  p 0
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: outParam (A ‚Üí Prop) is not a `‚àÄ`

Testing || Filter.Germ.instAddMonoid.proof_3 : ‚àÄ {Œ± : Type u_2} {l : Filter Œ±} {M : Type u_1} [inst : AddMonoid M] (x x_1 : Œ± ‚Üí M), ‚Üë(x + x_1) = ‚Üë(x + x_1)
Result.success

Testing || TensorProduct.SMul.aux_of : ‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Type u_4} {N : Type u_5} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N] {R' : Type u_10} [inst_5 : SMul R' M] (r : R')
  (m : M) (n : N), (TensorProduct.SMul.aux r) (FreeAddMonoid.of (m, n)) = (r ‚Ä¢ m) ‚äó‚Çú[R] n
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.ComposableArrows.ext‚ÇÅ : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {F G : CategoryTheory.ComposableArrows C 1}
  (left : F.left = G.left) (right : F.right = G.right),
  F.hom =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom left)
        (CategoryTheory.CategoryStruct.comp G.hom (CategoryTheory.eqToHom ‚ãØ)) ‚Üí
    F = G
Result.autoException ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Fin.Ioo_eq_finset_subtype : ‚àÄ {n : ‚Ñï} (a b : Fin n), Finset.Ioo a b = Finset.fin n (Finset.Ioo ‚Üëa ‚Üëb)
Result.autoException ::
Auto failed to find proof

Testing || Pi.ringHom_injective : ‚àÄ {I : Type u} {f : I ‚Üí Type v} {Œ≥ : Type w} [inst : Nonempty I] [inst : (i : I) ‚Üí NonAssocSemiring (f i)]
  [inst_1 : NonAssocSemiring Œ≥] (g : (i : I) ‚Üí Œ≥ ‚Üí+* f i),
  (‚àÄ (i : I), Function.Injective ‚áë(g i)) ‚Üí Function.Injective ‚áë(Pi.ringHom g)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `inst‚úù¬π x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || MeasureTheory.mul_meas_ge_le_pow_eLpNorm : ‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} [inst : NormedAddCommGroup E] {p : ENNReal}
  (Œº : MeasureTheory.Measure Œ±) {f : Œ± ‚Üí E},
  p ‚â† 0 ‚Üí
    p ‚â† ‚ä§ ‚Üí
      MeasureTheory.AEStronglyMeasurable f Œº ‚Üí
        ‚àÄ (Œµ : ENNReal), Œµ * Œº {x | Œµ ‚â§ ‚Üë‚Äñf x‚Äñ‚Çä ^ p.toReal} ‚â§ MeasureTheory.eLpNorm f p Œº ^ p.toReal
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{x |
  cifvar_7 Œµ (cifvar_12 (cifvar_25 (cifvar_26 (cifvar_27 x))) (cifvar_14 x_0))}`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Orientation.map_symm : ‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : Module R N] (Œπ : Type u_4) (e : M ‚âÉ‚Çó[R] N),
  (Orientation.map Œπ e).symm = Orientation.map Œπ e.symm
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of _M____R__N is 1
; rep: (as @_M____R__N_0 _M____R__N)
; cardinality of |_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R| is 1
; rep: (as @|_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R|_0 |_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R|)
; cardinality of |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R| is 2
; rep: (as @|_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|_0 |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|)
; rep: (as @|_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|_1 |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|)
; cardinality of _N____R__M is 1
; rep: (as @_N____R__M_0 _N____R__M)
(define-fun _e () _M____R__N (as @_M____R__N_0 _M____R__N))
(define-fun |_Orientation.map_Œπ| ((_arg_1 _M____R__N)) |_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R| (as @|_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R|_0 |_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R|))
(define-fun _Equiv.symm ((_arg_1 |_Module.Ray_R_M___^Œπ____R__R___Module.Ray_R_N___^Œπ____R__R|)) |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R| (as @|_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|_0 |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|))
(define-fun _LinearEquiv.symm ((_arg_1 _M____R__N)) _N____R__M (as @_N____R__M_0 _N____R__M))
(define-fun |_Orientation.map_Œπ_0| ((_arg_1 _N____R__M)) |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R| (as @|_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|_1 |_Module.Ray_R_N___^Œπ____R__R___Module.Ray_R_M___^Œπ____R__R|))
)


Testing || TopologicalSpace.Opens.map_eq : ‚àÄ {X Y : TopCat} (f g : X ‚ü∂ Y), f = g ‚Üí TopologicalSpace.Opens.map f = TopologicalSpace.Opens.map g
Result.success

Testing || IsometryEquiv.surjective : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤),
  Function.Surjective ‚áëh
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Surjective
  (cifvar_4 x_0)`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || hasMFDerivWithinAt_extChartAt : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ùïú E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M}
  {x y : M},
  y ‚àà (chartAt H x).source ‚Üí
    HasMFDerivWithinAt I (modelWithCornersSelf ùïú E) (‚Üë(extChartAt I x)) s y (mfderiv I I (‚Üë(chartAt H x)) y)
Result.success

Testing || AddHom.op.proof_4 : ‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (x : AddHom M·µÉ·µí·µñ N·µÉ·µí·µñ),
  (fun f => { toFun := AddOpposite.op ‚àò ‚áëf ‚àò AddOpposite.unop, map_add' := ‚ãØ })
      ((fun f => { toFun := AddOpposite.unop ‚àò ‚áëf ‚àò AddOpposite.op, map_add' := ‚ãØ }) x) =
    (fun f => { toFun := AddOpposite.op ‚àò ‚áëf ‚àò AddOpposite.unop, map_add' := ‚ãØ })
      ((fun f => { toFun := AddOpposite.unop ‚àò ‚áëf ‚àò AddOpposite.op, map_add' := ‚ãØ }) x)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Function.Injective AddOpposite.unop is not a `‚àÄ`

Testing || CategoryTheory.Comonad.cofree_obj_A : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] (G : CategoryTheory.Comonad C) (X : C),
  (G.cofree.obj X).A = G.obj X
Result.autoException ::
Auto failed to find proof

Testing || Matroid.ground_finite : ‚àÄ {Œ± : Type u_1} (M : Matroid Œ±) [inst : M.Finite], M.E.Finite
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Matroid_Œ±| is 1
; rep: (as @|_Matroid_Œ±|_0 |_Matroid_Œ±|)
; cardinality of |_Set_Œ±| is 1
; rep: (as @|_Set_Œ±|_0 |_Set_Œ±|)
(define-fun _M () |_Matroid_Œ±| (as @|_Matroid_Œ±|_0 |_Matroid_Œ±|))
(define-fun _Matroid.Finite ((_arg_1 |_Matroid_Œ±|)) Bool true)
(define-fun _Matroid.E ((_arg_1 |_Matroid_Œ±|)) |_Set_Œ±| (as @|_Set_Œ±|_0 |_Set_Œ±|))
(define-fun _Set.Finite ((_arg_1 |_Set_Œ±|)) Bool false)
)


Testing || Nat.testBit_and : ‚àÄ (x y i : ‚Ñï), (x &&& y).testBit i = (x.testBit i && y.testBit i)
Result.autoException ::
Auto failed to find proof

Testing || Function.support_comp_eq_preimage : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : Zero M] (g : Œ≤ ‚Üí M) (f : Œ± ‚Üí Œ≤),
  Function.support (g ‚àò f) = f ‚Åª¬π' Function.support g
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Set_Œ±| is 2
; rep: (as @|_Set_Œ±|_0 |_Set_Œ±|)
; rep: (as @|_Set_Œ±|_1 |_Set_Œ±|)
; cardinality of |_Set_Œ≤| is 1
; rep: (as @|_Set_Œ≤|_0 |_Set_Œ≤|)
(define-fun _Function.support_g___f () |_Set_Œ±| (as @|_Set_Œ±|_0 |_Set_Œ±|))
(define-fun _Function.support_g () |_Set_Œ≤| (as @|_Set_Œ≤|_0 |_Set_Œ≤|))
(define-fun _Set.preimage_f ((_arg_1 |_Set_Œ≤|)) |_Set_Œ±| (as @|_Set_Œ±|_1 |_Set_Œ±|))
)


Testing || DFinsupp.lapply_comp_lsingle_of_ne : ‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} [inst : Semiring R] [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)]
  [inst_2 : (i : Œπ) ‚Üí Module R (M i)] [inst_3 : DecidableEq Œπ] (i i' : Œπ),
  i ‚â† i' ‚Üí DFinsupp.lapply i ‚àò‚Çó DFinsupp.lsingle i' = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œπ| is 2
; rep: (as @|_Œπ|_0 |_Œπ|)
; rep: (as @|_Œπ|_1 |_Œπ|)
; cardinality of |_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i| is 1
; rep: (as @|_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i|_0 |_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i|)
; cardinality of |_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i| is 1
; rep: (as @|_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i|_0 |_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i|)
; cardinality of _M_i_____R__M_i is 2
; rep: (as @_M_i_____R__M_i_0 _M_i_____R__M_i)
; rep: (as @_M_i_____R__M_i_1 _M_i_____R__M_i)
(define-fun _i () |_Œπ| (as @|_Œπ|_0 |_Œπ|))
(define-fun _i_ () |_Œπ| (as @|_Œπ|_1 |_Œπ|))
(define-fun _DFinsupp.lapply_i () |_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i| (as @|_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i|_0 |_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i|))
(define-fun _DFinsupp.lsingle_i_ () |_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i| (as @|_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i|_0 |_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i|))
(define-fun _LinearMap.comp ((_arg_1 |_Œ†‚ÇÄ__i___Œπ___M_i____R__M_i|) (_arg_2 |_M_i_____R__Œ†‚ÇÄ__i___Œπ___M_i|)) _M_i_____R__M_i (as @_M_i_____R__M_i_1 _M_i_____R__M_i))
(define-fun _0_ () _M_i_____R__M_i (as @_M_i_____R__M_i_0 _M_i_____R__M_i))
)


Elapsed time: 115516 ms

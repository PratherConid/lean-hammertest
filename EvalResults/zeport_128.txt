Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || PrimeMultiset.prod_zero : PrimeMultiset.prod 0 = 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Multiset.prod cifvar_3`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || jacobiSym.zero_right : âˆ€ (a : â„¤), jacobiSym a 0 = 1
Result.autoException ::
Auto failed to find proof

Testing || Rel.image_bot : âˆ€ {Î± : Type u_1} {Î² : Type u_2} (s : Set Î±), âŠ¥.image s = âˆ…
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (âˆ€ x0 : #1, (âˆ€ x1 : #3, (âˆ€ x2 : #2, ((!4 (!0 x0 x2) x1) = (âˆƒ x3 : #4, ((!6 x2 x3) âˆ§ (x0 x3 x1))))))) is not type correct

Testing || MeasureTheory.hasFiniteIntegral_const : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : NormedAddCommGroup Î²]
  [inst_1 : MeasureTheory.IsFiniteMeasure Î¼] (c : Î²), MeasureTheory.HasFiniteIntegral (fun x => c) Î¼
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasureTheory.HasFiniteIntegral
  (fun x => x_1) x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || isPurelyInseparable_iff_finSepDegree_eq_one : âˆ€ (F : Type u) (E : Type v) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E],
  IsPurelyInseparable F E â†” Field.finSepDegree F E = 1
Result.success

Testing || IsLocalization.map_integerMultiple : âˆ€ {R : Type u_1} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_2} [inst_1 : CommSemiring S]
  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] {Î¹ : Type u_4} (s : Finset Î¹) (f : Î¹ â†’ S) (i : { x // x âˆˆ s }),
  (algebraMap R S) (IsLocalization.integerMultiple M s f i) = IsLocalization.commonDenom M s f â€¢ f â†‘i
Result.autoException ::
Auto failed to find proof

Testing || OrderIso.isBoundedUnder_le_comp : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] (e : Î± â‰ƒo Î²) {l : Filter Î³}
  {u : Î³ â†’ Î±},
  (Filter.IsBoundedUnder (fun x1 x2 => x1 â‰¤ x2) l fun x => e (u x)) â†” Filter.IsBoundedUnder (fun x1 x2 => x1 â‰¤ x2) l u
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Surjective
  (cifvar_7 x_0)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.ceil_eq_zero : âˆ€ {Î± : Type u_2} [inst : LinearOrderedSemiring Î±] [inst_1 : FloorSemiring Î±] {a : Î±}, âŒˆaâŒ‰â‚Š = 0 â†” a â‰¤ 0
Result.success

Testing || CategoryTheory.ComposableArrows.naturality'_assoc : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {n : â„•} {F G : CategoryTheory.ComposableArrows C n}
  (Ï† : F âŸ¶ G) (i j : â„•) (hij : autoParam (i â‰¤ j) _autoâœ) (hj : autoParam (j â‰¤ n) _autoâœÂ¹) {Z : C} (h : G.obj' j hj âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (F.map' i j hij hj)
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.app' Ï† j hj) h) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.app' Ï† i â‹¯)
      (CategoryTheory.CategoryStruct.comp (G.map' i j hij hj) h)
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  Â¬CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE â‹¯))
        (CategoryTheory.CategoryStruct.comp (Ï†.app âŸ¨j, â‹¯âŸ©) h) =
      CategoryTheory.CategoryStruct.comp (Ï†.app âŸ¨i, â‹¯âŸ©)
        (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.homOfLE â‹¯)) h) is not type correct

Testing || Fin.partialProd_left_inv : âˆ€ {n : â„•} {G : Type u_3} [inst : Group G] (f : Fin (n + 1) â†’ G),
  (f 0 â€¢ Fin.partialProd fun i => (f â†‘â†‘i)â»Â¹ * f i.succ) = f
Result.autoException ::
Auto failed to find proof

Testing || Submonoid.exists_mulEquiv_eq_mgraph : âˆ€ {H : Type u_2} {I : Type u_3} [inst : Monoid H] [inst_1 : Monoid I] {G : Submonoid (H Ã— I)},
  Function.Bijective (Prod.fst âˆ˜ â‡‘G.subtype) â†’
    Function.Bijective (Prod.snd âˆ˜ â‡‘G.subtype) â†’ âˆƒ e, G = e.toMonoidHom.mgraph
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_13 x_0 x }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CoalgebraCat.toCoalgHom_id : âˆ€ {R : Type u} [inst : CommRing R] {M : CoalgebraCat R},
  (CategoryTheory.CategoryStruct.id M).toCoalgHom = CoalgHom.id R â†‘M.toModuleCat
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€
  (map_comp_comul : TensorProduct.map LinearMap.id LinearMap.id âˆ˜â‚— Coalgebra.comul = Coalgebra.comul âˆ˜â‚— LinearMap.id),
  CoalgHom.id R â†‘M.toModuleCat =
    { toLinearMap := LinearMap.id, counit_comp := counit_comp,
      map_comp_comul := map_comp_comul }, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || CategoryTheory.isIso_op_iff : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y),
  CategoryTheory.IsIso f.op â†” CategoryTheory.IsIso f
Result.autoException ::
Auto failed to find proof

Testing || FreeGroup.lift.of : âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î²] {f : Î± â†’ Î²} {x : Î±}, (FreeGroup.lift f) (FreeGroup.of x) = f x
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Limits.InitialMonoClass.of_terminal : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasTerminal C],
  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C)) â†’ CategoryTheory.Limits.InitialMonoClass C
Result.autoException ::
Auto failed to find proof

Testing || AddSubgroup.unop_injective : âˆ€ {G : Type u_2} [inst : AddGroup G], Function.Injective AddSubgroup.unop
Result.autoException ::
Auto failed to find proof

Testing || WeierstrassCurve.Projective.Point.toAffineAddEquiv_apply : âˆ€ {F : Type v} [inst : Field F] (W : WeierstrassCurve.Projective F) (P : W.Point),
  (WeierstrassCurve.Projective.Point.toAffineAddEquiv W) P = P.toAffineLift
Result.success

Testing || Nat.zeckendorf_of_pos : âˆ€ {n : â„•}, 0 < n â†’ n.zeckendorf = n.greatestFib :: (n - Nat.fib n.greatestFib).zeckendorf
Result.autoException ::
Auto failed to find proof

Testing || AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_eq_iff_eq : âˆ€ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {P : Type u_3}
  [inst_2 : AddCommMonoid P] (f : S.LocalizationMap N) {k : N â‰ƒ+ P} {x : M} {y : P},
  (f.ofAddEquivOfLocalizations k).toMap x = y â†” f.toMap x = k.symm y
Result.success

Testing || RingEquiv.unop_map_list_prod : âˆ€ {R : Type u_2} {S : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] (f : R â‰ƒ+* Sáµáµ’áµ–) (l : List R),
  MulOpposite.unop (f l.prod) = (List.map (MulOpposite.unop âˆ˜ â‡‘f) l).reverse.prod
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2 âˆ˜ cifvar_3 x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Order.Ideal.IsProper.not_mem_or_compl_not_mem : âˆ€ {P : Type u_1} [inst : BooleanAlgebra P] {x : P} {I : Order.Ideal P}, I.IsProper â†’ x âˆ‰ I âˆ¨ xá¶œ âˆ‰ I
Result.success

Testing || Complex.cos_int_mul_two_pi_sub_pi : âˆ€ (n : â„¤), Complex.cos (â†‘n * (2 * â†‘Real.pi) - â†‘Real.pi) = -1
Result.success

Testing || LinearMap.finrank_range_dualMap_eq_finrank_range : âˆ€ {K : Type uK} [inst : Field K] {Vâ‚ : Type uVâ‚} {Vâ‚‚ : Type uVâ‚‚} [inst_1 : AddCommGroup Vâ‚]
  [inst_2 : _root_.Module K Vâ‚] [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : _root_.Module K Vâ‚‚] (f : Vâ‚ â†’â‚—[K] Vâ‚‚),
  Module.finrank K â†¥(LinearMap.range f.dualMap) = Module.finrank K â†¥(LinearMap.range f)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Functor.Monoidal.whiskerRight_app_snd_assoc : âˆ€ {J : Type u_1} {C : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} J]
  [inst_1 : CategoryTheory.Category.{u_4, u_2} C] [inst_2 : CategoryTheory.ChosenFiniteProducts C]
  {Fâ‚ Fâ‚' : CategoryTheory.Functor J C} (f : Fâ‚ âŸ¶ Fâ‚') (Fâ‚‚ : CategoryTheory.Functor J C) (j : J) {Z : C}
  (h : Fâ‚‚.obj j âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategory.whiskerRight f Fâ‚‚).app j)
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (Fâ‚'.obj j) (Fâ‚‚.obj j)) h) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (Fâ‚.obj j) (Fâ‚‚.obj j)) h
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || NNRat.floor_coe : âˆ€ (q : â„šâ‰¥0), âŒŠâ†‘qâŒ‹â‚Š = âŒŠqâŒ‹â‚Š
Result.success

Testing || ContinuousAt.comp_of_eq : âˆ€ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : X â†’ Y} {x : X} {y : Y} {g : Y â†’ Z},
  ContinuousAt g y â†’ ContinuousAt f x â†’ f x = y â†’ ContinuousAt (g âˆ˜ f) x
Result.success

Testing || List.Ico.zero_bot : âˆ€ (n : â„•), List.Ico 0 n = List.range n
Result.success

Testing || fderiv_csin : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {x : E},
  DifferentiableAt â„‚ f x â†’ fderiv â„‚ (fun x => Complex.sin (f x)) x = Complex.cos (f x) â€¢ fderiv â„‚ f x
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.memâ„’p_stoppedProcess : âˆ€ {Î© : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} {Ï„ : Î© â†’ Î¹} {E : Type u_4}
  {p : ENNReal} {u : Î¹ â†’ Î© â†’ E} [inst : LinearOrder Î¹] [inst_1 : TopologicalSpace Î¹] [inst_2 : OrderTopology Î¹]
  [inst_3 : FirstCountableTopology Î¹] {â„± : MeasureTheory.Filtration Î¹ m} [inst_4 : NormedAddCommGroup E]
  [inst_5 : LocallyFiniteOrderBot Î¹],
  MeasureTheory.IsStoppingTime â„± Ï„ â†’
    (âˆ€ (n : Î¹), MeasureTheory.Memâ„’p (u n) p Î¼) â†’ âˆ€ (n : Î¹), MeasureTheory.Memâ„’p (MeasureTheory.stoppedProcess u Ï„ n) p Î¼
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasureTheory.Memâ„’p (cifvar_6 x_0)
  cifvar_7 cifvar_8`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.divisorsAntidiagonal_one : Nat.divisorsAntidiagonal 1 = {(1, 1)}
Result.success

Testing || InnerProductGeometry.sin_angle_sub_of_inner_eq_zero : âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},
  inner x y = 0 â†’ x â‰  0 âˆ¨ y â‰  0 â†’ Real.sin (InnerProductGeometry.angle x (x - y)) = â€–yâ€– / â€–x - yâ€–
Result.success

Testing || Finset.sup'_lt_iff : âˆ€ {Î± : Type u_2} {Î¹ : Type u_5} [inst : LinearOrder Î±] {s : Finset Î¹} (H : s.Nonempty) {f : Î¹ â†’ Î±} {a : Î±},
  s.sup' H f < a â†” âˆ€ i âˆˆ s, f i < a
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.ShortComplex.opcyclesMap'_smul : âˆ€ {R : Type u_1} {C : Type u_2} [inst : Semiring R] [inst_1 : CategoryTheory.Category.{u_3, u_2} C]
  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Linear R C] {Sâ‚ Sâ‚‚ : CategoryTheory.ShortComplex C}
  (Ï† : Sâ‚ âŸ¶ Sâ‚‚) (hâ‚ : Sâ‚.RightHomologyData) (hâ‚‚ : Sâ‚‚.RightHomologyData) (a : R),
  CategoryTheory.ShortComplex.opcyclesMap' (a â€¢ Ï†) hâ‚ hâ‚‚ = a â€¢ CategoryTheory.ShortComplex.opcyclesMap' Ï† hâ‚ hâ‚‚
Result.autoException ::
Auto failed to find proof

Testing || WithLp.equiv_sub : âˆ€ (p : ENNReal) {V : Type uV} [inst : AddCommGroup V] (x y : WithLp p V),
  (WithLp.equiv p V) (x - y) = (WithLp.equiv p V) x - (WithLp.equiv p V) y
Result.success

Testing || LinearMap.BilinForm.isCompl_orthogonal_iff_disjoint : âˆ€ {V : Type u_5} {K : Type u_6} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]
  [inst_3 : FiniteDimensional K V] {B : LinearMap.BilinForm K V} {W : Submodule K V},
  B.IsRefl â†’ (IsCompl W (B.orthogonal W) â†” Disjoint W (B.orthogonal W))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_15 x_0 x }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || edist_pi_def : âˆ€ {Î² : Type v} {Ï€ : Î² â†’ Type u_2} [inst : Fintype Î²] [inst_1 : (b : Î²) â†’ EDist (Ï€ b)] (f g : (b : Î²) â†’ Ï€ b),
  edist f g = Finset.univ.sup fun b => edist (f b) (g b)
Result.success

Testing || EReal.le_limsup_add : âˆ€ {Î± : Type u_3} {f : Filter Î±} {u v : Î± â†’ EReal}, Filter.limsup u f + Filter.liminf v f â‰¤ Filter.limsup (u + v) f
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆƒá¶  (a : Î±) in x_0,
  cifvar_7 y (cifvar_11 a)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.levyProkhorovEDist_lt_top : âˆ€ {Î© : Type u_1} [inst : MeasurableSpace Î©] [inst_1 : PseudoEMetricSpace Î©] (Î¼ Î½ : MeasureTheory.Measure Î©)
  [inst_2 : MeasureTheory.IsFiniteMeasure Î¼] [inst_3 : MeasureTheory.IsFiniteMeasure Î½],
  MeasureTheory.levyProkhorovEDist Î¼ Î½ < âŠ¤
Result.success

Testing || Complex.lim_re : âˆ€ (f : CauSeq â„‚ â‡‘Complex.abs), (Complex.cauSeqRe f).lim = f.lim.re
Result.autoException ::
Auto failed to find proof

Testing || Homotopy.nullHomotopicMap'_f : âˆ€ {Î¹ : Type u_1} {V : Type u} [inst : CategoryTheory.Category.{v, u} V] [inst_1 : CategoryTheory.Preadditive V]
  {c : ComplexShape Î¹} {C D : HomologicalComplex V c} {kâ‚‚ kâ‚ kâ‚€ : Î¹} (râ‚‚â‚ : c.Rel kâ‚‚ kâ‚) (râ‚â‚€ : c.Rel kâ‚ kâ‚€)
  (h : (i j : Î¹) â†’ c.Rel j i â†’ (C.X i âŸ¶ D.X j)),
  (Homotopy.nullHomotopicMap' h).f kâ‚ =
    CategoryTheory.CategoryStruct.comp (C.d kâ‚ kâ‚€) (h kâ‚€ kâ‚ râ‚â‚€) +
      CategoryTheory.CategoryStruct.comp (h kâ‚ kâ‚‚ râ‚‚â‚) (D.d kâ‚‚ kâ‚)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_22.d x_0 cifvar_3`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Limits.hasColimitsOfShape_of_closed_under_colimits : âˆ€ {J : Type w} [inst : CategoryTheory.Category.{w', w} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {P : C â†’ Prop},
  CategoryTheory.Limits.ClosedUnderColimitsOfShape J P â†’
    âˆ€ [inst_2 : CategoryTheory.Limits.HasColimitsOfShape J C],
      CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.FullSubcategory P)
Result.success

Testing || Filter.EventuallyEq.prod_mk : âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {l : Filter Î±} {f f' : Î± â†’ Î²},
  f =á¶ [l] f' â†’ âˆ€ {g g' : Î± â†’ Î³}, g =á¶ [l] g' â†’ (fun x => (f x, g x)) =á¶ [l] fun x => (f' x, g' x)
Result.autoException ::
Auto failed to find proof

Testing || List.not_eq_key : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {a : Î±} {l : List (Sigma Î²)}, a âˆ‰ l.keys â†” âˆ€ s âˆˆ l, a â‰  s.fst
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Î² x_0 of Î» binder contains bound variables

Testing || PadicInt.mkUnits_eq : âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {u : â„š_[p]} (h : â€–uâ€– = 1), â†‘â†‘(PadicInt.mkUnits h) = u
Result.success

Testing || Filter.tendsto_mul_const_atTop_of_pos : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedSemifield Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±},
  0 < r â†’ (Filter.Tendsto (fun x => f x * r) l Filter.atTop â†” Filter.Tendsto f l Filter.atTop)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.Tendsto
  (fun x => cifvar_10 x_1 (cifvar_10 (cifvar_14 x) cifvar_2)) x_0 cifvar_7`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || WithTop.coe_nat : âˆ€ {Î± : Type u} [inst : AddMonoidWithOne Î±] (n : â„•), â†‘â†‘n = â†‘n
Result.success

Testing || Nat.factorization_lcm : âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ (a.lcm b).factorization = a.factorization âŠ” b.factorization
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `instDistribLatticeOfLinearOrder`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matrix.linfty_op_nnnorm_mul : âˆ€ {l : Type u_2} {m : Type u_3} {n : Type u_4} {Î± : Type u_5} [inst : Fintype l] [inst_1 : Fintype m]
  [inst_2 : Fintype n] [inst_3 : NonUnitalSeminormedRing Î±] (A : Matrix l m Î±) (B : Matrix m n Î±),
  â€–A * Bâ€–â‚Š â‰¤ â€–Aâ€–â‚Š * â€–Bâ€–â‚Š
Result.success

Testing || Finset.insert_idem : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (s : Finset Î±), insert a (insert a s) = insert a s
Result.success

Testing || Cardinal.lift_injective : Function.Injective Cardinal.lift.{u, v}
Result.autoException ::
Auto failed to find proof

Testing || Antitone.map_iSup_of_continuousAt' : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]
  [inst_2 : OrderTopology Î±] [inst_3 : ConditionallyCompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²]
  [inst_5 : OrderClosedTopology Î²] {Î¹ : Sort u_3} [inst_6 : Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±},
  ContinuousAt f (iSup g) â†’ Antitone f â†’ autoParam (BddAbove (Set.range g)) _autoâœ â†’ f (â¨† i, g i) = â¨… i, f (g i)
Result.success

Testing || CategoryTheory.PreOneHypercover.map_f : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {X : C} (E : CategoryTheory.PreOneHypercover X) (F : CategoryTheory.Functor C D) (i : E.Iâ‚€),
  (E.map F).f i = F.map (E.f i)
Result.success

Testing || nhds_bot_basis_Iic : âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderBot Î±] [inst_3 : OrderTopology Î±]
  [inst_4 : Nontrivial Î±] [inst_5 : DenselyOrdered Î±], (nhds âŠ¥).HasBasis (fun a => âŠ¥ < a) Set.Iic
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderTop.toTop`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || exists_floor : âˆ€ {Î± : Type u_1} [inst : StrictOrderedRing Î±] [inst_1 : Archimedean Î±] (x : Î±), âˆƒ fl, âˆ€ (z : â„¤), z â‰¤ fl â†” â†‘z â‰¤ x
Result.autoException ::
Auto failed to find proof

Testing || Acc.cutExpand : âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : IsIrrefl Î± r] {a : Î±}, Acc r a â†’ Acc (Relation.CutExpand r) {a}
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_2.erase a`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddCon.orderIsoOp.proof_2 : âˆ€ {M : Type u_1} [inst : Add M] (x : AddCon Máµƒáµ’áµ–), x.unop.op = x.unop.op
Result.success

Testing || CategoryTheory.Presheaf.isSheaf_coherent_of_hasPullbacks_of_comp : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] {A : Type uâ‚ƒ}
  [inst_1 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} A] (F : CategoryTheory.Functor Cáµ’áµ– A) {B : Type uâ‚„}
  [inst_2 : CategoryTheory.Category.{vâ‚„, uâ‚„} B] (s : CategoryTheory.Functor A B) [inst_3 : CategoryTheory.Preregular C]
  [inst_4 : CategoryTheory.FinitaryExtensive C]
  [h : âˆ€ {Y X : C} (f : Y âŸ¶ X) [inst_5 : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f]
  [inst_5 : CategoryTheory.Limits.ReflectsFiniteLimits s],
  CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) (F.comp s) â†’
    CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F
Result.autoException ::
Auto failed to find proof

Testing || add_lt_of_neg_right : âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : LT Î±] [inst_2 : AddLeftStrictMono Î±] (a : Î±) {b : Î±},
  b < 0 â†’ a + b < a
Result.success

Testing || Nat.Prime.not_dvd_mul : âˆ€ {p m n : â„•}, Nat.Prime p â†’ Â¬p âˆ£ m â†’ Â¬p âˆ£ n â†’ Â¬p âˆ£ m * n
Result.success

Testing || addOrderOf_dvd_natCard : âˆ€ {G : Type u_6} [inst : AddGroup G] (x : G), addOrderOf x âˆ£ Nat.card G
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Fintype.card cifvar_5`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.Nonempty.sigma_fst : âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} {s : Set Î¹} {t : (i : Î¹) â†’ Set (Î± i)}, (s.sigma t).Nonempty â†’ s.Nonempty
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.OverPresheafAux.OverArrows.mapâ‚_mapâ‚‚ : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {A F G : CategoryTheory.Functor Cáµ’áµ– (Type v)} {Î· : F âŸ¶ A}
  {Î¼ : G âŸ¶ A} (Îµ : F âŸ¶ G) (hÎµ : CategoryTheory.CategoryStruct.comp Îµ Î¼ = Î·) {X Y : C}
  {s : CategoryTheory.yoneda.obj X âŸ¶ A} {t : CategoryTheory.yoneda.obj Y âŸ¶ A} (f : X âŸ¶ Y)
  (hf : CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t = s)
  (u : CategoryTheory.OverPresheafAux.OverArrows Î· t), (u.mapâ‚ Îµ hÎµ).mapâ‚‚ f hf = (u.mapâ‚‚ f hf).mapâ‚ Îµ hÎµ
Result.autoException ::
Auto failed to find proof

Testing || WeierstrassCurve.Jacobian.Point.toAffine_add : âˆ€ {F : Type v} [inst : Field F] {W : WeierstrassCurve.Jacobian F} {P Q : Fin 3 â†’ F},
  W.Nonsingular P â†’
    W.Nonsingular Q â†’
      WeierstrassCurve.Jacobian.Point.toAffine W (W.add P Q) =
        WeierstrassCurve.Jacobian.Point.toAffine W P + WeierstrassCurve.Jacobian.Point.toAffine W Q
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_11 x_0 =
  cifvar_29 (cifvar_30 (cifvar_14 cifvar_23) cifvar_31)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Units.inv_eq_of_mul_eq_one_right : âˆ€ {Î± : Type u} [inst : Monoid Î±] {u : Î±Ë£} {a : Î±}, â†‘u * a = 1 â†’ â†‘uâ»Â¹ = a
Result.success

Testing || LieIdeal.derivedSeries_eq_bot_iff : âˆ€ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] (I : LieIdeal R L)
  (k : â„•), LieAlgebra.derivedSeries R (â†¥I) k = âŠ¥ â†” LieAlgebra.derivedSeriesOfIdeal R L k I = âŠ¥
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_13 x_0 x }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SemiNormedGrp.explicitCokernelDesc_norm_le_of_norm_le : âˆ€ {X Y Z : SemiNormedGrp} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} (w : CategoryTheory.CategoryStruct.comp f g = 0) (c : NNReal),
  â€–gâ€– â‰¤ â†‘c â†’ â€–SemiNormedGrp.explicitCokernelDesc wâ€– â‰¤ â†‘c
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_34 x_0).str`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.NatIso.pi_inv : âˆ€ {I : Type wâ‚€} {C : I â†’ Type uâ‚} [inst : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)] {D : I â†’ Type uâ‚‚}
  [inst_1 : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)] {F G : (i : I) â†’ CategoryTheory.Functor (C i) (D i)}
  (e : (i : I) â†’ F i â‰… G i), (CategoryTheory.NatIso.pi e).inv = CategoryTheory.NatTrans.pi fun i => (e i).inv
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `instâœÂ¹ i`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ChartedSpace.liftPropAt_iff : âˆ€ {H : Type u_1} {M : Type u_2} {H' : Type u_3} {M' : Type u_4} [inst : TopologicalSpace H]
  [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M] [inst_3 : TopologicalSpace H']
  [inst_4 : TopologicalSpace M'] [inst_5 : ChartedSpace H' M'] {P : (H â†’ H') â†’ Set H â†’ H â†’ Prop} {f : M â†’ M'} {x : M},
  ChartedSpace.LiftPropAt P f x â†”
    ContinuousAt f x âˆ§ P (â†‘(chartAt H' (f x)) âˆ˜ f âˆ˜ â†‘(chartAt H x).symm) Set.univ (â†‘(chartAt H x) x)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_20 âˆ˜
  cifvar_22 (cifvar_23 (cifvar_9 x_1))`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submodule.mul_def : âˆ€ (R : Type u) [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M N : Submodule R A),
  M * N = Submodule.span R (â†‘M * â†‘N)
Result.success

Testing || MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_topâ‚€ : âˆ€ {Î± : Type u_1} {Î¹ : Type u_5} {x : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},
  (âˆ€ (i : Î¹), MeasureTheory.NullMeasurableSet (As i) Î¼) â†’
    Pairwise (MeasureTheory.AEDisjoint Î¼ on As) â†’ Î¼ (â‹ƒ i, As i) â‰  âŠ¤ â†’ {i | 0 < Î¼ (As i)}.Countable
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `StrictAnti u`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Limits.isoZeroOfMonoZero_hom : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]
  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} (x : CategoryTheory.Mono 0),
  (CategoryTheory.Limits.isoZeroOfMonoZero x).hom = 0
Result.success

Testing || CategoryTheory.InjectiveResolution.descFOne_zero_comm : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {Y Z : C} (f : Z âŸ¶ Y)
  (I : CategoryTheory.InjectiveResolution Y) (J : CategoryTheory.InjectiveResolution Z),
  CategoryTheory.CategoryStruct.comp (J.cocomplex.d 0 1) (CategoryTheory.InjectiveResolution.descFOne f I J) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descFZero f I J) (I.cocomplex.d 0 1)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.Î¹`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Computation.get_bind : âˆ€ {Î± : Type u} {Î² : Type v} (s : Computation Î±) (f : Î± â†’ Computation Î²) [inst : s.Terminates]
  [inst_1 : (f s.get).Terminates], (s.bind f).get = (f s.get).get
Result.success

Testing || Set.Finite.bddAbove : âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x1 x2 => x1 â‰¤ x2] [inst_2 : Nonempty Î±] {s : Set Î±},
  s.Finite â†’ BddAbove s
Result.autoException ::
Auto failed to find proof

Testing || fourier_add : âˆ€ {T : â„} {m n : â„¤} {x : AddCircle T}, (fourier (m + n)) x = (fourier m) x * (fourier n) x
Result.autoException ::
Auto failed to find proof

Testing || Topology.IsInducing.functor_obj : âˆ€ {X Y : TopCat} {f : X âŸ¶ Y} (hf : Topology.IsInducing â‡‘f) (U : TopologicalSpace.Opens â†‘X),
  hf.functor.obj U = hf.functorObj U
Result.success

Testing || Submonoid.map_powers : âˆ€ {M : Type u_1} [inst : Monoid M] {N : Type u_4} {F : Type u_5} [inst_1 : Monoid N] [inst_2 : FunLike F M N]
  [inst_3 : MonoidHomClass F M N] (f : F) (m : M), Submonoid.map f (Submonoid.powers m) = Submonoid.powers (f m)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 x_0 '' x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || HasFDerivWithinAt.hasMFDerivWithinAt : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace ğ•œ E'] {f : E â†’ E'}
  {s : Set E} {x : E}
  {f' : TangentSpace (modelWithCornersSelf ğ•œ E) x â†’L[ğ•œ] TangentSpace (modelWithCornersSelf ğ•œ E') (f x)},
  HasFDerivWithinAt f f' s x â†’ HasMFDerivWithinAt (modelWithCornersSelf ğ•œ E) (modelWithCornersSelf ğ•œ E') f s x f'
Result.autoException ::
Auto failed to find proof

Testing || LieAlgebra.IsKilling.corootSpace_zero_eq_bot : âˆ€ (K : Type u_2) (L : Type u_3) [inst : LieRing L] [inst_1 : Field K] [inst_2 : LieAlgebra K L]
  [inst_3 : FiniteDimensional K L] (H : LieSubalgebra K L) [inst_4 : H.IsCartanSubalgebra]
  [inst_5 : LieAlgebra.IsKilling K L], LieAlgebra.corootSpace 0 = âŠ¥
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_11 x_0 x }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || RCLike.norm_im_le_norm : âˆ€ {K : Type u_1} [inst : RCLike K] (z : K), â€–RCLike.im zâ€– â‰¤ â€–zâ€–
Result.success

Testing || one_zpow : âˆ€ {Î± : Type u_1} [inst : DivisionMonoid Î±] (n : â„¤), 1 ^ n = 1
Result.autoException ::
Auto failed to find proof

Testing || sub_lt_of_abs_sub_lt_right : âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, |a - b| < c â†’ a - c < b
Result.success

Testing || Dilation.comp_apply : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²]
  [inst_2 : PseudoEMetricSpace Î³] (g : Î² â†’áµˆ Î³) (f : Î± â†’áµˆ Î²) (x : Î±), (g.comp f) x = g (f x)
Result.success

Testing || CategoryTheory.GrothendieckTopology.plusLift_unique : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}
  [inst_1 : CategoryTheory.Category.{max v u, w} D]
  [inst_2 :
    âˆ€ (P : CategoryTheory.Functor Cáµ’áµ– D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)]
  [inst_3 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)áµ’áµ– D] {P Q : CategoryTheory.Functor Cáµ’áµ– D}
  (Î· : P âŸ¶ Q) (hQ : CategoryTheory.Presheaf.IsSheaf J Q) (Î³ : J.plusObj P âŸ¶ Q),
  CategoryTheory.CategoryStruct.comp (J.toPlus P) Î³ = Î· â†’ Î³ = J.plusLift Î· hQ
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2.instPreorderCover x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Auto.Embedding.Lam.BVLems.shl_equiv : âˆ€ {n : â„•} (a : BitVec n) (b : â„•), a <<< b = if b < n then a <<< BitVec.ofNat n b else 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `BitVec.ofNat x_0 x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LinearMap.prodMap_mul : âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]
  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R Mâ‚‚] (fâ‚â‚‚ fâ‚‚â‚ƒ : M â†’â‚—[R] M) (gâ‚â‚‚ gâ‚‚â‚ƒ : Mâ‚‚ â†’â‚—[R] Mâ‚‚),
  fâ‚‚â‚ƒ.prodMap gâ‚‚â‚ƒ * fâ‚â‚‚.prodMap gâ‚â‚‚ = (fâ‚‚â‚ƒ * fâ‚â‚‚).prodMap (gâ‚‚â‚ƒ * gâ‚â‚‚)
Result.success

Testing || contDiff_one_iff_deriv : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {F : Type uF} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ğ•œ F] {fâ‚‚ : ğ•œ â†’ F}, ContDiff ğ•œ 1 fâ‚‚ â†” Differentiable ğ•œ fâ‚‚ âˆ§ Continuous (deriv fâ‚‚)
Result.autoException ::
Auto failed to find proof

Testing || Matrix.one_apply_eq : âˆ€ {n : Type u_3} {Î± : Type v} [inst : DecidableEq n] [inst_1 : _root_.Zero Î±] [inst_2 : _root_.One Î±] (i : n), 1 i i = 1
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n Î± is not a `âˆ€`

Testing || Std.DHashMap.Internal.Raw.erase_val : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : BEq Î±] [inst_1 : Hashable Î±] {m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²} {a : Î±},
  (â†‘m).erase a = â†‘(m.erase a)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In âˆ€ (property : 0 < (â†‘m).buckets.size),
  m = âŸ¨â†‘m, propertyâŸ©, type of dependent âˆ€ bound variable is of sort `Prop`

Testing || Submodule.strictMono_comap_prod_map : âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  (p : Submodule R M), StrictMono fun m => (Submodule.comap p.subtype m, Submodule.map p.mkQ m)
Result.autoException ::
Auto failed to find proof

Testing || conjneg_eq_zero : âˆ€ {G : Type u_2} {R : Type u_3} [inst : AddGroup G] [inst_1 : CommSemiring R] [inst_2 : StarRing R] {f : G â†’ R},
  conjneg f = 0 â†” f = 0
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.measure_smul_eq_zero_iff : âˆ€ {G : Type u} {Î± : Type w} {m : MeasurableSpace Î±} [inst : Group G] [inst_1 : MulAction G Î±]
  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : MeasureTheory.SMulInvariantMeasure G Î± Î¼] {s : Set Î±} (c : G),
  Î¼ (c â€¢ s) = 0 â†” Î¼ s = 0
Result.success

Testing || Std.HashMap.getKey?_emptyc : âˆ€ {Î± : Type u} {Î² : Type v} {x : BEq Î±} {x_1 : Hashable Î±} {a : Î±}, âˆ….getKey? a = none
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Std.DHashMap.Raw.WF.emptyâ‚€`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LinearMap.comap_injective : âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]
  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {F : Type u_10} [inst_6 : FunLike F M Mâ‚‚] [inst_7 : SemilinearMapClass F Ï„â‚â‚‚ M Mâ‚‚]
  [inst_8 : RingHomSurjective Ï„â‚â‚‚] {f : F}, LinearMap.range f = âŠ¤ â†’ Function.Injective (Submodule.comap f)
Result.autoException ::
Auto failed to find proof

Testing || sup_sdiff_right_self : âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] {a b : Î±}, (a âŠ” b) \ b = a \ b
Result.success

Testing || Ordinal.type_le_iff' : âˆ€ {Î± Î² : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} [inst : IsWellOrder Î± r] [inst_1 : IsWellOrder Î² s],
  Ordinal.type r â‰¤ Ordinal.type s â†” Nonempty (r â†ªr s)
Result.autoException ::
Auto failed to find proof

Testing || Sigma.instAddAction.proof_1 : âˆ€ {Î¹ : Type u_1} {M : Type u_3} {Î± : Î¹ â†’ Type u_2} {m : AddMonoid M} [inst : (i : Î¹) â†’ AddAction M (Î± i)]
  (x : (i : Î¹) Ã— Î± i), 0 +áµ¥ x = x
Result.success

Testing || ContinuousLinearMap.op_norm_flip : âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8}
  [inst : SeminormedAddCommGroup E] [inst_1 : SeminormedAddCommGroup F] [inst_2 : SeminormedAddCommGroup G]
  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NontriviallyNormedField ğ•œâ‚‚] [inst_5 : NontriviallyNormedField ğ•œâ‚ƒ]
  [inst_6 : NormedSpace ğ•œ E] [inst_7 : NormedSpace ğ•œâ‚‚ F] [inst_8 : NormedSpace ğ•œâ‚ƒ G] {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ}
  [inst_9 : RingHomIsometric Ïƒâ‚‚â‚ƒ] [inst_10 : RingHomIsometric Ïƒâ‚â‚ƒ] (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G), â€–f.flipâ€– = â€–fâ€–
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_map : âˆ€ {D : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] {S' R : CategoryTheory.Functor Dáµ’áµ– CommRingCat}
  (Ï†' : S' âŸ¶ R) {X Y : Dáµ’áµ–} (f : X âŸ¶ Y),
  (PresheafOfModules.DifferentialsConstruction.relativeDifferentials' Ï†').map f = CommRingCat.KaehlerDifferential.map â‹¯
Result.autoException ::
Auto failed to find proof

Testing || Multiset.range_add_eq_union : âˆ€ (a b : â„•), Multiset.range (a + b) = Multiset.range a âˆª Multiset.map (fun x => a + x) (Multiset.range b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Multiset.map
  (fun x => cifvar_3 x_0 x) (cifvar_2 x_1)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.diagonal_subset_iff : âˆ€ {Î± : Type u_1} {s : Set (Î± Ã— Î±)}, Set.diagonal Î± âŠ† s â†” âˆ€ (x : Î±), (x, x) âˆˆ s
Result.success

Testing || Submonoid.induction_of_closure_eq_top_left : âˆ€ {M : Type u_1} [inst : Monoid M] {s : Set M} {p : M â†’ Prop},
  Submonoid.closure s = âŠ¤ â†’ âˆ€ (x : M), p 1 â†’ (âˆ€ x âˆˆ s, âˆ€ (y : M), p y â†’ p (x * y)) â†’ p x
Result.autoException ::
Auto failed to find proof

Testing || Int.gcd_dvd_gcd_mul_left : âˆ€ (i j k : â„¤), i.gcd j âˆ£ (k * i).gcd j
Result.success

Testing || Set.RightInvOn.prodMap : âˆ€ {Î±â‚ : Type u_7} {Î±â‚‚ : Type u_8} {Î²â‚ : Type u_9} {Î²â‚‚ : Type u_10} {tâ‚ : Set Î²â‚} {tâ‚‚ : Set Î²â‚‚} {fâ‚ : Î±â‚ â†’ Î²â‚}
  {fâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} {gâ‚ : Î²â‚ â†’ Î±â‚} {gâ‚‚ : Î²â‚‚ â†’ Î±â‚‚},
  Set.RightInvOn gâ‚ fâ‚ tâ‚ â†’
    Set.RightInvOn gâ‚‚ fâ‚‚ tâ‚‚ â†’ Set.RightInvOn (fun x => (gâ‚ x.1, gâ‚‚ x.2)) (fun x => (fâ‚ x.1, fâ‚‚ x.2)) (tâ‚ Ã—Ë¢ tâ‚‚)
Result.autoException ::
Auto failed to find proof

Testing || Finset.iInf_finset_image : âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : CompleteLattice Î²] [inst_1 : DecidableEq Î±] {f : Î³ â†’ Î±}
  {g : Î± â†’ Î²} {s : Finset Î³}, â¨… x âˆˆ Finset.image f s, g x = â¨… y âˆˆ s, g (f y)
Result.autoException ::
Auto failed to find proof

Testing || Set.inter_nsmul_subset : âˆ€ {Î± : Type u_2} [inst : AddMonoid Î±] {s t : Set Î±} {n : â„•}, n â€¢ (s âˆ© t) âŠ† n â€¢ s âˆ© n â€¢ t
Result.success

Testing || LinearEquiv.map_ne_zero_iff : âˆ€ {R : Type u_1} {S : Type u_5} {M : Type u_6} {Mâ‚‚ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] {module_M : _root_.Module R M}
  {module_S_Mâ‚‚ : _root_.Module S Mâ‚‚} {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} {reâ‚ : RingHomInvPair Ïƒ Ïƒ'}
  {reâ‚‚ : RingHomInvPair Ïƒ' Ïƒ} (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) {x : M}, e x â‰  0 â†” x â‰  0
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.ProbabilityMeasure.coeFn_univ_ne_zero : âˆ€ {Î© : Type u_1} [inst : MeasurableSpace Î©] (Î½ : MeasureTheory.ProbabilityMeasure Î©), Î½ Set.univ â‰  0
Result.success

Testing || WithTop.add_lt_add_left : âˆ€ {Î± : Type u} [inst : Add Î±] {a b c : WithTop Î±} [inst_1 : LT Î±] [inst_2 : AddLeftStrictMono Î±],
  a â‰  âŠ¤ â†’ b < c â†’ a + b < a + c
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.lintegral_sub_right_eq_self : âˆ€ {G : Type u_1} [inst : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_1 : AddGroup G]
  [inst_2 : MeasurableAdd G] [inst_3 : Î¼.IsAddRightInvariant] (f : G â†’ ENNReal) (g : G),
  âˆ«â» (x : G), f (x - g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆ«â» (x : G),
  cifvar_13 (cifvar_8 (cifvar_9 x x_2) cifvar_14) âˆ‚x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.sup_div_right : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : DecidableEq Î±] [inst_1 : Div Î±] [inst_2 : SemilatticeSup Î²]
  [inst_3 : OrderBot Î²] (s t : Finset Î±) (f : Î± â†’ Î²), (s / t).sup f = t.sup fun y => s.sup fun x => f (x / y)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.sup fun x =>
  cifvar_10 (cifvar_11 x y)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || WeierstrassCurve.Projective.Point.toAffine_zero : âˆ€ {F : Type v} [inst : Field F] {W : WeierstrassCurve.Projective F},
  WeierstrassCurve.Projective.Point.toAffine W ![0, 1, 0] = 0
Result.autoException ::
Auto failed to find proof

Testing || CochainComplex.cochainComplex_d_succ_succ_zero : âˆ€ {V : Type u} [inst : CategoryTheory.Category.{v, u} V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  (C : CochainComplex V â„•) (i : â„•), C.d 0 (i + 2) = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.d x_1 x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FreeGroup.mk_toWord : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {x : FreeGroup Î±}, FreeGroup.mk x.toWord = x
Result.autoException ::
Auto failed to find proof

Testing || Duper.equality_factoring_soundness4 : âˆ€ {Î± : Sort u_1} {s t : Î±} (u : Î±), s = t â†’ s â‰  u âˆ¨ u = t
Result.success

Testing || SetTheory.PGame.numeric_nat : âˆ€ (n : â„•), (â†‘n).Numeric
Result.autoException ::
Auto failed to find proof

Testing || Module.isTrivialRelation_iff_vanishesTrivially : âˆ€ {R M : Type u} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {Î¹ : Type u}
  [inst_3 : Fintype Î¹] {f : Î¹ â†’ R} {x : Î¹ â†’ M}, Module.IsTrivialRelation f x â†” TensorProduct.VanishesTrivially R f x
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Fintype Îºâœ of Î» binder contains bound variables

Testing || FirstOrder.Language.Term.realize_var : âˆ€ {L : FirstOrder.Language} {M : Type w} [inst : L.Structure M] {Î± : Type u'} (v : Î± â†’ M) (k : Î±),
  FirstOrder.Language.Term.realize v (FirstOrder.Language.var k) = v k
Result.success

Testing || Nat.dvd_of_mul_dvd_mul_right : âˆ€ {k m n : â„•}, 0 < k â†’ m * k âˆ£ n * k â†’ m âˆ£ n
Result.success

Testing || LinearMap.restrictScalarsâ‚—_apply : âˆ€ (R : Type u_14) (S : Type u_15) (M : Type u_16) (N : Type u_17) [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R N]
  [inst_6 : _root_.Module S M] [inst_7 : _root_.Module S N] [inst_8 : LinearMap.CompatibleSMul M N R S] (Râ‚ : Type u_19)
  [inst_9 : Semiring Râ‚] [inst_10 : _root_.Module Râ‚ N] [inst_11 : SMulCommClass S Râ‚ N]
  [inst_12 : SMulCommClass R Râ‚ N] (fâ‚— : M â†’â‚—[S] N), (LinearMap.restrictScalarsâ‚— R S M N Râ‚) fâ‚— = â†‘R fâ‚—
Result.success

Testing || AddMonoidHom.fiberEquivKer_symm_apply : âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] {H : Type u_2} [inst_1 : AddGroup H] (f : Î± â†’+ H) (a : Î±) (g : â†¥f.ker),
  â†‘((f.fiberEquivKer a).symm g) = a + â†‘g
Result.success

Testing || isLindelof_univ : âˆ€ {X : Type u} [inst : TopologicalSpace X] [h : LindelofSpace X], IsLindelof Set.univ
Result.success

Testing || div_div_div_comm : âˆ€ {Î± : Type u_1} [inst : DivisionCommMonoid Î±] (a b c d : Î±), a / b / (c / d) = a / c / (b / d)
Result.success

Testing || LinearMap.IsSymmetric.diagonalization_symm_apply : âˆ€ {ğ•œ : Type u_1} [inst : RCLike ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]
  {T : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E] (hT : T.IsSymmetric)
  (w : PiLp 2 fun Î¼ => â†¥(Module.End.eigenspace T (â†‘T 1 Î¼))),
  hT.diagonalization.symm w = âˆ‘ Î¼ : Module.End.Eigenvalues T, â†‘(w Î¼)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: PiLp 2 fun Î¼ => â†¥(Module.End.eigenspace T (â†‘T 1 Î¼)) is not a `âˆ€`

Testing || Continuous.indicator : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±}
  [inst_2 : _root_.Zero Î²], (âˆ€ a âˆˆ frontier s, f a = 0) â†’ Continuous f â†’ Continuous (s.indicator f)
Result.success

Testing || Int.toNat_sub_toNat_neg : âˆ€ (n : â„¤), â†‘n.toNat - â†‘(-n).toNat = n
Result.autoException ::
Auto failed to find proof

Testing || IsLindelof.inter_right : âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsLindelof s â†’ IsClosed t â†’ IsLindelof (s âˆ© t)
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.getVert_tail : âˆ€ {V : Type u} {G : SimpleGraph V} {u v : V} {n : â„•} (p : G.Walk u v), Â¬p.Nil â†’ p.tail.getVert n = p.getVert (n + 1)
Result.autoException ::
Auto failed to find proof

Elapsed time: 430778 ms

Summary:

0 E PrimeMultiset.prod_zero
1 E jacobiSym.zero_right
2 E Rel.image_bot
3 E MeasureTheory.hasFiniteIntegral_const
4 S isPurelyInseparable_iff_finSepDegree_eq_one
5 E IsLocalization.map_integerMultiple
6 E OrderIso.isBoundedUnder_le_comp
7 S Nat.ceil_eq_zero
8 E CategoryTheory.ComposableArrows.naturality'_assoc
9 E Fin.partialProd_left_inv
10 E Submonoid.exists_mulEquiv_eq_mgraph
11 E CoalgebraCat.toCoalgHom_id
12 E CategoryTheory.isIso_op_iff
13 E FreeGroup.lift.of
14 E CategoryTheory.Limits.InitialMonoClass.of_terminal
15 E AddSubgroup.unop_injective
16 S WeierstrassCurve.Projective.Point.toAffineAddEquiv_apply
17 E Nat.zeckendorf_of_pos
18 S AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_eq_iff_eq
19 E RingEquiv.unop_map_list_prod
20 S Order.Ideal.IsProper.not_mem_or_compl_not_mem
21 S Complex.cos_int_mul_two_pi_sub_pi
22 E LinearMap.finrank_range_dualMap_eq_finrank_range
23 E CategoryTheory.Functor.Monoidal.whiskerRight_app_snd_assoc
24 S NNRat.floor_coe
25 S ContinuousAt.comp_of_eq
26 S List.Ico.zero_bot
27 E fderiv_csin
28 E MeasureTheory.memâ„’p_stoppedProcess
29 S Nat.divisorsAntidiagonal_one
30 S InnerProductGeometry.sin_angle_sub_of_inner_eq_zero
31 E Finset.sup'_lt_iff
32 E CategoryTheory.ShortComplex.opcyclesMap'_smul
33 S WithLp.equiv_sub
34 E LinearMap.BilinForm.isCompl_orthogonal_iff_disjoint
35 S edist_pi_def
36 E EReal.le_limsup_add
37 S MeasureTheory.levyProkhorovEDist_lt_top
38 E Complex.lim_re
39 E Homotopy.nullHomotopicMap'_f
40 S CategoryTheory.Limits.hasColimitsOfShape_of_closed_under_colimits
41 E Filter.EventuallyEq.prod_mk
42 E List.not_eq_key
43 S PadicInt.mkUnits_eq
44 E Filter.tendsto_mul_const_atTop_of_pos
45 S WithTop.coe_nat
46 E Nat.factorization_lcm
47 S Matrix.linfty_op_nnnorm_mul
48 S Finset.insert_idem
49 E Cardinal.lift_injective
50 S Antitone.map_iSup_of_continuousAt'
51 S CategoryTheory.PreOneHypercover.map_f
52 E nhds_bot_basis_Iic
53 E exists_floor
54 E Acc.cutExpand
55 S AddCon.orderIsoOp.proof_2
56 E CategoryTheory.Presheaf.isSheaf_coherent_of_hasPullbacks_of_comp
57 S add_lt_of_neg_right
58 S Nat.Prime.not_dvd_mul
59 E addOrderOf_dvd_natCard
60 E Set.Nonempty.sigma_fst
61 E CategoryTheory.OverPresheafAux.OverArrows.mapâ‚_mapâ‚‚
62 E WeierstrassCurve.Jacobian.Point.toAffine_add
63 S Units.inv_eq_of_mul_eq_one_right
64 E LieIdeal.derivedSeries_eq_bot_iff
65 E SemiNormedGrp.explicitCokernelDesc_norm_le_of_norm_le
66 E CategoryTheory.NatIso.pi_inv
67 E ChartedSpace.liftPropAt_iff
68 S Submodule.mul_def
69 E MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_topâ‚€
70 S CategoryTheory.Limits.isoZeroOfMonoZero_hom
71 E CategoryTheory.InjectiveResolution.descFOne_zero_comm
72 S Computation.get_bind
73 E Set.Finite.bddAbove
74 E fourier_add
75 S Topology.IsInducing.functor_obj
76 E Submonoid.map_powers
77 E HasFDerivWithinAt.hasMFDerivWithinAt
78 E LieAlgebra.IsKilling.corootSpace_zero_eq_bot
79 S RCLike.norm_im_le_norm
80 E one_zpow
81 S sub_lt_of_abs_sub_lt_right
82 S Dilation.comp_apply
83 E CategoryTheory.GrothendieckTopology.plusLift_unique
84 E Auto.Embedding.Lam.BVLems.shl_equiv
85 S LinearMap.prodMap_mul
86 E contDiff_one_iff_deriv
87 E Matrix.one_apply_eq
88 E Std.DHashMap.Internal.Raw.erase_val
89 E Submodule.strictMono_comap_prod_map
90 E conjneg_eq_zero
91 S MeasureTheory.measure_smul_eq_zero_iff
92 E Std.HashMap.getKey?_emptyc
93 E LinearMap.comap_injective
94 S sup_sdiff_right_self
95 E Ordinal.type_le_iff'
96 S Sigma.instAddAction.proof_1
97 E ContinuousLinearMap.op_norm_flip
98 E PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_map
99 E Multiset.range_add_eq_union
100 S Set.diagonal_subset_iff
101 E Submonoid.induction_of_closure_eq_top_left
102 S Int.gcd_dvd_gcd_mul_left
103 E Set.RightInvOn.prodMap
104 E Finset.iInf_finset_image
105 S Set.inter_nsmul_subset
106 E LinearEquiv.map_ne_zero_iff
107 S MeasureTheory.ProbabilityMeasure.coeFn_univ_ne_zero
108 E WithTop.add_lt_add_left
109 E MeasureTheory.lintegral_sub_right_eq_self
110 E Finset.sup_div_right
111 E WeierstrassCurve.Projective.Point.toAffine_zero
112 E CochainComplex.cochainComplex_d_succ_succ_zero
113 E FreeGroup.mk_toWord
114 S Duper.equality_factoring_soundness4
115 E SetTheory.PGame.numeric_nat
116 E Module.isTrivialRelation_iff_vanishesTrivially
117 S FirstOrder.Language.Term.realize_var
118 S Nat.dvd_of_mul_dvd_mul_right
119 S LinearMap.restrictScalarsâ‚—_apply
120 S AddMonoidHom.fiberEquivKer_symm_apply
121 S isLindelof_univ
122 S div_div_div_comm
123 E LinearMap.IsSymmetric.diagonalization_symm_apply
124 S Continuous.indicator
125 E Int.toNat_sub_toNat_neg
126 E IsLindelof.inter_right
127 E SimpleGraph.Walk.getVert_tail

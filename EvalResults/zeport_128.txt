Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || Int.natAbs_one : Int.natAbs 1 = 1
Result.autoException ::
Auto failed to find proof

Testing || HNNExtension.NormalWord.group_smul_def : âˆ€ {G : Type u_1} [inst : Group G] {A B : Subgroup G} {d : HNNExtension.NormalWord.TransversalPair G A B} (g : G)
  (w : HNNExtension.NormalWord d), g â€¢ w = { head := g * w.head, toList := w.toList, chain := â‹¯, mem_set := â‹¯ }
Result.autoException ::
Auto failed to find proof

Testing || Batteries.RBNode.balance2_eq : âˆ€ {Î± : Type u_1} {c : Batteries.RBColor} {n : â„•} {l : Batteries.RBNode Î±} {v : Î±} {r : Batteries.RBNode Î±},
  r.Balanced c n â†’ l.balance2 v r = Batteries.RBNode.node Batteries.RBColor.black l v r
Result.autoException ::
Auto failed to find proof

Testing || PMF.toOuterMeasure_bind_apply : âˆ€ {Î± : Type u_1} {Î² : Type u_2} (p : PMF Î±) (f : Î± â†’ PMF Î²) (s : Set Î²),
  (p.bind f).toOuterMeasure s = âˆ‘' (a : Î±), p a * (f a).toOuterMeasure s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.indicator (cifvar_10 x_0) x`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || PEquiv.single_trans_single_of_ne : âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : DecidableEq Î±] [inst_1 : DecidableEq Î²] [inst_2 : DecidableEq Î³]
  {bâ‚ bâ‚‚ : Î²}, bâ‚ â‰  bâ‚‚ â†’ âˆ€ (a : Î±) (c : Î³), (PEquiv.single a bâ‚).trans (PEquiv.single bâ‚‚ c) = âŠ¥
Result.success

Testing || Equiv.bijOn_swap : âˆ€ {Î± : Type u_1} {s : Set Î±} [inst : DecidableEq Î±] {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.BijOn (â‡‘(Equiv.swap a b)) s s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.BijOn (cifvar_7 x_0) x_1 x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Matrix.kroneckerMap_zero_right : âˆ€ {Î± : Type u_2} {Î² : Type u_4} {Î³ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11}
  [inst : Zero Î²] [inst_1 : Zero Î³] (f : Î± â†’ Î² â†’ Î³),
  (âˆ€ (a : Î±), f a 0 = 0) â†’ âˆ€ (A : Matrix l m Î±), Matrix.kroneckerMap f A 0 = 0
Result.autoException ::
Auto failed to find proof

Testing || HomogeneousIdeal.toIdeal_add : âˆ€ {Î¹ : Type u_1} {Ïƒ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : DecidableEq Î¹] [inst_2 : AddMonoid Î¹]
  [inst_3 : SetLike Ïƒ A] [inst_4 : AddSubmonoidClass Ïƒ A] {ğ’œ : Î¹ â†’ Ïƒ} [inst_5 : GradedRing ğ’œ]
  (I J : HomogeneousIdeal ğ’œ), (I + J).toIdeal = I.toIdeal + J.toIdeal
Result.autoException ::
Auto failed to find proof

Testing || List.nodup_rotate : âˆ€ {Î± : Type u} {l : List Î±} {n : â„•}, (l.rotate n).Nodup â†” l.Nodup
Result.success

Testing || Submodule.le_comap_pow_of_le_comap : âˆ€ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (p : Submodule R M)
  {f : M â†’â‚—[R] M}, p â‰¤ Submodule.comap f p â†’ âˆ€ (k : â„•), p â‰¤ Submodule.comap (f ^ k) p
Result.autoException ::
Auto failed to find proof

Testing || FiniteField.isSquare_neg_two_iff : âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-2) â†” Fintype.card F % 8 â‰  5 âˆ§ Fintype.card F % 8 â‰  7
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `quadraticChar cifvar_54`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || HasSum.hasSum_at_zero : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] (a : â„• â†’ E), HasSum (fun n => 0 ^ n â€¢ a n) (a 0)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulWithZero.toSMulZeroClass`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || AddOreLocalization.oreSub_add_oreSub : âˆ€ {R : Type u_1} [inst : AddMonoid R] {S : AddSubmonoid R} [inst_1 : AddOreLocalization.AddOreSet S] {râ‚ râ‚‚ : R}
  {sâ‚ sâ‚‚ : â†¥S},
  râ‚ -â‚’ sâ‚ + (râ‚‚ -â‚’ sâ‚‚) = AddOreLocalization.oreMin râ‚ sâ‚‚ + râ‚‚ -â‚’ (AddOreLocalization.oreSubtra râ‚ sâ‚‚ + sâ‚)
Result.autoException ::
Auto failed to find proof

Testing || sectionOfRetractionKerToTensor_algebraMap : âˆ€ {R P S : Type u} [inst : CommRing R] [inst_1 : CommRing P] [inst_2 : CommRing S] [inst_3 : Algebra R P]
  [inst_4 : Algebra P S] (l : TensorProduct P S (Î©[Pâ„R]) â†’â‚—[P] â†¥(RingHom.ker (algebraMap P S)))
  (hl : l âˆ˜â‚— KaehlerDifferential.kerToTensor R P S = LinearMap.id) [inst_5 : Algebra R S] [inst_6 : IsScalarTower R P S]
  (hf' : RingHom.ker (algebraMap P S) ^ 2 = âŠ¥) (hf : Function.Surjective â‡‘(algebraMap P S)) (x : P),
  (sectionOfRetractionKerToTensor l hl hf' hf) ((algebraMap P S) x) = x - â†‘(l (1 âŠ—â‚œ[P] (KaehlerDifferential.D R P) x))
Result.autoException ::
Auto failed to find proof

Testing || Set.up_image : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] (f : Î± â†’* Î²) (s : Set Î±),
  Set.up (â‡‘f '' s) = (SetSemiring.imageHom f) (Set.up s)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Limits.pullbackConeOfRightIso_Ï€_app_right : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z)
  [inst_1 : CategoryTheory.IsIso g],
  (CategoryTheory.Limits.pullbackConeOfRightIso f g).Ï€.app CategoryTheory.Limits.WalkingCospan.right =
    CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv g)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv_symm_Î¹_apply : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{uâ‚‚, uâ‚} C] (F : CategoryTheory.Functor C FintypeCat)
  [inst_1 : CategoryTheory.PreGaloisCategory C] [inst_2 : CategoryTheory.PreGaloisCategory.FiberFunctor F] {X Y : C}
  {f g : X âŸ¶ Y} (x : â†‘(F.obj X)) (h : F.map f x = F.map g x),
  F.map (CategoryTheory.Limits.equalizer.Î¹ f g)
      ((CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv F f g).symm âŸ¨x, hâŸ©) =
    x
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.obj X âŸ¶ F.obj Y is not a `âˆ€`

Testing || CategoryTheory.Limits.prod.lift_fst_snd : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C}
  [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y],
  CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd =
    CategoryTheory.CategoryStruct.id (X â¨¯ Y)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.limit.lift
  (cifvar_1 cifvar_2 cifvar_3) x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Matrix.SpecialLinearGroup.mem_center_iff : âˆ€ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R]
  {A : Matrix.SpecialLinearGroup n R},
  A âˆˆ Subgroup.center (Matrix.SpecialLinearGroup n R) â†” âˆƒ r, r ^ Fintype.card n = 1 âˆ§ (Matrix.scalar n) r = â†‘A
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `âˆ€`

Testing || LinearPMap.zero_domain : âˆ€ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}
  [inst_3 : AddCommGroup F] [inst_4 : Module R F], LinearPMap.domain 0 = âŠ¤
Result.autoException ::
Auto failed to find proof

Testing || char_dvd_card_solutions_of_sum_lt : âˆ€ {K : Type u_1} {Ïƒ : Type u_2} {Î¹ : Type u_3} [inst : Fintype K] [inst_1 : Field K] [inst_2 : Fintype Ïƒ]
  [inst_3 : DecidableEq Ïƒ] [inst_4 : DecidableEq K] (p : â„•) [inst_5 : CharP K p] {s : Finset Î¹}
  {f : Î¹ â†’ MvPolynomial Ïƒ K},
  âˆ‘ i âˆˆ s, (f i).totalDegree < Fintype.card Ïƒ â†’ p âˆ£ Fintype.card { x // âˆ€ i âˆˆ s, (MvPolynomial.eval x) (f i) = 0 }
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toMonoidWithZero`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || NNRat.num_coe : âˆ€ (q : â„šâ‰¥0), (â†‘q).num = â†‘q.num
Result.autoException ::
Auto failed to find proof

Testing || Int.bmod_one_is_zero : âˆ€ (x : â„¤), x.bmod 1 = 0
Result.autoException ::
Auto failed to find proof

Testing || Nat.rel_of_forall_rel_succ_of_lt : âˆ€ {Î² : Type v} (r : Î² â†’ Î² â†’ Prop) [inst : IsTrans Î² r] {f : â„• â†’ Î²},
  (âˆ€ (n : â„•), r (f n) (f (n + 1))) â†’ âˆ€ â¦ƒa b : â„•â¦„, a < b â†’ r (f a) (f b)
Result.autoException ::
Auto failed to find proof

Testing || le_of_forall_pos_sub_le : âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] [inst_1 : LinearOrder Î±] [inst_2 : AddLeftMono Î±] [inst_3 : DenselyOrdered Î±]
  {a b : Î±}, (âˆ€ (Îµ : Î±), 0 < Îµ â†’ a - Îµ â‰¤ b) â†’ a â‰¤ b
Result.success

Testing || HomologicalComplexUpToQuasiIso.Q_map_eq_of_homotopy : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] {Î¹ : Type u_2} {c : ComplexShape Î¹}
  [inst_1 : CategoryTheory.Preadditive C] [inst_2 : CategoryTheory.CategoryWithHomology C]
  [inst_3 : (HomologicalComplex.quasiIso C c).HasLocalization] [inst_4 : c.QFactorsThroughHomotopy C]
  {K L : HomologicalComplex C c} {f g : K âŸ¶ L},
  Homotopy f g â†’ HomologicalComplexUpToQuasiIso.Q.map f = HomologicalComplexUpToQuasiIso.Q.map g
Result.autoException ::
Auto failed to find proof

Testing || Finset.nonempty_Ico : âˆ€ {Î± : Type u_2} {a b : Î±} [inst : Preorder Î±] [inst_1 : LocallyFiniteOrder Î±], (Finset.Ico a b).Nonempty â†” a < b
Result.success

Testing || Sum.LiftRel.exists_of_isLeft_right : âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} {Î´ : Type u_2} {r : Î± â†’ Î³ â†’ Prop} {s : Î² â†’ Î´ â†’ Prop} {x : Î± âŠ• Î²} {y : Î³ âŠ• Î´},
  Sum.LiftRel r s x y â†’ y.isLeft = true â†’ âˆƒ a c, r a c âˆ§ x = Sum.inl a âˆ§ y = Sum.inl c
Result.success

Testing || FirstOrder.Language.Hom.id_comp : âˆ€ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : L.Structure M] [inst_1 : L.Structure N] (f : L.Hom M N),
  (FirstOrder.Language.Hom.id L N).comp f = f
Result.autoException ::
Auto failed to find proof

Testing || Pi.single_inj : âˆ€ {I : Type u} (f : I â†’ Type vâ‚) [inst : DecidableEq I] [inst_1 : (i : I) â†’ Zero (f i)] (i : I) {x y : f i},
  Pi.single i x = Pi.single i y â†” x = y
Result.autoException ::
Auto failed to find proof

Testing || WeierstrassCurve.preÎ¨'_one : âˆ€ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R), W.preÎ¨' 1 = 1
Result.autoException ::
Auto failed to find proof

Testing || Matrix.updateColumn_conjTranspose : âˆ€ {m : Type u_2} {n : Type u_3} {Î± : Type v} {M : Matrix m n Î±} {i : m} {b : n â†’ Î±} [inst : DecidableEq m]
  [inst_1 : Star Î±], M.conjTranspose.updateColumn i (star b) = (M.updateRow i b).conjTranspose
Result.success

Testing || conformalAt_iff : âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]
  [inst_2 : InnerProductSpace â„ E] [inst_3 : InnerProductSpace â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F},
  HasFDerivAt f f' x â†’ (ConformalAt f x â†” âˆƒ c, 0 < c âˆ§ âˆ€ (u v : E), inner (f' u) (f' v) = c * inner u v)
Result.success

Testing || List.prod_homâ‚‚_nonempty : âˆ€ {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} {P : Type u_6} [inst : Monoid M] [inst_1 : Monoid N] [inst_2 : Monoid P]
  {l : List Î¹} (f : M â†’ N â†’ P),
  (âˆ€ (a b : M) (c d : N), f (a * b) (c * d) = f a c * f b d) â†’
    âˆ€ (fâ‚ : Î¹ â†’ M) (fâ‚‚ : Î¹ â†’ N),
      l â‰  [] â†’ (List.map (fun i => f (fâ‚ i) (fâ‚‚ i)) l).prod = f (List.map fâ‚ l).prod (List.map fâ‚‚ l).prod
Result.autoException ::
Auto failed to find proof

Testing || Filter.mem_of_superset : âˆ€ {Î± : Type u_1} {f : Filter Î±} {x y : Set Î±}, x âˆˆ f â†’ x âŠ† y â†’ y âˆˆ f
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearEquiv.contDiffWithinAt_comp_iff : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {s : Set E} {f : E â†’ F} {x : E} {n : â„•âˆ} (e : G â‰ƒL[ğ•œ] E),
  ContDiffWithinAt ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (e.symm x) â†” ContDiffWithinAt ğ•œ n f s x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_23 âˆ˜ cifvar_24 x_3`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || eq_sub_of_add_eq' : âˆ€ {G : Type u_3} [inst : AddCommGroup G] {a b c : G}, c + a = b â†’ a = b - c
Result.success

Testing || Primrec.pred : Primrec Nat.pred
Result.success

Testing || MeasurableSet.cylinder : âˆ€ {Î¹ : Type u_2} {Î± : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MeasurableSpace (Î± i)] (s : Finset Î¹)
  {S : Set ((i : { x // x âˆˆ s }) â†’ Î± â†‘i)}, MeasurableSet S â†’ MeasurableSet (MeasureTheory.cylinder s S)
Result.autoException ::
Auto failed to find proof

Testing || ZMod.intCast_eq_intCast_iff : âˆ€ (a b : â„¤) (c : â„•), â†‘a = â†‘b â†” a â‰¡ b [ZMOD â†‘c]
Result.autoException ::
Auto failed to find proof

Testing || List.getI_eq_default : âˆ€ {Î± : Type u} (l : List Î±) [inst : Inhabited Î±] {n : â„•}, l.length â‰¤ n â†’ l.getI n = default
Result.autoException ::
Auto failed to find proof

Testing || NonUnitalSubsemiring.comap_top : âˆ€ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}
  [inst_2 : FunLike F R S] [inst_3 : NonUnitalRingHomClass F R S] (f : F), NonUnitalSubsemiring.comap f âŠ¤ = âŠ¤
Result.autoException ::
Auto failed to find proof

Testing || Monotone.rightLim_le : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]
  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},
  Monotone f â†’ âˆ€ {x y : Î±}, x < y â†’ Function.rightLim f x â‰¤ f y
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_toStalk : âˆ€ (R : Type u) [inst : CommRing R] (x : â†‘(AlgebraicGeometry.PrimeSpectrum.Top R)) (f : R),
  (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) ((AlgebraicGeometry.StructureSheaf.toStalk R x) f) =
    (algebraMap R (Localization.AtPrime x.asIdeal)) f
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.isPrime`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || ringExpChar.eq_iff : âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] {q : â„•}, ringExpChar R = q â†” ExpChar R q
Result.success

Testing || TopologicalSpace.NoetherianSpace.finite : âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] [inst : T2Space Î±], Finite Î±
Result.success

Testing || Subalgebra.mem_op : âˆ€ {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {x : Aáµáµ’áµ–}
  {S : Subalgebra R A}, x âˆˆ S.op â†” MulOpposite.unop x âˆˆ S
Result.autoException ::
Auto failed to find proof

Testing || MvQPF.Cofix.bisimâ‚‚ : âˆ€ {n : â„•} {F : TypeVec.{u} (n + 1) â†’ Type u} [q : MvQPF F] {Î± : TypeVec.{u} n}
  (r : MvQPF.Cofix F Î± â†’ MvQPF.Cofix F Î± â†’ Prop),
  (âˆ€ (x y : MvQPF.Cofix F Î±), r x y â†’ MvFunctor.LiftR' (Î±.RelLast' r) x.dest y.dest) â†’
    âˆ€ (x y : MvQPF.Cofix F Î±), r x y â†’ x = y
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: TypeVec.{u} (n + 1) is not a `âˆ€`

Testing || CategoryTheory.BicategoricalCoherence.whiskerLeft_iso : âˆ€ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b c : B} (f : a âŸ¶ b) (g h : b âŸ¶ c)
  [inst_1 : CategoryTheory.BicategoricalCoherence g h],
  CategoryTheory.BicategoricalCoherence.iso =
    CategoryTheory.Bicategory.whiskerLeftIso f CategoryTheory.BicategoricalCoherence.iso
Result.autoException ::
Auto failed to find proof

Testing || Nat.sq_add_sq_mul : âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2
Result.autoException ::
Auto failed to find proof

Testing || Set.iUnion_smul_left_image : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SMul Î± Î²] {s : Set Î±} {t : Set Î²}, â‹ƒ a âˆˆ s, a â€¢ t = s â€¢ t
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a âˆˆ x_0 of Î» binder contains bound variables

Testing || IsGroupHom.comp : âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},
  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)
Result.autoException ::
Auto failed to find proof

Testing || LieSubmodule.sup_lie : âˆ€ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : AddCommGroup M]
  [inst_3 : Module R M] [inst_4 : LieRingModule L M] (N : LieSubmodule R L M) [inst_5 : LieAlgebra R L]
  (I J : LieIdeal R L), â…I âŠ” J, Nâ† = â…I, Nâ† âŠ” â…J, Nâ†
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_17 x_1 x }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || mem_ball_zero_iff : âˆ€ {E : Type u_6} [inst : SeminormedAddGroup E] {a : E} {r : â„}, a âˆˆ Metric.ball 0 r â†” â€–aâ€– < r
Result.success

Testing || ContinuousConstSMul.continuous_const_smul : âˆ€ {Î“ : Type u_1} {T : Type u_2} {inst : TopologicalSpace T} {inst_1 : SMul Î“ T} [self : ContinuousConstSMul Î“ T]
  (Î³ : Î“), Continuous fun x => Î³ â€¢ x
Result.autoException ::
Auto failed to find proof

Testing || Cardinal.lift_mk_shrink' : âˆ€ (Î± : Type u) [inst : Small.{v, u} Î±],
  Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, u} Î±)) = Cardinal.lift.{v, u} (Cardinal.mk Î±)
Result.autoException ::
Auto failed to find proof

Testing || SetTheory.PGame.Domineering.snd_pred_mem_erase_of_mem_left : âˆ€ {b : SetTheory.PGame.Domineering.Board} {m : â„¤ Ã— â„¤},
  m âˆˆ SetTheory.PGame.Domineering.left b â†’ (m.1, m.2 - 1) âˆˆ Finset.erase b m
Result.autoException ::
Auto failed to find proof

Testing || Ordnode.Valid'.node4L : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {l : Ordnode Î±} {x : Î±} {m : Ordnode Î±} {y : Î±} {r : Ordnode Î±} {oâ‚ : WithBot Î±}
  {oâ‚‚ : WithTop Î±},
  Ordnode.Valid' oâ‚ l â†‘x â†’
    Ordnode.Valid' (â†‘x) m â†‘y â†’
      Ordnode.Valid' (â†‘y) r oâ‚‚ â†’
        0 < m.size â†’
          l.size = 0 âˆ§ m.size = 1 âˆ§ r.size â‰¤ 1 âˆ¨
              0 < l.size âˆ§
                Ordnode.ratio * r.size â‰¤ m.size âˆ§
                  Ordnode.delta * l.size â‰¤ m.size + r.size âˆ§
                    3 * (m.size + r.size) â‰¤ 16 * l.size + 9 âˆ§ m.size â‰¤ Ordnode.delta * r.size â†’
            Ordnode.Valid' oâ‚ (l.node4L x m y r) oâ‚‚
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.setToFun_sub : âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]
  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}
  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} {f g : Î± â†’ E}
  (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C),
  MeasureTheory.Integrable f Î¼ â†’
    MeasureTheory.Integrable g Î¼ â†’
      MeasureTheory.setToFun Î¼ T hT (f - g) = MeasureTheory.setToFun Î¼ T hT f - MeasureTheory.setToFun Î¼ T hT g
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Pretriangulated.mem_distTriang_op_iff : âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.HasShift C â„¤]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Preadditive C]
  [inst_4 : âˆ€ (n : â„¤), (CategoryTheory.shiftFunctor C n).Additive] [inst_5 : CategoryTheory.Pretriangulated C]
  (T : CategoryTheory.Pretriangulated.Triangle Cáµ’áµ–),
  T âˆˆ CategoryTheory.Pretriangulated.distinguishedTriangles â†”
    Opposite.unop ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse.obj T) âˆˆ
      CategoryTheory.Pretriangulated.distinguishedTriangles
Result.autoException ::
Auto failed to find proof

Testing || LinearMap.lTensor_neg : âˆ€ {R : Type u_1} [inst : CommSemiring R] {M : Type u_2} {N : Type u_3} {P : Type u_4} [inst_1 : AddCommGroup M]
  [inst_2 : AddCommGroup N] [inst_3 : AddCommGroup P] [inst_4 : Module R M] [inst_5 : Module R N] [inst_6 : Module R P]
  (f : N â†’â‚—[R] P), LinearMap.lTensor M (-f) = -LinearMap.lTensor M f
Result.autoException ::
Auto failed to find proof

Testing || AddLocalization.rec.proof_3 : âˆ€ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {p : AddLocalization S â†’ Sort u_2}
  (f : (a : M) â†’ (b : â†¥S) â†’ p (AddLocalization.mk a b)),
  (âˆ€ {a c : M} {b d : â†¥S} (h : (AddLocalization.r S) (a, b) (c, d)), â‹¯ â–¸ f a b = f c d) â†’
    âˆ€ (y z : M Ã— â†¥S) (h : (AddOreLocalization.oreEqv S M) y z), â‹¯ â–¸ â‹¯ â–¸ f y.1 y.2 = â‹¯ â–¸ f z.1 z.2
Result.autoException ::
Auto failed to find proof

Testing || Unitization.lift_symm_apply : âˆ€ {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : NonUnitalSemiring A] [inst_2 : Module R A]
  [inst_3 : SMulCommClass R A A] [inst_4 : IsScalarTower R A A] {C : Type u_5} [inst_5 : Semiring C]
  [inst_6 : Algebra R C] (Ï† : Unitization R A â†’â‚[R] C),
  Unitization.lift.symm Ï† = (NonUnitalAlgHomClass.toNonUnitalAlgHom Ï†).comp (Unitization.inrNonUnitalAlgHom R A)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Limits.Types.binaryCoproductColimit_desc : âˆ€ (X Y : Type u) (s : CategoryTheory.Limits.BinaryCofan X Y) (a : X âŠ• Y),
  (CategoryTheory.Limits.Types.binaryCoproductColimit X Y).desc s a = Sum.elim s.inl s.inr a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: (CategoryTheory.Limits.Types.binaryCoproductCocone X Y).pt âŸ¶
  s.pt is not a `âˆ€`

Testing || LinearIsometry.map_ne : âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {Eâ‚‚ : Type u_6} {F : Type u_9} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]
  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_2 : SeminormedAddCommGroup Eâ‚‚] [inst_3 : Module Râ‚‚ Eâ‚‚] [inst_4 : NormedAddCommGroup F]
  [inst_5 : Module R F] (fâ‚ : F â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) {x y : F}, x â‰  y â†’ fâ‚ x â‰  fâ‚ y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective (cifvar_5 x_0)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Relation.comp_assoc : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {r : Î± â†’ Î² â†’ Prop} {p : Î² â†’ Î³ â†’ Prop} {q : Î³ â†’ Î´ â†’ Prop},
  Relation.Comp (Relation.Comp r p) q = Relation.Comp r (Relation.Comp p q)
Result.autoException ::
Auto failed to find proof

Testing || Int.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul : âˆ€ {p : â„•},
  Nat.Prime p â†’
    âˆ€ {m n : â„¤} {k l : â„•},
      â†‘(p ^ k) âˆ£ m â†’ â†‘(p ^ l) âˆ£ n â†’ â†‘(p ^ (k + l + 1)) âˆ£ m * n â†’ â†‘(p ^ (k + 1)) âˆ£ m âˆ¨ â†‘(p ^ (l + 1)) âˆ£ n
Result.success

Testing || Subring.coe_center : âˆ€ (R : Type u) [inst : Ring R], â†‘(Subring.center R) = Set.center R
Result.autoException ::
Auto failed to find proof

Testing || AntivaryOn.sum_mul_le_sum_mul_comp_perm : âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : LinearOrderedSemiring Î±] [inst_1 : ExistsAddOfLE Î±] {s : Finset Î¹}
  {Ïƒ : Equiv.Perm Î¹} {f g : Î¹ â†’ Î±}, AntivaryOn f g â†‘s â†’ {x | Ïƒ x â‰  x} âŠ† â†‘s â†’ âˆ‘ i âˆˆ s, f i * g i â‰¤ âˆ‘ i âˆˆ s, f i * g (Ïƒ i)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆ‘ i âˆˆ x_0,
  cifvar_12 (cifvar_13 i) (cifvar_14 (cifvar_15 x_1 i))`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || RightOrdContinuous.lt_iff : âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²] {f : Î± â†’ Î²},
  RightOrdContinuous f â†’ Function.Injective f â†’ âˆ€ {x y : Î±}, f x < f y â†” x < y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `SemilatticeSup.toPartialOrder`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Batteries.Vector.push_pop_back : âˆ€ {Î± : Type u_1} {n : â„•} (v : Batteries.Vector Î± (n + 1)), Batteries.Vector.push v.back v.pop = v
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  âˆ€ {Î± : Type u_1} {n : â„•} {v : Batteries.Vector Î± n} {x : Î±} {i : â„•} (h : i < n),
    (Batteries.Vector.push x v)[i] = v[i] is not type correct

Testing || CategoryTheory.Adjunction.toEquivalence_inverse : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F âŠ£ G)
  [inst_2 : âˆ€ (X : C), CategoryTheory.IsIso (adj.unit.app X)]
  [inst_3 : âˆ€ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)], adj.toEquivalence.inverse = G
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_7 cifvar_8).app x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || FractionalIdeal.fg_of_isUnit : âˆ€ {R : Type u_1} [inst : CommRing R] {S : Submonoid R} {P : Type u_2} [inst_1 : CommRing P] [inst_2 : Algebra R P]
  (I : FractionalIdeal S P), IsUnit I â†’ (â†‘I).FG
Result.autoException ::
Auto failed to find proof

Testing || minpoly.natSepDegree_eq_one_iff_eq_X_sub_C_pow : âˆ€ {F : Type u} {E : Type v} [inst : Field F] [inst_1 : Ring E] [inst_2 : IsDomain E] [inst_3 : Algebra F E] (q : â„•)
  [hF : ExpChar F q] {x : E},
  (minpoly F x).natSepDegree = 1 â†”
    âˆƒ n, Polynomial.map (algebraMap F E) (minpoly F x) = (Polynomial.X - Polynomial.C x) ^ q ^ n
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || IsAddRightRegular.add : âˆ€ {R : Type u_1} [inst : AddSemigroup R] {a b : R},
  IsAddRightRegular a â†’ IsAddRightRegular b â†’ IsAddRightRegular (a + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_4 x x_0) âˆ˜
  fun x => cifvar_4 x x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || StarConvex.preimage_add_left : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E] [inst_2 : Module ğ•œ E] {x z : E}
  {s : Set E}, StarConvex ğ•œ (x + z) s â†’ StarConvex ğ•œ x ((fun x => x + z) â»Â¹' s)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_1 x_1 x) â»Â¹' x_2`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || fixedPoints_submonoid_sup : âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Monoid M] [inst_1 : MulAction M Î±] {P Q : Submonoid M},
  MulAction.fixedPoints (â†¥(P âŠ” Q)) Î± = MulAction.fixedPoints (â†¥P) Î± âˆ© MulAction.fixedPoints (â†¥Q) Î±
Result.autoException ::
Auto failed to find proof

Testing || add_neg_cancel_comm : âˆ€ {G : Type u_1} [inst : AddCommGroup G] (a b : G), a + b + -a = b
Result.success

Testing || StructureGroupoid.LocalInvariantProp.liftPropAt_symm_of_mem_maximalAtlas : âˆ€ {H : Type u_1} {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]
  {G : StructureGroupoid H} {e : PartialHomeomorph M H} {Q : (H â†’ H) â†’ Set H â†’ H â†’ Prop} [inst_3 : HasGroupoid M G]
  {x : H},
  G.LocalInvariantProp G Q â†’
    (âˆ€ (y : H), Q id Set.univ y) â†’
      e âˆˆ StructureGroupoid.maximalAtlas M G â†’ x âˆˆ e.target â†’ ChartedSpace.LiftPropAt Q (â†‘e.symm) x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆ€á¶  (y : H) in cifvar_20 x_1,
  cifvar_16 (cifvar_17 x_0 (cifvar_18 (cifvar_19 x_0) y)) y`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || MeasureTheory.tendsto_of_uncrossing_lt_top : âˆ€ {Î© : Type u_1} {f : â„• â†’ Î© â†’ â„} {Ï‰ : Î©},
  Filter.liminf (fun n => â†‘â€–f n Ï‰â€–â‚Š) Filter.atTop < âŠ¤ â†’
    (âˆ€ (a b : â„š), a < b â†’ MeasureTheory.upcrossings (â†‘a) (â†‘b) f Ï‰ < âŠ¤) â†’
      âˆƒ c, Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆƒá¶  (n : â„•) in x_0,
  cifvar_17 (cifvar_18 n cifvar_6) a`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || BitVec.shiftLeft_add_distrib : âˆ€ {w : â„•} {x y : BitVec w} {n : â„•}, (x + y) <<< n = x <<< n + y <<< n
Result.autoException ::
Auto failed to find proof

Testing || Std.DHashMap.Internal.AssocList.get_eq : âˆ€ {Î± : Type u} {Î² : Type v} [inst : BEq Î±] {l : Std.DHashMap.Internal.AssocList Î± fun x => Î²} {a : Î±}
  {h : Std.DHashMap.Internal.AssocList.contains a l = true},
  Std.DHashMap.Internal.AssocList.get a l h = Std.DHashMap.Internal.List.getValue a l.toList â‹¯
Result.autoException ::
Auto failed to find proof

Testing || UniqueFactorizationMonoid.pow_eq_pow_iff : âˆ€ {M : Type u_1} [inst : CancelCommMonoidWithZero M] {q : M}, Â¬IsUnit q â†’ q â‰  0 â†’ âˆ€ {m n : â„•}, q ^ m = q ^ n â†” m = n
Result.success

Testing || MvPolynomial.radical_le_vanishingIdeal_zeroLocus : âˆ€ {k : Type u_1} [inst : Field k] {Ïƒ : Type u_2} (I : Ideal (MvPolynomial Ïƒ k)),
  I.radical â‰¤ MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus I)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{J |
  cifvar_15 (cifvar_1 x_0 J) (cifvar_16 J)}`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || SimpleGraph.Walk.not_nil_cons : âˆ€ {V : Type u} {G : SimpleGraph V} {u v w : V} {h : G.Adj u v} {p : G.Walk v w}, Â¬(SimpleGraph.Walk.cons h p).Nil
Result.autoException ::
Auto failed to find proof

Testing || Isometry.preimage_emetric_ball : âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},
  Isometry f â†’ âˆ€ (x : Î±) (r : ENNReal), f â»Â¹' EMetric.ball (f x) r = EMetric.ball x r
Result.success

Testing || CategoryTheory.isCoseparating_empty_of_thin : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : Quiver.IsThin C], CategoryTheory.IsCoseparating âˆ…
Result.autoException ::
Auto failed to find proof

Testing || ENNReal.fun_eq_funMulInvSnorm_mul_snorm : âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p : â„} (f : Î± â†’ ENNReal),
  âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  0 â†’
    âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ€ {a : Î±}, f a = ENNReal.funMulInvSnorm f p Î¼ a * (âˆ«â» (c : Î±), f c ^ p âˆ‚Î¼) ^ (1 / p)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆ«â» (c : Î±),
  cifvar_11 (cifvar_6 c) x_1 âˆ‚x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || CategoryTheory.IsFiltered.of_isRightAdjoint : âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type uâ‚}
  [inst_2 : CategoryTheory.Category.{vâ‚, uâ‚} D] (R : CategoryTheory.Functor C D) [inst : R.IsRightAdjoint],
  CategoryTheory.IsFiltered D
Result.autoException ::
Auto failed to find proof

Testing || heq_rec_iff_heq : âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {a b : Î±} {C : Î± â†’ Sort u_1} {x : Î²} {y : C a} {e : a = b}, HEq x (e â–¸ y) â†” HEq x y
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.braiding_tensorUnit_left_assoc : âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C]
  [inst_2 : CategoryTheory.BraidedCategory C] (X : C) {Z : C}
  (h : CategoryTheory.MonoidalCategory.tensorObj X (ğŸ™_ C) âŸ¶ Z),
  CategoryTheory.CategoryStruct.comp (Î²_ (ğŸ™_ C) X).hom h =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv h)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.leftUnitor
  x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || lipschitzOnWith_iff_norm_div_le : âˆ€ {E : Type u_3} {F : Type u_4} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F] {s : Set E} {f : E â†’ F}
  {C : NNReal}, LipschitzOnWith C f s â†” âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ â€–f x / f yâ€– â‰¤ â†‘C * â€–x / yâ€–
Result.success

Testing || ProbabilityTheory.IsMeasurableRatCDF.tendsto_atBot_zero : âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„š â†’ â„},
  ProbabilityTheory.IsMeasurableRatCDF f â†’ âˆ€ (a : Î±), Filter.Tendsto (f a) Filter.atBot (nhds 0)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.Tendsto (cifvar_8 x_0)
  cifvar_3 (cifvar_4 cifvar_5)`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || ULift.up_injective : âˆ€ {Î± : Type u}, Function.Injective ULift.up
Result.autoException ::
Auto failed to find proof

Testing || IsCyclotomicExtension.Rat.absdiscr_prime_pow_succ : âˆ€ (p : â„•+) (k : â„•) (K : Type u) [inst : Field K] [hp : Fact (Nat.Prime â†‘p)] [inst_1 : CharZero K]
  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} â„š K],
  NumberField.discr K = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2) * â†‘â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_27 x_0 x }`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || SemilatticeSup.ext : âˆ€ {Î± : Type u_1} {A B : SemilatticeSup Î±}, (âˆ€ (x y : Î±), x â‰¤ y â†” x â‰¤ y) â†’ A = B
Result.autoException ::
Auto failed to find proof

Testing || balanced_zero : âˆ€ {ğ•œ : Type u_1} {E : Type u_3} [inst : SeminormedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E], Balanced ğ•œ 0
Result.autoException ::
Auto failed to find proof

Testing || Orientation.oangle_rotation_oangle_left : âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : Fact (Module.finrank â„ V = 2)]
  (o : Orientation â„ V (Fin 2)) (x y : V), o.oangle ((o.rotation (o.oangle x y)) x) y = 0
Result.autoException ::
Auto failed to find proof

Testing || Finsupp.card_Ioc : âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : PartialOrder Î±] [inst_1 : Zero Î±] [inst_2 : LocallyFiniteOrder Î±]
  (f g : Î¹ â†’â‚€ Î±), (Finset.Ioc f g).card = âˆ i âˆˆ f.support âˆª g.support, (Finset.Icc (f i) (g i)).card - 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `âˆ
  i âˆˆ cifvar_8 (cifvar_9 x_0) (cifvar_9 x_1), cifvar_13 (cifvar_15 (cifvar_19 x_0 i) (cifvar_19 x_1 i))`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || SubfieldClass.coe_ratCast : âˆ€ {K : Type u} [inst : DivisionRing K] {S : Type u_1} [inst_1 : SetLike S K] [h : SubfieldClass S K] (s : S) (x : â„š),
  â†‘â†‘x = â†‘x
Result.autoException ::
Auto failed to find proof

Testing || AnalyticOn.iteratedFDeriv : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ğ•œ E] {F : Type v} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}
  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOnNhd ğ•œ f s â†’ âˆ€ (n : â„•), AnalyticOnNhd ğ•œ (iteratedFDeriv ğ•œ n f) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Fin.fintype n`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Set.image2_inter_subset_left : âˆ€ {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f : Î± â†’ Î² â†’ Î³} {s s' : Set Î±} {t : Set Î²},
  Set.image2 f (s âˆ© s') t âŠ† Set.image2 f s t âˆ© Set.image2 f s' t
Result.autoException ::
Auto failed to find proof

Testing || Irrational.div_nat : âˆ€ {x : â„}, Irrational x â†’ âˆ€ {m : â„•}, m â‰  0 â†’ Irrational (x / â†‘m)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Oplax.category_comp : âˆ€ {B : Type uâ‚} [inst : CategoryTheory.Bicategory B] {C : Type uâ‚‚} [inst_1 : CategoryTheory.Bicategory C]
  (F G : CategoryTheory.OplaxFunctor B C) {X Y Z : F âŸ¶ G} (Î“ : CategoryTheory.Oplax.Modification X Y)
  (Î” : CategoryTheory.Oplax.Modification Y Z), CategoryTheory.CategoryStruct.comp Î“ Î” = Î“.vcomp Î”
Result.autoException ::
Auto failed to find proof

Testing || homothety_inv_two : âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Field k] [inst_1 : CharZero k] [inst_2 : AddCommGroup V]
  [inst_3 : Module k V] [inst_4 : AddTorsor V P] (a b : P), (AffineMap.homothety a 2â»Â¹) b = midpoint k a b
Result.autoException ::
Auto failed to find proof

Testing || MulActionHom.map_smul : âˆ€ {M' : Type u_1} {X : Type u_5} [inst : SMul M' X] {Y : Type u_6} [inst_1 : SMul M' Y] (f : X â†’â‚‘[id] Y) (m : M')
  (x : X), f (m â€¢ x) = m â€¢ f x
Result.success

Testing || AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_snd_fst : âˆ€ {X : AlgebraicGeometry.Scheme} (ğ’° : X.OpenCover) (x y z : ğ’°.J),
  CategoryTheory.CategoryStruct.comp (ğ’°.gluedCoverT' x y z)
      (CategoryTheory.CategoryStruct.comp
        (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z))
          (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x)))
        (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y))
        (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z)))
      (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_16.map x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || List.unattach_join : âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {l : List (List { x // p x })}, l.join.unattach = (List.map List.unattach l).join
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearEquiv.piCongrRight_symm_apply : âˆ€ {Râ‚ : Type u_1} [inst : Semiring Râ‚] {Î¹ : Type u_9} {M : Î¹ â†’ Type u_10} [inst_1 : (i : Î¹) â†’ TopologicalSpace (M i)]
  [inst_2 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_3 : (i : Î¹) â†’ Module Râ‚ (M i)] {N : Î¹ â†’ Type u_11}
  [inst_4 : (i : Î¹) â†’ TopologicalSpace (N i)] [inst_5 : (i : Î¹) â†’ AddCommMonoid (N i)]
  [inst_6 : (i : Î¹) â†’ Module Râ‚ (N i)] (f : (i : Î¹) â†’ M i â‰ƒL[Râ‚] N i) (n : (i : Î¹) â†’ N i) (i : Î¹),
  (ContinuousLinearEquiv.piCongrRight f).symm n i = (f i).symm (n i)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Int.le_iff_pos_of_dvd : âˆ€ {a b : â„¤}, 0 < a â†’ a âˆ£ b â†’ (a â‰¤ b â†” 0 < b)
Result.success

Testing || Real.zpow_le_of_le_log : âˆ€ {x y : â„} {n : â„¤}, 0 < y â†’ Real.log x â‰¤ â†‘n * Real.log y â†’ x â‰¤ y ^ n
Result.success

Testing || Ideal.radical_eq_top : âˆ€ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, I.radical = âŠ¤ â†” I = âŠ¤
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.Î“Spec.toOpen_comp_locallyRingedSpaceAdjunction_homEquiv_app : âˆ€ {X : AlgebraicGeometry.LocallyRingedSpace} {R : Type u} [inst : CommRing R]
  (f : AlgebraicGeometry.LocallyRingedSpace.Î“.rightOp.obj X âŸ¶ Opposite.op (CommRingCat.of R))
  (U :
    (TopologicalSpace.Opens
        â†‘â†‘(AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op (CommRingCat.of R))).toPresheafedSpace)áµ’áµ–),
  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R (Opposite.unop U))
      (((AlgebraicGeometry.Î“Spec.locallyRingedSpaceAdjunction.homEquiv X (Opposite.op (CommRingCat.of R))) f).c.app U) =
    CategoryTheory.CategoryStruct.comp f.unop (X.presheaf.map (CategoryTheory.homOfLE â‹¯).op)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Affine.nonsingular_negAdd : âˆ€ {F : Type u} [inst : Field F] {W : WeierstrassCurve.Affine F} {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : F},
  W.Nonsingular xâ‚ yâ‚ â†’
    W.Nonsingular xâ‚‚ yâ‚‚ â†’
      (xâ‚ = xâ‚‚ â†’ yâ‚ â‰  W.negY xâ‚‚ yâ‚‚) â†’
        W.Nonsingular (W.addX xâ‚ xâ‚‚ (W.slope xâ‚ xâ‚‚ yâ‚ yâ‚‚)) (W.negAddY xâ‚ xâ‚‚ yâ‚ (W.slope xâ‚ xâ‚‚ yâ‚ yâ‚‚))
Result.autoException ::
Auto failed to find proof

Testing || finrank_le_one : âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]
  [inst_3 : NoZeroSMulDivisors R M] [inst_4 : StrongRankCondition R] (v : M),
  (âˆ€ (w : M), âˆƒ c, c â€¢ v = w) â†’ Module.finrank R M â‰¤ 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `One.toOfNat1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Option.mapâ‚‚_coe_left : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â†’ Î² â†’ Î³) (a : Î±) (b : Option Î²),
  Option.mapâ‚‚ f (some a) b = Option.map (fun b => f a b) b
Result.autoException ::
Auto failed to find proof

Testing || DomMulAct.inducing_mk_symm : âˆ€ {M : Type u_1} [inst : TopologicalSpace M], IsInducing â‡‘DomMulAct.mk.symm
Result.success

Testing || ContinuousAlternatingMap.map_update_zero : âˆ€ {R : Type u_1} {M : Type u_2} {N : Type u_4} {Î¹ : Type u_6} [inst : Semiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : Module R M] [inst_3 : TopologicalSpace M] [inst_4 : AddCommMonoid N] [inst_5 : Module R N]
  [inst_6 : TopologicalSpace N] (f : M [â‹€^Î¹]â†’L[R] N) [inst_7 : DecidableEq Î¹] (m : Î¹ â†’ M) (i : Î¹),
  f (Function.update m i 0) = 0
Result.autoException ::
Auto failed to find proof

Testing || ArithmeticFunction.pmul_apply : âˆ€ {R : Type u_1} [inst : MulZeroClass R] {f g : ArithmeticFunction R} {x : â„•}, (f.pmul g) x = f x * g x
Result.autoException ::
Auto failed to find proof

Testing || List.dropLast_prefix : âˆ€ {Î± : Type u_1} (l : List Î±), l.dropLast <+: l
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.Scheme.homOfLE_Î¹ : âˆ€ (X : AlgebraicGeometry.Scheme) {U V : X.Opens} (e : U â‰¤ V), CategoryTheory.CategoryStruct.comp (X.homOfLE e) V.Î¹ = U.Î¹
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_12
      (cifvar_13 (cifvar_14 (cifvar_15 (cifvar_17 x_0))))).instFunLike
  (cifvar_12 (cifvar_13 (cifvar_14 (cifvar_15 cifvar_16))))`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Set.range_list_getI : âˆ€ {Î± : Type u_1} [inst : Inhabited Î±] (l : List Î±), Set.range l.getI = insert default {x | x âˆˆ l}
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.range fun n =>
  cifvar_8 (cifvar_9 x_0 n) x_1`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || IsQuotientMap.isClopen_preimage : âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X â†’ Y},
  IsQuotientMap f â†’ âˆ€ {s : Set Y}, IsClopen (f â»Â¹' s) â†” IsClopen s
Result.autoException ::
Auto failed to find proof

Testing || Bifunctor.id_fst : âˆ€ {F : Type uâ‚€ â†’ Type uâ‚ â†’ Type uâ‚‚} [inst : Bifunctor F] [inst_1 : LawfulBifunctor F] {Î± : Type uâ‚€} {Î² : Type uâ‚}
  (x : F Î± Î²), Bifunctor.fst id x = x
Result.success

Testing || Auto.Embedding.Lam.LamTerm.rwGenAll_atom : âˆ€ {conv : Auto.Embedding.Lam.LamTerm â†’ Option Auto.Embedding.Lam.LamTerm} {n : â„•},
  Auto.Embedding.Lam.LamTerm.rwGenAll conv (Auto.Embedding.Lam.LamTerm.atom n) =
    some ((conv (Auto.Embedding.Lam.LamTerm.atom n)).getD (Auto.Embedding.Lam.LamTerm.atom n))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `match cifvar_7 x_0 with
| some t' => cifvar_5 t'
| none => cifvar_5 x_0`.
This is because it has subterms possessing at least one of the following features
Â· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
Â· Î» binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
Â· Other (TODO)

Testing || Multiset.Nodup.product : âˆ€ {Î± : Type u_1} {Î² : Type v} {s : Multiset Î±} {t : Multiset Î²}, s.Nodup â†’ t.Nodup â†’ (s Ã—Ë¢ t).Nodup
Result.autoException ::
Auto failed to find proof

Testing || Set.toFinset_congr : âˆ€ {Î± : Type u_1} {s t : Set Î±} [inst : Fintype â†‘s] [inst_1 : Fintype â†‘t], s = t â†’ s.toFinset = t.toFinset
Result.autoException ::
Auto failed to find proof

Testing || List.suffix_iff_eq_append : âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <:+ lâ‚‚ â†” List.take (lâ‚‚.length - lâ‚.length) lâ‚‚ ++ lâ‚ = lâ‚‚
Result.autoException ::
Auto failed to find proof

Elapsed time: 746848 ms

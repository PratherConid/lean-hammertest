Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || AEMeasurable.inf : ‚àÄ {M : Type u_1} [inst : MeasurableSpace M] {Œ± : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}
  {f g : Œ± ‚Üí M} [inst_1 : Min M] [inst_2 : MeasurableInf‚ÇÇ M],
  AEMeasurable f Œº ‚Üí AEMeasurable g Œº ‚Üí AEMeasurable (fun a => f a ‚äì g a) Œº
Result.autoException ::
Auto failed to find proof

Testing || Std.HashSet.getD_insert : ‚àÄ {Œ± : Type u} {x : BEq Œ±} {x_1 : Hashable Œ±} {m : Std.HashSet Œ±} [inst : EquivBEq Œ±] [inst : LawfulHashable Œ±]
  {k a fallback : Œ±}, (m.insert k).getD a fallback = if (k == a) = true ‚àß k ‚àâ m then k else m.getD a fallback
Result.autoException ::
application type mismatch
  Std.HashSet Œ± = { inner := Std.HashSet Œ± }.inner
argument
  { inner := Std.HashSet Œ± }.inner
has type
  Std.HashMap Œ± Unit : Type u
but is expected to have type
  Type u : Type (u + 1)

Testing || LinOrd.Iso.mk_inv : ‚àÄ {Œ± Œ≤ : LinOrd} (e : ‚ÜëŒ± ‚âÉo ‚ÜëŒ≤), (LinOrd.Iso.mk e).inv = ‚Üëe.symm
Result.success

Testing || List.sublistsLen_length : ‚àÄ {Œ± : Type u} (l : List Œ±), List.sublistsLen l.length l = [l]
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `List.map (cifvar_9 x_1)
  (cifvar_2 x_0 x_2)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || GenContFract.zeroth_contAux_eq_one_zero : ‚àÄ {K : Type u_1} {g : GenContFract K} [inst : DivisionRing K], g.contsAux 0 = { a := 1, b := 0 }
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Stream' (GenContFract.Pair K) is not a `‚àÄ`

Testing || Rat.cast_sub_of_ne_zero : ‚àÄ {Œ± : Type u_3} [inst : DivisionRing Œ±] {p q : ‚Ñö}, ‚Üëp.den ‚â† 0 ‚Üí ‚Üëq.den ‚â† 0 ‚Üí ‚Üë(p - q) = ‚Üëp - ‚Üëq
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.den_nz`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.Combinatorics.SimpleGraph.Triangle.Counting.0.SimpleGraph.edgeDensity_badVertices_le : ‚àÄ {Œ± : Type u_1} (G : SimpleGraph Œ±) [inst : DecidableRel G.Adj] {Œµ : ‚Ñù} {s t : Finset Œ±},
  0 ‚â§ Œµ ‚Üí 2 * Œµ ‚â§ ‚Üë(G.edgeDensity s t) ‚Üí ‚Üë(G.edgeDensity (SimpleGraph.badVertices G Œµ s t) t) ‚â§ ‚Üë(G.edgeDensity s t) - Œµ
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubtractionMonoid`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.Combinatorics.Additive.SmallTripling.0.Finset.small_pos_neg_pos_add : ‚àÄ {G : Type u_1} [inst : DecidableEq G] [inst_1 : AddGroup G] {A : Finset G} {K : ‚Ñù},
  ‚Üë(3 ‚Ä¢ A).card ‚â§ K * ‚ÜëA.card ‚Üí ‚Üë(A + -A + A).card ‚â§ K ^ 3 * ‚ÜëA.card
Result.autoException ::
Auto failed to find proof

Testing || AddMonoid.exponent_pi_eq_zero : ‚àÄ {Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí AddMonoid (M i)] {j : Œπ},
  AddMonoid.exponent (M j) = 0 ‚Üí AddMonoid.exponent ((i : Œπ) ‚Üí M i) = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `n ‚Ä¢ g`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || isLUB_sSup : ‚àÄ {Œ± : Type u_1} [inst : CompleteSemilatticeSup Œ±] (s : Set Œ±), IsLUB s (sSup s)
Result.autoException ::
Auto failed to find proof

Testing || Algebra.coe_sInf : ‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  (S : Set (Subalgebra R A)), ‚Üë(sInf S) = ‚ãÇ s ‚àà S, ‚Üës
Result.autoException ::
Auto failed to find proof

Testing || Set.image_mul_left_Ioo : ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±},
  0 < a ‚Üí ‚àÄ (b c : Œ±), (fun x => a * x) '' Set.Ioo b c = Set.Ioo (a * b) (a * c)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_9 x x_2) ''
  cifvar_6 x_0 x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FirstOrder.Language.ElementaryEmbedding.map_rel : ‚àÄ {L : FirstOrder.Language} {M : Type u_1} {N : Type u_2} [inst : L.Structure M] [inst_1 : L.Structure N]
  (œÜ : L.ElementaryEmbedding M N) {n : ‚Ñï} (r : L.Relations n) (x : Fin n ‚Üí M),
  FirstOrder.Language.Structure.RelMap r (‚áëœÜ ‚àò x) ‚Üî FirstOrder.Language.Structure.RelMap r x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_13 x_0 ‚àò cifvar_14`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || hnot_le_iff_codisjoint_left : ‚àÄ {Œ± : Type u_2} [inst : CoheytingAlgebra Œ±] {a b : Œ±}, Ôø¢a ‚â§ b ‚Üî Codisjoint b a
Result.success

Testing || SemistandardYoungTableau.copy_eq : ‚àÄ {Œº : YoungDiagram} (T : SemistandardYoungTableau Œº) (entry' : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï) (h : entry' = ‚áëT), T.copy entry' h = T
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 x_0 = cifvar_8 x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map' : ‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_3, u_2} D] {G : CategoryTheory.Functor C D} {A : Type w}
  [inst_2 : CategoryTheory.Category.{w', w} A] {J : CategoryTheory.GrothendieckTopology C}
  {K : CategoryTheory.GrothendieckTopology D} [inst_3 : G.IsCocontinuous J K] {F : CategoryTheory.Functor C·µí·µñ A}
  (hF : CategoryTheory.Presheaf.IsSheaf J F) {R : CategoryTheory.Functor D·µí·µñ A} (Œ± : G.op.comp R ‚ü∂ F) {X : D}
  {S : K.Cover X} (s : CategoryTheory.Limits.Multifork (S.index R)) {Y Y' : C} (f : G.obj Y ‚ü∂ X) (f' : G.obj Y' ‚ü∂ X)
  {W : C} (a : W ‚ü∂ Y) (b : W ‚ü∂ Y'),
  CategoryTheory.CategoryStruct.comp (G.map a) f = CategoryTheory.CategoryStruct.comp (G.map b) f' ‚Üí
    CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Œ± s f) (F.map a.op) =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Œ± s f') (F.map b.op)
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.Spec.toSheafedSpace_obj : ‚àÄ (R : CommRingCat·µí·µñ),
  AlgebraicGeometry.Spec.toSheafedSpace.obj R = AlgebraicGeometry.Spec.sheafedSpaceObj (Opposite.unop R)
Result.autoException ::
application type mismatch
  CommRing Œ± = Opposite.unop (Opposite.op (CommRing Œ±))
argument
  Opposite.unop (Opposite.op (CommRing Œ±))
has type
  CommRingCat : Type (u + 1)
but is expected to have type
  Type u : Type (u + 1)

Testing || Set.image_preimage : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤}, GaloisConnection (Set.image f) (Set.preimage f)
Result.autoException ::
Auto failed to find proof

Testing || deriv_sinh : ‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù}, DifferentiableAt ‚Ñù f x ‚Üí deriv (fun x => Real.sinh (f x)) x = Real.cosh (f x) * deriv f x
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WCovBy.le_of_lt : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b c : Œ±}, a ‚©ø b ‚Üí c < b ‚Üí c ‚â§ a
Result.autoException ::
Auto failed to find proof

Testing || Bool.not_eq_not : ‚àÄ {a b : Bool}, ¬¨a = !b ‚Üî a = b
Result.success

Testing || CategoryTheory.Limits.coneOfSectionCompYoneda_pt : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J : Type w} [inst_1 : CategoryTheory.Category.{t, w} J]
  (F : CategoryTheory.Functor J C·µí·µñ) (X : C) (s : ‚Üë(F.comp (CategoryTheory.yoneda.obj X)).sections),
  (CategoryTheory.Limits.coneOfSectionCompYoneda F X s).pt = Opposite.op X
Result.autoException ::
application type mismatch
  Opposite.op unop = Opposite.unop (Opposite.op (Opposite.op unop))
argument
  Opposite.unop (Opposite.op (Opposite.op unop))
has type
  C : Type u
but is expected to have type
  C·µí·µñ : Type u

Testing || WittVector.wittMul_vars : ‚àÄ (p : ‚Ñï) [hp : Fact (Nat.Prime p)] (n : ‚Ñï), (WittVector.wittMul p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1)
Result.autoException ::
Auto failed to find proof

Testing || Real.borel_eq_generateFrom_Ioi_rat : borel ‚Ñù = MeasurableSpace.generateFrom (‚ãÉ a, {Set.Ioi ‚Üëa})
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ‚àà x_1 of Œª binder contains bound variables

Testing || HomologicalComplex‚ÇÇ.comm_f : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {I‚ÇÅ : Type u_2} {I‚ÇÇ : Type u_3} {c‚ÇÅ : ComplexShape I‚ÇÅ} {c‚ÇÇ : ComplexShape I‚ÇÇ} {K L : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ}
  (f : K ‚ü∂ L) (i‚ÇÅ i‚ÇÅ' : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ),
  CategoryTheory.CategoryStruct.comp ((f.f i‚ÇÅ).f i‚ÇÇ) ((L.d i‚ÇÅ i‚ÇÅ').f i‚ÇÇ) =
    CategoryTheory.CategoryStruct.comp ((K.d i‚ÇÅ i‚ÇÅ').f i‚ÇÇ) ((f.f i‚ÇÅ').f i‚ÇÇ)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_17.d cifvar_16 x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Asymptotics.IsBigO.comp_tendsto : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : Œ± ‚Üí E} {g : Œ± ‚Üí F}
  {l : Filter Œ±}, f =O[l] g ‚Üí ‚àÄ {k : Œ≤ ‚Üí Œ±} {l' : Filter Œ≤}, Filter.Tendsto k l' l ‚Üí (f ‚àò k) =O[l'] (g ‚àò k)
Result.autoException ::
Auto failed to find proof

Testing || Filter.Tendsto.cexp : ‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {f : Œ± ‚Üí ‚ÑÇ} {z : ‚ÑÇ},
  Filter.Tendsto f l (nhds z) ‚Üí Filter.Tendsto (fun x => Complex.exp (f x)) l (nhds (Complex.exp z))
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsLocalizedModule.fromLocalizedModule'_add : ‚àÄ {R : Type u_1} [inst : CommSemiring R] (S : Submonoid R) {M : Type u_2} {M' : Type u_3} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M'] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M'] (f : M ‚Üí‚Çó[R] M')
  [inst_5 : IsLocalizedModule S f] (x y : LocalizedModule S M),
  IsLocalizedModule.fromLocalizedModule' S f (x + y) =
    IsLocalizedModule.fromLocalizedModule' S f x + IsLocalizedModule.fromLocalizedModule' S f y
Result.autoException ::
Auto failed to find proof

Testing || AffineSubspace.affineSpan_coe : ‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ‚Üës = s
Result.autoException ::
Auto failed to find proof

Testing || ENat.mem_nhds_natCast_iff : ‚àÄ (n : ‚Ñï) {s : Set ‚Ñï‚àû}, s ‚àà nhds ‚Üën ‚Üî ‚Üën ‚àà s
Result.success

Testing || HasProd.div : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CommGroup Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalGroup Œ±]
  {f g : Œ≤ ‚Üí Œ±} {a‚ÇÅ a‚ÇÇ : Œ±}, HasProd f a‚ÇÅ ‚Üí HasProd g a‚ÇÇ ‚Üí HasProd (fun b => f b / g b) (a‚ÇÅ / a‚ÇÇ)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsLocalization.coeSubmodule_fg : ‚àÄ {R : Type u_1} [inst : CommSemiring R] (S : Type u_2) [inst_1 : CommSemiring S] [inst_2 : Algebra R S],
  Function.Injective ‚áë(algebraMap R S) ‚Üí ‚àÄ (I : Ideal R), (IsLocalization.coeSubmodule S I).FG ‚Üî Submodule.FG I
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective
  (cifvar_10 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.IsPullback.of_right : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÅ‚ÇÉ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÇ‚ÇÉ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ}
  {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ},
  CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp h‚ÇÅ‚ÇÅ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ
      (CategoryTheory.CategoryStruct.comp h‚ÇÇ‚ÇÅ h‚ÇÇ‚ÇÇ) ‚Üí
    CategoryTheory.CategoryStruct.comp h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ = CategoryTheory.CategoryStruct.comp v‚ÇÅ‚ÇÅ h‚ÇÇ‚ÇÅ ‚Üí
      CategoryTheory.IsPullback h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ ‚Üí CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ
Result.success

Testing || Nat.nonempty_properDivisors : ‚àÄ {n : ‚Ñï}, n.properDivisors.Nonempty ‚Üî 1 < n
Result.autoException ::
Auto failed to find proof

Testing || RingEquiv.map_prod : ‚àÄ {Œ± : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommSemiring R] [inst_1 : CommSemiring S] (g : R ‚âÉ+* S)
  (f : Œ± ‚Üí R) (s : Finset Œ±), g (‚àè x ‚àà s, f x) = ‚àè x ‚àà s, g (f x)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àè x ‚àà x_1,
  cifvar_2 x_0 (cifvar_10 x)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || dist_smul : ‚àÄ {M : Type u} {X : Type w} [inst : PseudoMetricSpace X] [inst_1 : SMul M X] [inst_2 : IsometricSMul M X] (c : M)
  (x y : X), dist (c ‚Ä¢ x) (c ‚Ä¢ y) = dist x y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Isometry fun x => cifvar_4 x_0 x`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || map_mul_right_nhds‚ÇÄ : ‚àÄ {G‚ÇÄ : Type u_3} [inst : TopologicalSpace G‚ÇÄ] [inst_1 : GroupWithZero G‚ÇÄ] [inst_2 : ContinuousMul G‚ÇÄ] {a : G‚ÇÄ},
  a ‚â† 0 ‚Üí ‚àÄ (b : G‚ÇÄ), Filter.map (fun x => x * a) (nhds b) = nhds (b * a)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.map (cifvar_11 x_0)
  (cifvar_7 x_1)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.find_le : ‚àÄ {n : ‚Ñï} {p : ‚Ñï ‚Üí Prop} [inst : DecidablePred p] {h : ‚àÉ n, p n}, p n ‚Üí Nat.find h ‚â§ n
Result.autoException ::
Auto failed to find proof

Testing || Finset.subset_mul_left : ‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] [inst_1 : MulOneClass Œ±] (s : Finset Œ±) {t : Finset Œ±}, 1 ‚àà t ‚Üí s ‚äÜ s * t
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.decidableEq b`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IterateAddAct.ext : ‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : IterateAddAct f}, x.val = y.val ‚Üí x = y
Result.autoException ::
application type mismatch
  ‚Ñï = { val := ‚Ñï }.val
argument
  { val := ‚Ñï }.val
has type
  ‚Ñï : Type
but is expected to have type
  Type : Type 1

Testing || Mathlib.Vector.mem_cons_of_mem : ‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (a a' : Œ±) (v : Mathlib.Vector Œ± n), a' ‚àà v.toList ‚Üí a' ‚àà (a ::·µ• v).toList
Result.success

Testing || Measurable.set_lintegral_kernel : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ± : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {Œ∫ : ProbabilityTheory.Kernel Œ± Œ≤}
  [inst : ProbabilityTheory.IsSFiniteKernel Œ∫] {f : Œ≤ ‚Üí ENNReal},
  Measurable f ‚Üí ‚àÄ {s : Set Œ≤}, MeasurableSet s ‚Üí Measurable fun a => ‚à´‚Åª (b : Œ≤) in s, f b ‚àÇŒ∫ a
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Nat.dvd_zero : ‚àÄ (a : ‚Ñï), a ‚à£ 0
Result.autoException ::
Auto failed to find proof

Testing || Function.Embedding.toEquivRange_symm_apply_self : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Fintype Œ±] [inst_1 : DecidableEq Œ≤] (f : Œ± ‚Ü™ Œ≤) (a : Œ±),
  f.toEquivRange.symm ‚ü®f a, ‚ãØ‚ü© = a
Result.autoException ::
Auto failed to find proof

Testing || Matrix.star_dotProduct_star : ‚àÄ {m : Type u_2} {Œ± : Type v} [inst : Fintype m] [inst_1 : NonUnitalSemiring Œ±] [inst_2 : StarRing Œ±] (v w : m ‚Üí Œ±),
  Matrix.dotProduct (star v) (star w) = star (Matrix.dotProduct w v)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.singleton_infs_singleton : ‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] [inst_1 : SemilatticeInf Œ±] {a b : Œ±}, {a} ‚äº {b} = {a ‚äì b}
Result.success

Testing || IsConjRoot.isIntegral : ‚àÄ {R : Type u_1} {A : Type u_5} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] {x y : A},
  IsIntegral R x ‚Üí IsConjRoot R x y ‚Üí IsIntegral R y
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.transfer_transfer : ‚àÄ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : ‚àÄ e ‚àà p.edges, e ‚àà H.edgeSet)
  {K : SimpleGraph V} (hp' : ‚àÄ e ‚àà (p.transfer H hp).edges, e ‚àà K.edgeSet),
  (p.transfer H hp).transfer K hp' = p.transfer K ‚ãØ
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type (p.transfer H hp).edges =
  x‚úù of Œª binder contains bound variables

Testing || CategoryTheory.ofTypeMonad_Œº_app : ‚àÄ (m : Type u ‚Üí Type u) [inst : Monad m] [inst_1 : LawfulMonad m] {Œ± : Type u} (a : m (m Œ±)),
  (CategoryTheory.ofTypeMonad m).Œº.app Œ± a = joinM a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: ((CategoryTheory.ofTypeMonad m).comp
        (CategoryTheory.ofTypeMonad m).toFunctor).obj
    Œ± ‚ü∂
  (CategoryTheory.ofTypeMonad m).obj Œ± is not a `‚àÄ`

Testing || measure_Ioc_lt_top : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : CompactIccSpace Œ±] {m : MeasurableSpace Œ±}
  {Œº : MeasureTheory.Measure Œ±} [inst_3 : MeasureTheory.IsLocallyFiniteMeasure Œº] {a b : Œ±}, Œº (Set.Ioc a b) < ‚ä§
Result.success

Testing || List.takeDTR_go_eq : ‚àÄ {Œ± : Type u_1} {dflt : Œ±} {acc : Array Œ±} (n : ‚Ñï) (l : List Œ±),
  List.takeDTR.go dflt n l acc = acc.toList ++ List.takeD n l dflt
Result.autoException ::
application type mismatch
  Œ±‚úù = { toList := Œ±‚úù }.toList
argument
  { toList := Œ±‚úù }.toList
has type
  List Œ±‚úù : Type u_1
but is expected to have type
  Type u_1 : Type (u_1 + 1)

Testing || Symmetric.iff : ‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Symmetric r ‚Üí ‚àÄ (x y : Œ±), r x y ‚Üî r y x
Result.autoException ::
Auto failed to find proof

Testing || LieModuleEquiv.symm_apply_apply : ‚àÄ {R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [inst : CommRing R] [inst_1 : LieRing L]
  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R N]
  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (e : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) (x : M), e.symm (e x) = x
Result.autoException ::
Auto failed to find proof

Testing || AffineIndependent.mem_affineSpan_iff : ‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [inst_3 : AddTorsor V P] {Œπ : Type u_4} [inst_4 : Nontrivial k] {p : Œπ ‚Üí P},
  AffineIndependent k p ‚Üí ‚àÄ (i : Œπ) (s : Set Œπ), p i ‚àà affineSpan k (p '' s) ‚Üî i ‚àà s
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : (#5 ‚Üí Prop), ((‚àÉx1 : #5, x0 x1) = (!14 x0))) is not type correct

Testing || CategoryTheory.ofTypeMonad_obj : ‚àÄ (m : Type u ‚Üí Type u) [inst : Monad m] [inst_1 : LawfulMonad m] (a : Type u),
  (CategoryTheory.ofTypeMonad m).obj a = m a
Result.success

Testing || Set.center_eq_univ : ‚àÄ (M : Type u_1) [inst : CommSemigroup M], Set.center M = Set.univ
Result.autoException ::
Auto failed to find proof

Testing || LinearIsometryEquiv.differentiableOn : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {s : Set E}
  (iso : E ‚âÉ‚Çó·µ¢[ùïú] F), DifferentiableOn ùïú (‚áëiso) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Differentiable cifvar_5
  (cifvar_8 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TwoUniqueSums.of_addHom : ‚àÄ {G : Type u} {H : Type v} [inst : Add G] [inst_1 : Add H] (f : H ‚Üí‚Çô+ G),
  (‚àÄ ‚¶Éa b c d : H‚¶Ñ, a + b = c + d ‚Üí f a = f c ‚àß f b = f d ‚Üí a = c ‚àß b = d) ‚Üí ‚àÄ [inst : TwoUniqueSums G], TwoUniqueSums H
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image (cifvar_3 x_5) x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SimpleGraph.Walk.map_toDeleteEdges_eq : ‚àÄ {V : Type u} {G : SimpleGraph V} {v w : V} (s : Set (Sym2 V)) {p : G.Walk v w} (hp : ‚àÄ e ‚àà p.edges, e ‚àâ s),
  SimpleGraph.Walk.map (SimpleGraph.Hom.mapSpanningSubgraphs ‚ãØ) (SimpleGraph.Walk.toDeleteEdges s p hp) = p
Result.autoException ::
Auto failed to find proof

Testing || LinearEquiv.symm_apply_apply : ‚àÄ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M‚ÇÇ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] {module_M : _root_.Module R M}
  {module_S_M‚ÇÇ : _root_.Module S M‚ÇÇ} {œÉ : R ‚Üí+* S} {œÉ' : S ‚Üí+* R} {re‚ÇÅ : RingHomInvPair œÉ œÉ'}
  {re‚ÇÇ : RingHomInvPair œÉ' œÉ} (e : M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) (b : M), e.symm (e b) = b
Result.autoException ::
Auto failed to find proof

Testing || Valuation.IsEquiv.ne_zero : ‚àÄ {R : Type u_3} {Œì‚ÇÄ : Type u_4} {Œì'‚ÇÄ : Type u_5} [inst : Ring R] [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]
  [inst_2 : LinearOrderedCommMonoidWithZero Œì'‚ÇÄ] {v‚ÇÅ : Valuation R Œì‚ÇÄ} {v‚ÇÇ : Valuation R Œì'‚ÇÄ},
  v‚ÇÅ.IsEquiv v‚ÇÇ ‚Üí ‚àÄ {r : R}, v‚ÇÅ r ‚â† 0 ‚Üî v‚ÇÇ r ‚â† 0
Result.success

Testing || List.pwFilter_map : ‚àÄ {Œ± : Type u_1} {R : Œ± ‚Üí Œ± ‚Üí Prop} {Œ≤ : Type u_2} [inst : DecidableRel R] (f : Œ≤ ‚Üí Œ±) (l : List Œ≤),
  List.pwFilter R (List.map f l) = List.map f (List.pwFilter (fun x y => R (f x) (f y)) l)
Result.autoException ::
Auto failed to find proof

Testing || Relator.RightUnique.forall‚ÇÇ : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {R : Œ± ‚Üí Œ≤ ‚Üí Prop}, Relator.RightUnique R ‚Üí Relator.RightUnique (List.Forall‚ÇÇ R)
Result.autoException ::
Auto failed to find proof

Testing || CFC.quasispectrum_zero_eq : ‚àÄ {R : Type u_1} {A : Type u_2} {p : A ‚Üí Prop} [inst : CommSemiring R] [inst_1 : Nontrivial R] [inst_2 : StarRing R]
  [inst_3 : MetricSpace R] [inst_4 : TopologicalSemiring R] [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A]
  [inst_7 : StarRing A] [inst_8 : TopologicalSpace A] [inst_9 : _root_.Module R A] [inst_10 : IsScalarTower R A A]
  [inst_11 : SMulCommClass R A A] [instCFC‚Çô : NonUnitalContinuousFunctionalCalculus R p], quasispectrum R 0 = {0}
Result.autoException ::
Auto failed to find proof

Testing || taylor_mean_remainder_cauchy : ‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x x‚ÇÄ : ‚Ñù} {n : ‚Ñï},
  x‚ÇÄ < x ‚Üí
    ContDiffOn ‚Ñù (‚Üën) f (Set.Icc x‚ÇÄ x) ‚Üí
      DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Set.Icc x‚ÇÄ x)) (Set.Ioo x‚ÇÄ x) ‚Üí
        ‚àÉ x' ‚àà Set.Ioo x‚ÇÄ x,
          f x - taylorWithinEval f n (Set.Icc x‚ÇÄ x) x‚ÇÄ x =
            iteratedDerivWithin (n + 1) f (Set.Icc x‚ÇÄ x) x' * (x - x') ^ n / ‚Üën.factorial * (x - x‚ÇÄ)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Idempotents.DoldKan.N_obj : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.IsIdempotentComplete C] [inst_3 : CategoryTheory.Limits.HasFiniteCoproducts C]
  (X : CategoryTheory.SimplicialObject C),
  CategoryTheory.Idempotents.DoldKan.N.obj X =
    (CategoryTheory.Idempotents.toKaroubiEquivalence (ChainComplex C ‚Ñï)).inverse.obj
      (AlgebraicTopology.DoldKan.N‚ÇÅ.obj X)
Result.success

Testing || HomogeneousLocalization.val_zsmul : ‚àÄ {Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]
  {ùíú : Œπ ‚Üí Submodule R A} (x : Submonoid A) (n : ‚Ñ§) (y : HomogeneousLocalization ùíú x), (n ‚Ä¢ y).val = n ‚Ä¢ y.val
Result.success

Testing || Filter.NeBot.mul_zero_nonneg : ‚àÄ {Œ± : Type u_2} [inst : MulZeroClass Œ±] {f : Filter Œ±}, f.NeBot ‚Üí 0 ‚â§ f * 0
Result.autoException ::
Auto failed to find proof

Testing || sdiff_sdiff : ‚àÄ {Œ± : Type u_2} [inst : GeneralizedCoheytingAlgebra Œ±] (a b c : Œ±), (a \ b) \ c = a \ (b ‚äî c)
Result.success

Testing || Rat.ofInt_eq_cast : ‚àÄ (n : ‚Ñ§), Rat.ofInt n = ‚Üën
Result.success

Testing || QPF.Fix.ind_rec : ‚àÄ {F : Type u ‚Üí Type u} [q : QPF F] {Œ± : Type u} (g‚ÇÅ g‚ÇÇ : QPF.Fix F ‚Üí Œ±),
  (‚àÄ (x : F (QPF.Fix F)), g‚ÇÅ <$> x = g‚ÇÇ <$> x ‚Üí g‚ÇÅ (QPF.Fix.mk x) = g‚ÇÇ (QPF.Fix.mk x)) ‚Üí ‚àÄ (x : QPF.Fix F), g‚ÇÅ x = g‚ÇÇ x
Result.autoException ::
Auto failed to find proof

Testing || Polynomial.eval_one_cyclotomic_not_prime_pow : ‚àÄ {R : Type u_1} [inst : Ring R] {n : ‚Ñï},
  (‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÄ (k : ‚Ñï), p ^ k ‚â† n) ‚Üí Polynomial.eval 1 (Polynomial.cyclotomic n R) = 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective fun x =>
  cifvar_2 x_0 x`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || leibniz_cross : ‚àÄ {R : Type u_1} [inst : CommRing R] (u v w : Fin 3 ‚Üí R),
  (crossProduct u) ((crossProduct v) w) = (crossProduct ((crossProduct u) v)) w + (crossProduct v) ((crossProduct u) w)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Real.one_sub_le_exp_neg : ‚àÄ (x : ‚Ñù), 1 - x ‚â§ Real.exp (-x)
Result.success

Testing || Monovary.sum_smul_comp_perm_le_sum_smul : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemiring Œ±] [inst_1 : ExistsAddOfLE Œ±]
  [inst_2 : LinearOrderedCancelAddCommMonoid Œ≤] [inst_3 : _root_.Module Œ± Œ≤] [inst_4 : PosSMulMono Œ± Œ≤]
  {œÉ : Equiv.Perm Œπ} {f : Œπ ‚Üí Œ±} {g : Œπ ‚Üí Œ≤} [inst_5 : Fintype Œπ],
  Monovary f g ‚Üí ‚àë i : Œπ, f i ‚Ä¢ g (œÉ i) ‚â§ ‚àë i : Œπ, f i ‚Ä¢ g i
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àë i ‚àà x_0,
  cifvar_10 (cifvar_11 i) (cifvar_12 (cifvar_13 cifvar_14 (cifvar_13 x_1 i)))`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IndexedPartition.disjoint : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí Set Œ±}, IndexedPartition s ‚Üí Pairwise (Disjoint on s)
Result.autoException ::
Auto failed to find proof

Testing || isConjRoot_iff_mem_minpoly_rootSet : ‚àÄ {K : Type u_2} {S : Type u_4} [inst : CommRing S] [inst_1 : Field K] [inst_2 : Algebra K S] [inst_3 : IsDomain S]
  {x y : S}, IsIntegral K x ‚Üí (IsConjRoot K x y ‚Üî y ‚àà (minpoly K x).rootSet S)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_2.toFinset`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Perm.eraseP : ‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Bool) {l‚ÇÅ l‚ÇÇ : List Œ±},
  List.Pairwise (fun a b => f a = true ‚Üí f b = true ‚Üí False) l‚ÇÅ ‚Üí
    l‚ÇÅ.Perm l‚ÇÇ ‚Üí (List.eraseP f l‚ÇÅ).Perm (List.eraseP f l‚ÇÇ)
Result.autoException ::
Auto failed to find proof

Testing || Fin.appendIsometry_symm_apply : ‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (m n : ‚Ñï) (f : Fin (m + n) ‚Üí Œ±),
  (Fin.appendIsometry m n).symm f = (fun i => f (Fin.castAdd n i), fun i => f (Fin.natAdd m i))
Result.success

Testing || AddUnits.addRight_bijective : ‚àÄ {M : Type u_3} [inst : AddMonoid M] (a : AddUnits M), Function.Bijective fun x => x + ‚Üëa
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.length_transfer : ‚àÄ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : ‚àÄ e ‚àà p.edges, e ‚àà H.edgeSet),
  (p.transfer H hp).length = p.length
Result.autoException ::
Auto failed to find proof

Testing || CliffordAlgebra.forall_mul_self_eq_iff : ‚àÄ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {Q : QuadraticForm R M} {A : Type u_4} [inst_3 : Ring A] [inst_4 : Algebra R A],
  IsUnit 2 ‚Üí
    ‚àÄ (f : M ‚Üí‚Çó[R] A),
      (‚àÄ (x : M), f x * f x = (algebraMap R A) (Q x)) ‚Üî
        (LinearMap.mul R A).compl‚ÇÇ f ‚àò‚Çó f + (LinearMap.mul R A).flip.compl‚ÇÇ f ‚àò‚Çó f =
          LinearMap.compr‚ÇÇ (QuadraticMap.polarBilin Q) (Algebra.linearMap R A)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuadraticMap.polar (cifvar_10 x_0)
  a b`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Topology.IsQuotientMap.image_connectedComponent : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},
  Topology.IsQuotientMap f ‚Üí
    (‚àÄ (y : Œ≤), IsConnected (f ‚Åª¬π' {y})) ‚Üí ‚àÄ (a : Œ±), f '' connectedComponent a = connectedComponent (f a)
Result.success

Testing || isPiSystem_iUnion_of_monotone : ‚àÄ {Œ± : Type u_3} {Œπ : Type u_4} [inst : SemilatticeSup Œπ] (p : Œπ ‚Üí Set (Set Œ±)),
  (‚àÄ (n : Œπ), IsPiSystem (p n)) ‚Üí Monotone p ‚Üí IsPiSystem (‚ãÉ n, p n)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : #1, ((!0 x0) = (!5 x0 (Œªx1 : #2, (‚àÄ x2 : #2, ((!6 x0 x2) ‚Üí ((!7 (!8 x1 x2)) ‚Üí (!6 x0 (!8 x1 x2))))))))) is not type correct

Testing || Setoid.eq_of_mem_eqv_class : ‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)},
  (‚àÄ (a : Œ±), ‚àÉ! b, b ‚àà c ‚àß a ‚àà b) ‚Üí ‚àÄ {x : Œ±} {b b' : Set Œ±}, b ‚àà c ‚Üí x ‚àà b ‚Üí b' ‚àà c ‚Üí x ‚àà b' ‚Üí b = b'
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àÉ! b,
  cifvar_2 (cifvar_3 cifvar_4 b) (cifvar_5 b x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || univLE_max : UnivLE.{u, max u v}
Result.autoException ::
Auto failed to find proof

Testing || hasLineDerivAt_zero : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {F : Type u_2} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {E : Type u_3} [inst_3 : AddCommGroup E] [inst_4 : _root_.Module ùïú E] {f : E ‚Üí F} {x : E},
  HasLineDerivAt ùïú f 0 x 0
Result.autoException ::
Auto failed to find proof

Testing || Complex.polarCoord_apply : ‚àÄ (a : ‚ÑÇ), ‚ÜëComplex.polarCoord a = (Complex.abs a, a.arg)
Result.autoException ::
Auto failed to find proof

Testing || Complex.cosh_sub : ‚àÄ (x y : ‚ÑÇ), Complex.cosh (x - y) = Complex.cosh x * Complex.cosh y - Complex.sinh x * Complex.sinh y
Result.success

Testing || MeasureTheory.Measure.restrict_apply' : ‚àÄ {Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s t : Set Œ±},
  MeasurableSet s ‚Üí (Œº.restrict s) t = Œº (t ‚à© s)
Result.success

Testing || Inseparable.mem_open_iff : ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X} {s : Set X}, Inseparable x y ‚Üí IsOpen s ‚Üí (x ‚àà s ‚Üî y ‚àà s)
Result.success

Testing || CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_base : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor C CategoryTheory.Cat)
  {X Y : CategoryTheory.Grothendieck F} (f : X ‚ü∂ Y),
  ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).map f).base = f.base
Result.success

Testing || UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors : ‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R]
  [inst_2 : NormalizationMonoid R] {x : R},
  x ‚â† 0 ‚Üí (Squarefree x ‚Üî (UniqueFactorizationMonoid.normalizedFactors x).Nodup)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Multiset.count a x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContDiffAt.prod_map : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {n : WithTop ‚Ñï‚àû}
  {E' : Type u_3} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace ùïú E'] {F' : Type u_4}
  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace ùïú F'] {f : E ‚Üí F} {g : E' ‚Üí F'} {x : E} {y : E'},
  ContDiffAt ùïú n f x ‚Üí ContDiffAt ùïú n g y ‚Üí ContDiffAt ùïú n (Prod.map f g) (x, y)
Result.success

Testing || MeasureTheory.isClosed_aeStronglyMeasurable' : ‚àÄ {Œ± : Type u_1} {F : Type u_2} {p : ENNReal} [inst : NormedAddCommGroup F] {m m0 : MeasurableSpace Œ±}
  {Œº : MeasureTheory.Measure Œ±} [inst_1 : Fact (1 ‚â§ p)] [inst_2 : CompleteSpace F],
  m ‚â§ m0 ‚Üí IsClosed {f | MeasureTheory.AEStronglyMeasurable' m (‚Üë‚Üëf) Œº}
Result.autoException ::
Auto failed to find proof

Testing || ProbabilityTheory.Kernel.fst_comp : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ± : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {Œ≥ : Type u_3} {Œ¥ : Type u_4}
  {mŒ≥ : MeasurableSpace Œ≥} {mŒ¥ : MeasurableSpace Œ¥} (Œ∫ : ProbabilityTheory.Kernel Œ± Œ≤)
  (Œ∑ : ProbabilityTheory.Kernel Œ≤ (Œ≥ √ó Œ¥)), (Œ∑.comp Œ∫).fst = Œ∑.fst.comp Œ∫
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TypeVec.dropFun_id : ‚àÄ {n : ‚Ñï} {Œ± : TypeVec.{u_1} (n + 1)}, TypeVec.dropFun TypeVec.id = TypeVec.id
Result.success

Testing || Real.cos_sq_add_sin_sq : ‚àÄ (x : ‚Ñù), Real.cos x ^ 2 + Real.sin x ^ 2 = 1
Result.success

Testing || Equiv.addCommSemigroup.proof_1 : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} (e : Œ± ‚âÉ Œ≤) [inst : AddCommSemigroup Œ≤] (x y : Œ±), e (e.symm (e x + e y)) = e x + e y
Result.success

Testing || Nat.lcm_pos : ‚àÄ {m n : ‚Ñï}, 0 < m ‚Üí 0 < n ‚Üí 0 < m.lcm n
Result.success

Testing || PProd.exists' : ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {p : Œ± ‚Üí Œ≤ ‚Üí Prop}, (‚àÉ x, p x.fst x.snd) ‚Üî ‚àÉ a b, p a b
Result.autoException ::
Auto failed to find proof

Testing || div_le_div_left : ‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] {a b c : Œ±}, 0 < a ‚Üí 0 < b ‚Üí 0 < c ‚Üí (a / b ‚â§ a / c ‚Üî c ‚â§ b)
Result.success

Testing || Set.Finite.induction_to_univ : ‚àÄ {Œ± : Type u} [inst : Finite Œ±] {C : Set Œ± ‚Üí Prop} (S0 : Set Œ±),
  C S0 ‚Üí (‚àÄ (S : Set Œ±), S ‚â† Set.univ ‚Üí C S ‚Üí ‚àÉ a ‚àâ S, C (insert a S)) ‚Üí C Set.univ
Result.autoException ::
Auto failed to find proof

Testing || VectorBundleCore.continuous_proj : ‚àÄ {R : Type u_1} {B : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField R] [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace R F] [inst_3 : TopologicalSpace B] {Œπ : Type u_5} (Z : VectorBundleCore R B F Œπ),
  Continuous Z.proj
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Bundle.TotalSpace cifvar_3
  (cifvar_4 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.equivYoneda'_inv_val : ‚àÄ (S : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)),
  (CategoryTheory.equivYoneda' S).inv.val = (CategoryTheory.equivYoneda S.val ‚ãØ).inv
Result.autoException ::
application type mismatch
  Œ±·µí·µñ = { val := Œ±·µí·µñ }.val
argument
  { val := Œ±·µí·µñ }.val
has type
  (CategoryTheory.yoneda'.obj (S.val.obj (Opposite.op PUnit.{u + 1}))).val ‚ü∂ S.val : Type (u + 1)
but is expected to have type
  Type (u + 1) : Type (u + 2)

Testing || Fintype.decidableEqAddEquivFintype.proof_1 : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Add Œ≤] (a b : Œ± ‚âÉ+ Œ≤), ‚áëa = ‚áëb ‚Üî a = b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 a‚úù = cifvar_8 b`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || intervalIntegral.intervalIntegrable_log : ‚àÄ {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù} [inst : MeasureTheory.IsLocallyFiniteMeasure Œº],
  0 ‚àâ Set.uIcc a b ‚Üí IntervalIntegrable Real.log Œº a b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x.decidableEq cifvar_7`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || StrictConcaveOn.concaveOn : ‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_5} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]
  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : _root_.Module ùïú E] [inst_4 : _root_.Module ùïú Œ≤] {s : Set E} {f : E ‚Üí Œ≤},
  StrictConcaveOn ùïú s f ‚Üí ConcaveOn ùïú s f
Result.success

Testing || ProbabilityTheory.Kernel.ae_compProd_iff : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ± : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {Œ≥ : Type u_3}
  {mŒ≥ : MeasurableSpace Œ≥} {Œ∫ : ProbabilityTheory.Kernel Œ± Œ≤} [inst : ProbabilityTheory.IsSFiniteKernel Œ∫]
  {Œ∑ : ProbabilityTheory.Kernel (Œ± √ó Œ≤) Œ≥} [inst : ProbabilityTheory.IsSFiniteKernel Œ∑] {a : Œ±} {p : Œ≤ √ó Œ≥ ‚Üí Prop},
  MeasurableSet {x | p x} ‚Üí
    ((‚àÄ·µê (bc : Œ≤ √ó Œ≥) ‚àÇ(Œ∫.compProd Œ∑) a, p bc) ‚Üî ‚àÄ·µê (b : Œ≤) ‚àÇŒ∫ a, ‚àÄ·µê (c : Œ≥) ‚àÇŒ∑ (a, b), p (b, c))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àÄ·∂† (c : Œ≥) in
  cifvar_20 (cifvar_21 x_2 (cifvar_22 x_4 b)), cifvar_18 (cifvar_19 b c)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SMulPosReflectLT.toSMulPosMono : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SMul Œ± Œ≤] [inst_1 : Preorder Œ±] [inst_2 : LinearOrder Œ≤]
  [inst_3 : _root_.Zero Œ≤] [inst_4 : SMulPosReflectLT Œ± Œ≤], SMulPosMono Œ± Œ≤
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Zero.toOfNat0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.withDensity_indicator_one : ‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±},
  MeasurableSet s ‚Üí Œº.withDensity (s.indicator 1) = Œº.restrict s
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || add_halves' : ‚àÄ {R : Type u_1} [inst : DivisionSemiring R] [inst_1 : NeZero 2] (a : R), a / 2 + a / 2 = a
Result.success

Testing || CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {D : Type u'}
  [inst_2 : CategoryTheory.Category.{v', u'} D] [inst_3 : CategoryTheory.Preadditive D] (F : CategoryTheory.Functor C D)
  [inst_4 : F.PreservesZeroMorphisms] {J : Type} [inst_5 : Fintype J]
  [inst_6 : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F],
  CategoryTheory.Limits.PreservesBiproductsOfShape J F
Result.autoException ::
Auto failed to find proof

Testing || WithTop.image_coe_Ioi : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, WithTop.some '' Set.Ioi a = Set.Ioo ‚Üëa ‚ä§
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : #3, (‚àÄ x1 : #3, ((!3 x0 x1) = (!11 (!17 x0) (Œªx2 : #3, (!17 x2 x1)))))) is not type correct

Testing || CategoryTheory.forgetEnrichment_id : ‚àÄ {C : Type u‚ÇÅ} (W : Type v) [inst : CategoryTheory.Category.{w, v} W] [inst_1 : CategoryTheory.MonoidalCategory W]
  [inst_2 : CategoryTheory.EnrichedCategory W C] (X : CategoryTheory.ForgetEnrichment W C),
  CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.id X) =
    CategoryTheory.eId W (CategoryTheory.ForgetEnrichment.to W X)
Result.autoException ::
application type mismatch
  CategoryTheory.ForgetEnrichment W C = Opposite.unop (Opposite.op C)
argument
  Opposite.unop (Opposite.op C)
has type
  W : Type v
but is expected to have type
  Type u‚ÇÅ : Type (u‚ÇÅ + 1)

Testing || CategoryTheory.Comma.mapLeftComp_inv_app_left : ‚àÄ {A : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A] {B : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B]
  {T : Type u‚ÇÉ} [inst_2 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T] (R : CategoryTheory.Functor B T)
  {L‚ÇÅ L‚ÇÇ L‚ÇÉ : CategoryTheory.Functor A T} (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (l' : L‚ÇÇ ‚ü∂ L‚ÇÉ) (X : CategoryTheory.Comma L‚ÇÉ R),
  ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).left = CategoryTheory.CategoryStruct.id X.left
Result.success

Testing || Order.pred_lt : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : NoMinOrder Œ±] (a : Œ±), Order.pred a < a
Result.success

Testing || isOfFinAddOrder_zero : ‚àÄ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0
Result.success

Testing || gradient_eq : ‚àÄ {ùïú : Type u_1} {F : Type u_2} [inst : RCLike ùïú] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace ùïú F]
  [inst_3 : CompleteSpace F] {f : F ‚Üí ùïú} {f' : F ‚Üí F}, (‚àÄ (x : F), HasGradientAt f (f' x) x) ‚Üí gradient f = f'
Result.autoException ::
Auto failed to find proof

Testing || padicNorm.int_lt_one_iff : ‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p)] (m : ‚Ñ§), padicNorm p ‚Üëm < 1 ‚Üî ‚Üëp ‚à£ m
Result.success

Testing || FiberBundle.mem_baseSet_trivializationAt : ‚àÄ {B : Type u_2} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : B ‚Üí Type u_5)
  [inst_2 : TopologicalSpace (Bundle.TotalSpace F E)] [inst_3 : (b : B) ‚Üí TopologicalSpace (E b)]
  [inst_4 : FiberBundle F E] (b : B), b ‚àà (trivializationAt F E b).baseSet
Result.success

Testing || Multiset.map_add_left_Ioc : ‚àÄ {Œ± : Type u_1} [inst : OrderedCancelAddCommMonoid Œ±] [inst_1 : ExistsAddOfLE Œ±] [inst_2 : LocallyFiniteOrder Œ±]
  (a b c : Œ±), Multiset.map (fun x => c + x) (Multiset.Ioc a b) = Multiset.Ioc (c + a) (c + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image
  (fun x => cifvar_7 x_3 x) (cifvar_10 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IsOpen.div_right : ‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {s t : Set G},
  IsOpen s ‚Üí IsOpen (s / t)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ‚àà x_1 of Œª binder contains bound variables

Testing || ZModModule.add_add_add_cancel : ‚àÄ {G : Type u_2} [inst : AddCommGroup G] [inst_1 : _root_.Module (ZMod 2) G] (x y z : G), x + y + (y + z) = x + z
Result.success

Testing || ProbabilityTheory.centralMoment_one' : ‚àÄ {Œ© : Type u_1} {m : MeasurableSpace Œ©} {X : Œ© ‚Üí ‚Ñù} {Œº : MeasureTheory.Measure Œ©}
  [inst : MeasureTheory.IsFiniteMeasure Œº],
  MeasureTheory.Integrable X Œº ‚Üí ProbabilityTheory.centralMoment X 1 Œº = (1 - (Œº Set.univ).toReal) * ‚à´ (x : Œ©), X x ‚àÇŒº
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b ‚ü∂ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a ‚ü∂ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful] {Z : C} (h : a ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.fst' f') h) =
    CategoryTheory.CategoryStruct.comp (hf'.snd g) h
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `‚àÄ`

Testing || Duper.rule15bTheorem : ‚àÄ (b : Bool), (!!b) = b
Result.success

Testing || Real.summable_cexp_multipliable : ‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} (f : Œπ ‚Üí Œ± ‚Üí ‚Ñù),
  (‚àÄ (x : Œ±) (n : Œπ), 0 < f n x) ‚Üí
    (‚àÄ (x : Œ±), Summable fun n => Real.log (f n x)) ‚Üí ‚àÄ (a : Œ±), Multipliable fun b => f b a
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Summable fun n =>
  cifvar_7 (cifvar_2 n x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Elapsed time: 528951 ms

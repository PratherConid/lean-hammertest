Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || Lean.Omega.Int.lt_of_not_le : âˆ€ {x y : â„¤}, Â¬x â‰¤ y â†’ y < x
Result.success

Testing || Algebra.toSubsemiring_eq_top : âˆ€ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {S : Subalgebra R A},
  S.toSubsemiring = âŠ¤ â†” S = âŠ¤
Result.success

Testing || AddSubgroup.map_comap_eq : âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_5} [inst_1 : AddGroup N] (f : G â†’+ N) (H : AddSubgroup N),
  AddSubgroup.map f (AddSubgroup.comap f H) = f.range âŠ“ H
Result.autoException ::
Auto failed to find proof

Testing || Fin.val_add_one_le_of_gt : âˆ€ {n : â„•} {a b : Fin n}, a > b â†’ â†‘b + 1 â‰¤ â†‘a
Result.autoException ::
Auto failed to find proof

Testing || Finset.mem_of_subset : âˆ€ {Î± : Type u_1} {sâ‚ sâ‚‚ : Finset Î±} {a : Î±}, sâ‚ âŠ† sâ‚‚ â†’ a âˆˆ sâ‚ â†’ a âˆˆ sâ‚‚
Result.autoException ::
Auto failed to find proof

Testing || Submonoid.centralizer_univ : âˆ€ (M : Type u_1) [inst : Monoid M], Submonoid.centralizer Set.univ = Submonoid.center M
Result.autoException ::
Auto failed to find proof

Testing || Nat.succ_sub_succ_eq_sub : âˆ€ (n m : â„•), n.succ - m.succ = n - m
Result.autoException ::
Auto failed to find proof

Testing || Auto.Embedding.restoreAt_zero : âˆ€ {Î± : Sort u_1} (restore : (â„• â†’ Î±) â†’ â„• â†’ Î±), Auto.Embedding.restoreAt 0 restore = restore
Result.autoException ::
Auto failed to find proof

Testing || QuotientAddGroup.quotientKerEquivOfRightInverse.proof_3 : âˆ€ {G : Type u_1} [inst : AddGroup G] {H : Type u_2} [inst_1 : AddGroup H] (Ï† : G â†’+ H) (x y : G â§¸ Ï†.ker),
  (â†‘(QuotientAddGroup.kerLift Ï†)).toFun (x + y) =
    (â†‘(QuotientAddGroup.kerLift Ï†)).toFun x + (â†‘(QuotientAddGroup.kerLift Ï†)).toFun y
Result.success

Testing || orderOf_dvd_of_mem_zpowers : âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.zpowers x â†’ orderOf y âˆ£ orderOf x
Result.success

Testing || Function.update_vadd : âˆ€ {Î¹ : Type u_1} {M : Type u_2} {Î± : Î¹ â†’ Type u_4} [inst : (i : Î¹) â†’ VAdd M (Î± i)] [inst_1 : DecidableEq Î¹] (c : M)
  (fâ‚ : (i : Î¹) â†’ Î± i) (i : Î¹) (xâ‚ : Î± i), Function.update (c +áµ¥ fâ‚) i (c +áµ¥ xâ‚) = c +áµ¥ Function.update fâ‚ i xâ‚
Result.autoException ::
Auto failed to find proof

Testing || OrderIso.mulLeft_symm : âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : LE Î±] [inst_2 : MulLeftMono Î±] (a : Î±),
  (OrderIso.mulLeft a).symm = OrderIso.mulLeft aâ»Â¹
Result.autoException ::
Auto failed to find proof

Testing || Rat.divInt_neg : âˆ€ (n d : â„¤), Rat.divInt n (-d) = Rat.divInt (-n) d
Result.success

Testing || IsEmbedding.inl : âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsEmbedding Sum.inl
Result.success

Testing || Filter.bind_smallSets_gc : âˆ€ {Î± : Type u_1}, GaloisConnection (fun L => L.bind Filter.principal) Filter.smallSets
Result.autoException ::
Auto failed to find proof

Testing || isAddUnit_of_add_isAddUnit_right : âˆ€ {M : Type u_1} [inst : AddCommMonoid M] {x y : M}, IsAddUnit (x + y) â†’ IsAddUnit y
Result.success

Testing || nonempty_embedding_nat : âˆ€ (Î± : Sort u_1) [inst : Countable Î±], Nonempty (Î± â†ª â„•)
Result.autoException ::
Auto failed to find proof

Testing || lt_of_le_of_lt : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b < c â†’ a < c
Result.success

Testing || Finset.vadd_eq_empty : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : DecidableEq Î²] [inst_1 : VAdd Î± Î²] {s : Finset Î±} {t : Finset Î²},
  s +áµ¥ t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ…
Result.autoException ::
Auto failed to find proof

Testing || Finsupp.mapDomain_comapDomain : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] (f : Î± â†’ Î²) (hf : Function.Injective f)
  (l : Î² â†’â‚€ M), â†‘l.support âŠ† Set.range f â†’ Finsupp.mapDomain f (Finsupp.comapDomain f l â‹¯) = l
Result.autoException ::
Monomorphization failed because currently the proi : m) (j : n) (M : Matrix m n Î±), (Matrix.entryLinearMap R Î± i j) M = M i j
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n Î± is not a `âˆ€`

Testing || Trunc.induction_onâ‚‚ : âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {C : Trunc Î± â†’ Trunc Î² â†’ Prop} (qâ‚ : Trunc Î±) (qâ‚‚ : Trunc Î²),
  (âˆ€ (a : Î±) (b : Î²), C (Trunc.mk a) (Trunc.mk b)) â†’ C qâ‚ qâ‚‚
Result.success

Testing || Mathlib.Tactic.PushNeg.not_ne_eq : âˆ€ {Î± : Sort u_1} (x y : Î±), (Â¬x â‰  y) = (x = y)
Result.success

Testing || Equiv.symm_comp_eq : âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} (e : Î± â‰ƒ Î²) (f : Î³ â†’ Î±) (g : Î³ â†’ Î²), â‡‘e.symm âˆ˜ g = f â†” g = â‡‘e âˆ˜ f
Result.autoException ::
Auto failed to find proof

Testing || Submonoid.toAddSubmonoid_closure : âˆ€ {M : Type u_1} [inst : MulOneClass M] (S : Set M),
  Submonoid.toAddSubmonoid (Submonoid.closure S) = AddSubmonoid.closure (â‡‘Additive.toMul â»Â¹' S)
Result.autoException ::
Auto failed to find proof

Testing || minimal_eq_iff : âˆ€ {Î± : Type u_1} {x y : Î±} [inst : LE Î±], Minimal (fun x => x = y) x â†” x = y
Result.autoException ::
Auto failed to find proof

Testing || BitVec.getLsbD_setWidth' : âˆ€ {m n : â„•} (ge : m â‰¥ n) (x : BitVec n) (i : â„•), (BitVec.setWidth' ge x).getLsbD i = x.getLsbD i
Result.autoException ::
Auto failed to find proof

Testing || Filter.comap_fst_neBot_iff : âˆ€ {Î± : Type u} {Î² : Type v} {f : Filter Î±}, (Filter.comap Prod.fst f).NeBot â†” f.NeBot âˆ§ Nonempty Î²
Result.autoException ::
Auto failed to find proof

Testing || ULift.up_iInf : âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : InfSet Î±] (f : Î¹ â†’ Î±), { down := â¨… i, f i } = â¨… i, { down := f i }
Result.autoException ::
Auto failed to find proof

Testing || Finset.image_op_mul : âˆ€ {Î± : Type u_2} [inst : DecidableEq Î±] [inst_1 : Mul Î±] (s t : Finset Î±),
  Finset.image MulOpposite.op (s * t) = Finset.image MulOpposite.op t * Finset.image MulOpposite.op s
Result.autoException ::
Auto failed to find proof

Testing || Embedding.map_nhdsWithin_eq : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},
  IsEmbedding f â†’ âˆ€ (s : Set Î±) (x : Î±), Filter.map f (nhdsWithin x s) = nhdsWithin (f x) (f '' s)
Result.success

Testing || Filter.subtractionMonoid.proof_1 : âˆ€ {Î± : Type u_1} [inst : SubtractionMonoid Î±] (x x_1 : Filter Î±),
  Filter.map (fun x => x) (Filter.mapâ‚‚ (fun x1 x2 => x1 - x2) x x_1) =
    Filter.mapâ‚‚ (fun x1 x2 => x1 + x2) x (Filter.map Neg.neg x_1)
Result.autoException ::
Auto failed to find proof

Testing || Fin.coe_int_sub_eq_mod : âˆ€ {n : â„•} (u v : Fin n), â†‘â†‘(u - v) = (â†‘â†‘u - â†‘â†‘v) % â†‘n
Result.success

Testing || Subgroup.fg_iff_submonoid_fg : âˆ€ {G : Type u_3} [inst : Group G] (P : Subgroup G), P.FG â†” P.FG
Result.autoException ::
Auto failed to find proof

Testing || Equiv.prodUnique_symm_apply : âˆ€ {Î± : Type u_9} {Î² : Type u_10} [inst : Unique Î²] (x : Î±), (Equiv.prodUnique Î± Î²).symm x = (x, default)
Result.autoException ::
Auto failed to find proof

Testing || sdiff_sdiff_le : âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] {a b : Î±}, a \ (a \ b) â‰¤ b
Result.success

Testing || ofMul_inv : âˆ€ {Î± : Type u} [inst : Inv Î±] (x : Î±), Additive.ofMul xâ»Â¹ = -Additive.ofMul x
Result.autoException ::
Auto failed to find proof

Testing || Matrix.updateRow_apply : âˆ€ {m : Type u_2} {n : Type u_3} {Î± : Type v} {M : Matrix m n Î±} {i : m} {j : n} {b : n â†’ Î±} [inst : DecidableEq m]
  {i' : m}, M.updateRow i b i' j = if i' = i then b j else M i' j
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n Î± is not a `âˆ€`

Testing || Finset.map_inter : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DecidableEq Î±] [inst_1 : DecidableEq Î²] {f : Î± â†ª Î²} (sâ‚ sâ‚‚ : Finset Î±),
  Finset.map f (sâ‚ âˆ© sâ‚‚) = Finset.map f sâ‚ âˆ© Finset.map f sâ‚‚
Result.success

Testing || Int.neg_nonpos_of_nonneg : âˆ€ {a : â„¤}, 0 â‰¤ a â†’ -a â‰¤ 0
Result.success

Testing || List.Perm.pairwise : âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {l l' : List Î±},
  l.Perm l' â†’ List.Pairwise R l â†’ (âˆ€ {x y : Î±}, R x y â†’ R y x) â†’ List.Pairwise R l'
Result.success

Testing || OrderIso.withTopCongr_symm : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (e : Î± â‰ƒo Î²),
  e.withTopCongr.symm = e.symm.withTopCongr
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x_0 â‰ƒr x_1 of Î» binder contains bound variables

Testing || Std.HashMap.getKey?_eq_some_getKeyD : âˆ€ {Î± : Type u} {Î² : Type v} {x : BEq Î±} {x_1 : Hashable Î±} {m : Std.HashMap Î± Î²} [inst : EquivBEq Î±]
  [inst : LawfulHashable Î±] {a fallback : Î±}, a âˆˆ m â†’ m.getKey? a = some (m.getKeyD a fallback)
Result.autoException ::
Auto failed to find proof

Testing || List.Lex.singleton_iff : âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} (a b : Î±), List.Lex r [a] [b] â†” r a b
Result.autoException ::
Auto failed to find proof

Testing || abs_sub_nonpos : âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b : Î±}, |a - b| â‰¤ 0 â†” a = b
Result.success

Testing || Mathlib.Vector.map_nil : âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²), Mathlib.Vector.map f Mathlib.Vector.nil = Mathlib.Vector.nil
Result.autoException ::
Auto failed to find proof

Testing || Finsupp.zipWith_single_single : âˆ€ {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]
  (f : M â†’ N â†’ P) (hf : f 0 0 = 0) (a : Î±) (m : M) (n : N),
  Finsupp.zipWith f hf (Finsupp.single a m) (Finsupp.single a n) = Finsupp.single a (f m n)
Result.autoException ::
Auto failed to find proof

Testing || OrderEmbedding.image_setOf_minimal : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {Î² : Type u_2} [inst_1 : Preorder Î²] {s : Set Î±} {f : Î± â†ªo Î²},
  â‡‘f '' {x | Minimal (fun x => x âˆˆ s) x} = {x | Minimal (fun x => x âˆˆ â‡‘f '' s) x}
Result.autoException ::
Auto failed to find proof

Testing || Set.eqOn_comp_right_iff : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {s : Set Î±} {f : Î± â†’ Î²} {gâ‚ gâ‚‚ : Î² â†’ Î³},
  Set.EqOn (gâ‚ âˆ˜ f) (gâ‚‚ âˆ˜ f) s â†” Set.EqOn gâ‚ gâ‚‚ (f '' s)
Result.success

Testing || List.length_bind : âˆ€ {Î± : Type u_2} {Î² : Type u_3} (l : List Î±) (f : Î± â†’ List Î²), (l.bind f).length = (List.map (List.length âˆ˜ f) l).sum
Result.success

Testing || CovBy.image : âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] {a b : Î±} (f : Î± â†ªo Î²),
  a â‹– b â†’ (Set.range â‡‘f).OrdConnected â†’ f a â‹– f b
Result.autoException ::
Auto failed to find proof

Testing || Sigma.map_mk : âˆ€ {Î±â‚ : Type u_2} {Î±â‚‚ : Type u_3} {Î²â‚ : Î±â‚ â†’ Type u_5} {Î²â‚‚ : Î±â‚‚ â†’ Type u_6} (fâ‚ : Î±â‚ â†’ Î±â‚‚)
  (fâ‚‚ : (a : Î±â‚) â†’ Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)) (x : Î±â‚) (y : Î²â‚ x), Sigma.map fâ‚ fâ‚‚ âŸ¨x, yâŸ© = âŸ¨fâ‚ x, fâ‚‚ x yâŸ©
Result.autoException ::
Auto failed to find proof

Testing || CovBy.trans_antisymmRel : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b c : Î±}, a â‹– b â†’ AntisymmRel (fun x1 x2 => x1 â‰¤ x2) b c â†’ a â‹– c
Result.autoException ::
Auto failed to find proof

Testing || Std.DHashMap.Internal.Raw.erase_val : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : BEq Î±] [inst_1 : Hashable Î±] {m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²} {a : Î±},
  (â†‘m).erase a = â†‘(m.erase a)
Result.autoException ::
Auto failed to find proof

Testing || Fin.castSucc_lt_castSucc_iff : âˆ€ {n : â„•} {a b : Fin n}, a.castSucc < b.castSucc â†” a < b
Result.autoException ::
Auto failed to find proof

Testing || Order.Coframe.MinimalAxioms.iInf_sup_eq : âˆ€ {Î± : Type u} {Î¹ : Sort w} (minAx : Order.Coframe.MinimalAxioms Î±) (f : Î¹ â†’ Î±) (a : Î±), (â¨… i, f i) âŠ” a = â¨… i, f i âŠ” a
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a âˆˆ x_0 of Î» binder contains bound variables

Testing || Complex.ofReal_prod : âˆ€ {Î± : Type u_1} (s : Finset Î±) (f : Î± â†’ â„), â†‘(âˆ i âˆˆ s, f i) = âˆ i âˆˆ s, â†‘(f i)
Result.autoException ::
Auto failed to find proof

Testing || Set.biUnion_insert : âˆ€ {Î± : Type u_1} {Î² : Type u_2} (a : Î±) (s : Set Î±) (t : Î± â†’ Set Î²), â‹ƒ x âˆˆ insert a s, t x = t a âˆª â‹ƒ x âˆˆ s, t x
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type xâœ âˆˆ insert a s of Î» binder contains bound variables

Testing || AddAction.nsmul_add_period_vadd : âˆ€ {Î± : Type v} {M : Type u} [inst : AddMonoid M] [inst_1 : AddAction M Î±] (n : â„•) (m : M) (a : Î±),
  (n + AddAction.period m a) â€¢ m +áµ¥ a = n â€¢ m +áµ¥ a
Result.success

Testing || imaginaryPart_comp_subtype_selfAdjoint : âˆ€ {A : Type u_1} [inst : AddCommGroup A] [inst_1 : Module â„‚ A] [inst_2 : StarAddMonoid A] [inst_3 : StarModule â„‚ A],
  imaginaryPart âˆ˜â‚— (selfAdjoint.submodule â„ A).subtype = 0
Result.autoException ::
Auto failed to find proof

Testing || List.erase_subperm : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (l : List Î±), (l.erase a).Subperm l
Result.success

Testing || Homeomorph.subtype_toEquiv : âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X â†’ Prop} {q : Y â†’ Prop}
  (h : X â‰ƒâ‚œ Y) (h_iff : âˆ€ (x : X), p x â†” q (h x)), (h.subtype h_iff).toEquiv = h.subtypeEquiv h_iff
Result.autoException ::
Auto failed to find proof

Testing || maximal_mem_iff : âˆ€ {Î± : Type u_1} {x : Î±} [inst : PartialOrder Î±] {s : Set Î±},
  Maximal (fun x => x âˆˆ s) x â†” x âˆˆ s âˆ§ âˆ€ â¦ƒy : Î±â¦„, y âˆˆ s â†’ x â‰¤ y â†’ x = y
Result.success

Testing || Subgroup.coe_inf : âˆ€ {G : Type u_1} [inst : Group G] (p p' : Subgroup G), â†‘(p âŠ“ p') = â†‘p âˆ© â†‘p'
Result.autoException ::
Auto failed to find proof

Testing || Set.singleton_smul_singleton : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SMul Î± Î²] {a : Î±} {b : Î²}, {a} â€¢ {b} = {a â€¢ b}
Result.autoException ::
Auto failed to find proof

Testing || Finset.map_subtype_embedding_Iio : âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (p : Î± â†’ Prop) [inst_1 : DecidablePred p] [inst_2 : LocallyFiniteOrderBot Î±]
  (a : Subtype p),
  (âˆ€ â¦ƒa x : Î±â¦„, x â‰¤ a â†’ p a â†’ p x) â†’ Finset.map (Function.Embedding.subtype p) (Finset.Iio a) = Finset.Iio â†‘a
Result.success

Testing || DFinsupp.eq_mk_support : âˆ€ {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [inst : DecidableEq Î¹] [inst_1 : (i : Î¹) â†’ Zero (Î² i)]
  [inst_2 : (i : Î¹) â†’ (x : Î² i) â†’ Decidable (x â‰  0)] (f : Î â‚€ (i : Î¹), Î² i), f = DFinsupp.mk f.support fun i => f â†‘i
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2 (cifvar_7 i)`.
This is because it contains free variables and has subterms possessing at least one of the following features
Â· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
Â· Î» binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
Â· (TODO)

Testing || NonUnitalAlgHom.restrictScalars_apply : âˆ€ (R : Type u_1) {S : Type u_2} {A : Type u_3} {B : Type u_4} [inst : Monoid R] [inst_1 : Monoid S]
  [inst_2 : NonUnitalNonAssocSemiring A] [inst_3 : NonUnitalNonAssocSemiring B] [inst_4 : MulAction R S]
  [inst_5 : DistribMulAction S A] [inst_6 : DistribMulAction S B] [inst_7 : DistribMulAction R A]
  [inst_8 : DistribMulAction R B] [inst_9 : IsScalarTower R S A] [inst_10 : IsScalarTower R S B] (f : A â†’â‚™â‚[S] B)
  (x : A), (NonUnitalAlgHom.restrictScalars R f) x = f x
Result.autoException ::
Auto failed to find proof

Testing || ZMod.cast_zmod_eq_zero_iff_of_le : âˆ€ {m n : â„•} [inst : NeZero m], m â‰¤ n â†’ âˆ€ (a : ZMod m), a.cast = 0 â†” a = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `ZMod.commRing x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
Â· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
Â· Î» binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
Â· (TODO)

Testing || Option.getD_some : âˆ€ {Î± : Type u_1} {a b : Î±}, (some a).getD b = a
Result.autoEbgroup G}, H.normalizer = âŠ¤ â†” H.Normal
Result.autoException ::
Auto failed to find proof

Testing || isClosedEmbedding_of_spaced_out : âˆ€ {Î² : Type v} [inst : UniformSpace Î²] {Î± : Type u_1} [inst_1 : TopologicalSpace Î±] [inst_2 : DiscreteTopology Î±]
  [inst_3 : T0Space Î²] {f : Î± â†’ Î²} {s : Set (Î² Ã— Î²)},
  s âˆˆ uniformity Î² â†’ (Pairwise fun x y => (f x, f y) âˆ‰ s) â†’ IsClosedEmbedding f
Result.autoException ::
Auto failed to find proof

Testing || Filter.Tendsto.div_const' : âˆ€ {G : Type w} {Î± : Type u} [inst : TopologicalSpace G] [inst_1 : Div G] [inst_2 : ContinuousDiv G] {c : G} {f : Î± â†’ G}
  {l : Filter Î±}, Filter.Tendsto f l (nhds c) â†’ âˆ€ (b : G), Filter.Tendsto (fun x => f x / b) l (nhds (c / b))
Result.success

Testing || eq_false_of_decide : âˆ€ {p : Prop} {x : Decidable p}, decide p = false â†’ p = False
Result.success

Testing || List.cons_diff_of_not_mem : âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] {a : Î±} {lâ‚‚ : List Î±},
  a âˆ‰ lâ‚‚ â†’ âˆ€ (lâ‚ : List Î±), (a :: lâ‚).diff lâ‚‚ = a :: lâ‚.diff lâ‚‚
Result.success

Testing || dif_eq_if : âˆ€ (c : Prop) {h : Decidable c} {Î± : Sort u} (t e : Î±), (if x : c then t else e) = if c then t else e
Result.autoException ::
Auto failed to find proof

Testing || Set.iInter_eq_if : âˆ€ {Î± : Type u_1} {p : Prop} [inst : Decidable p] (s : Set Î±), â‹‚ (_ : p), s = if p then s else Set.univ
Result.autoException ::
Auto failed to find proof

Testing || AddSubmonoid.add_subset_closure : âˆ€ {M : Type u_3} [inst : AddMonoid M] {s t u : Set M}, s âŠ† u â†’ t âŠ† u â†’ s + t âŠ† â†‘(AddSubmonoid.closure u)
Result.success

Testing || isAddUnit_iff_eq_zero : âˆ€ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Subsingleton (AddUnits M)] {x : M}, IsAddUnit x â†” x = 0
Result.autoException ::
Auto failed to find proof

Testing || OrderHom.ext : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] (f g : Î± â†’o Î²), â‡‘f = â‡‘g â†’ f = g
Result.autoException ::
Auto failed to find proof

Testing || Std.DHashMap.Internal.List.getValue?_congr : âˆ€ {Î± : Type u} {Î² : Type v} [inst : BEq Î±] [inst_1 : PartialEquivBEq Î±] {l : List ((_ : Î±) Ã— Î²)} {a b : Î±},
  (a == b) = true â†’ Std.DHashMap.Internal.List.getValue? a l = Std.DHashMap.Internal.List.getValue? b l
Result.success

Testing || Finset.erase_union_of_mem : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {t : Finset Î±} {a : Î±}, a âˆˆ t â†’ âˆ€ (s : Finset Î±), s.erase a âˆª t = s âˆª t
Result.success

Testing || Real.cos_add : âˆ€ (x y : â„), Real.cos (x + y) = Real.cos x * Real.cos y - Real.sin x * Real.sin y
Result.autoException ::
Auto failed to find proof

Testing || List.length_pos_of_sum_neg : âˆ€ {M : Type u_4} [inst : AddMonoid M] [inst_1 : Preorder M] (L : List M), L.sum < 0 â†’ 0 < L.length
Result.success

Testing || NoZeroSMulDivisors.algebraMap_eq_one_iff : âˆ€ (R : Type u_1) (A : Type u_2) [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Nontrivial A] [inst_3 : Algebra R A]
  [inst_4 : NoZeroSMulDivisors R A] {r : R}, (algebraMap R A) r = 1 â†” r = 1
Result.success

Testing || Fin.map_subtype_embedding_uIcc : âˆ€ {n : â„•} (a b : Fin n), Finset.map Fin.valEmbedding (Finset.uIcc a b) = Finset.uIcc â†‘a â†‘b
Result.autoException ::
Auto failed to find proof

Testing || Auto.HList.getD_heq : âˆ€ {Î±â‚ Î±â‚‚ : Type u_1} {Î²â‚ : Î±â‚ â†’ Sort u_2} {tyâ‚ : Î±â‚} {defaultâ‚ : Î²â‚ tyâ‚} {tysâ‚ : List Î±â‚} {hlâ‚ : Auto.HList Î²â‚ tysâ‚}
  {nâ‚ : â„•} {Î²â‚‚ : Î±â‚‚ â†’ Sort u_2} {tyâ‚‚ : Î±â‚‚} {defaultâ‚‚ : Î²â‚‚ tyâ‚‚} {tysâ‚‚ : List Î±â‚‚} {hlâ‚‚ : Auto.HList Î²â‚‚ tysâ‚‚} {nâ‚‚ : â„•},
  HEq Î²â‚ Î²â‚‚ â†’
    HEq tyâ‚ tyâ‚‚ â†’
      HEq defaultâ‚ defaultâ‚‚ â†’
        HEq tysâ‚ tysâ‚‚ â†’ HEq hlâ‚ hlâ‚‚ â†’ nâ‚ = nâ‚‚ â†’ HEq (Auto.HList.getD defaultâ‚ hlâ‚ nâ‚) (Auto.HList.getD defaultâ‚‚ hlâ‚‚ nâ‚‚)
Result.autoException ::
Auto failed to find proof

Testing || List.indexOf_inj : âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {l : List Î±} {x y : Î±},
  x âˆˆ l â†’ y âˆˆ l â†’ (List.indexOf x l = List.indexOf y l â†” x = y)
Result.autoException ::
Auto failed to find proof

Testing || AddSubgroup.addSubgroupOfEquivOfLe.proof_6 : âˆ€ {G : Type u_1} [inst : AddGroup G] {H K : AddSubgroup G} (h : H â‰¤ K) (_g _h : â†¥(H.addSubgroupOf K)),
  { toFun := fun g => âŸ¨â†‘â†‘g, â‹¯âŸ©, invFun := fun g => âŸ¨âŸ¨â†‘g, â‹¯âŸ©, â‹¯âŸ©, left_inv := â‹¯, right_inv := â‹¯ }.toFun (_g + _h) =
    { toFun := fun g => âŸ¨â†‘â†‘g, â‹¯âŸ©, invFun := fun g => âŸ¨âŸ¨â†‘g, â‹¯âŸ©, â‹¯âŸ©, left_inv := â‹¯, right_inv := â‹¯ }.toFun (_g + _h)
Result.success

Testing || Submodule.mul_smul_mul_eq_smul_mul_smul : âˆ€ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M N : Submodule R A)
  (x y : R), (x * y) â€¢ (M * N) = x â€¢ M * y â€¢ N
Result.autoException ::
Auto failed to find proof

Testing || lt_iff_exists_add : âˆ€ {Î± : Type u} [inst : CanonicallyOrderedAddCommMonoid Î±] {a b : Î±} [inst_1 : AddLeftStrictMono Î±],
  a < b â†” âˆƒ c > 0, b = a + c
Result.success

Testing || WithTop.untop_zero : âˆ€ {Î± : Type u} [inst : Zero Î±], WithTop.untop 0 â‹¯ = 0
Result.autoException ::
Auto failed to find proof

Testing || Finset.smul_sum : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : AddCommMonoid Î²] [inst_1 : DistribSMul Î± Î²] {r : Î±} {f : Î³ â†’ Î²}
  {s : Finset Î³}, r â€¢ âˆ‘ x âˆˆ s, f x = âˆ‘ x âˆˆ s, r â€¢ f x
Result.autoException ::
Auto failed to find proof

Testing || Std.DHashMap.Internal.List.getValue?_eraseKey_of_false : âˆ€ {Î± : Type u} {Î² : Type v} [inst : BEq Î±] [inst_1 : PartialEquivBEq Î±] {l : List ((_ : Î±) Ã— Î²)} {k a : Î±},
  (k == a) = false â†’
    Std.DHashMap.Internal.List.getValue? a (Std.DHashMap.Internal.List.eraseKey k l) =
      Std.DHashMap.Internal.List.getValue? a l
Result.success

Testing || UInt64.one_def : 1 = { val := 1 }
Result.autoException ::
Auto failed to find proof

Testing || AddOpposite.nndist_unop : âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (x y : Î±áµƒáµ’áµ–),
  nndist (AddOpposite.unop x) (AddOpposite.unop y) = nndist x y
Result.autoException ::
Auto failed to find proof

Testing || LowerSet.compl_sSup : âˆ€ {Î± : Type u_1} [inst : LE Î±] (S : Set (LowerSet Î±)), (sSup S).compl = â¨† s âˆˆ S, s.compl
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type s âˆˆ S of Î» binder contains bound variables

Testing || negPart_eq_neg_inf_zero : âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : AddGroup Î±] [inst_2 : AddLeftMono Î±] [inst_3 : AddRightMono Î±] (a : Î±),
  aâ» = -(a âŠ“ 0)
Result.success

Testing || AddMonoidHom.comp_sub : âˆ€ {M : Type u_2} {G : Type u_5} {H : Type u_6} [inst : AddZeroClass M] [inst_1 : AddCommGroup G]
  [inst_2 : AddCommGroup H] (f : G â†’+ H) (g h : M â†’+ G), f.comp (g - h) = f.comp g - f.comp h
Result.autoException ::
Auto failed to find proof

Testing || Std.Sat.AIG.Entrypoint.relabelNat_unsat_iff : âˆ€ {Î± : Type} [inst : DecidableEq Î±] [inst_1 : Hashable Î±] {entry : Std.Sat.AIG.Entrypoint Î±} [inst_2 : Nonempty Î±],
  entry.relabelNat.Unsat â†” entry.Unsat
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.ref`.
This is because it contains free variables and has subterms possessing at least one of the following features
Â· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
Â· Î» binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
Â· (TODO)

Testing || WithBot.add_lt_add_left : âˆ€ {Î± : Type u} [inst : Add Î±] {a b c : WithBot Î±} [inst_1 : Preorder Î±] [inst_2 : AddLeftStrictMono Î±],
  a â‰  âŠ¥ â†’ b < c â†’ a + b < a + c
Result.autoException ::
Auto failed to find proof

Testing || interior_univ : âˆ€ {X : Type u} [inst : TopologicalSpace X], interior Set.univ = Set.univ
Result.success

Testing || LinearMap.map_zero : âˆ€ {R : Type u_1} {S : Type u_5} {M : Type u_8} {Mâ‚ƒ : Type u_11} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚ƒ] [inst_4 : Module R M] [inst_5 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S}
  (f : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ), f 0 = 0
Result.success

Testing || AddSubgroup.map_map : âˆ€ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) {N : Type u_5} [inst_1 : AddGroup N] {P : Type u_6}
  [inst_2 : AddGroup P] (g : N â†’+ P) (f : G â†’+ N),
  AddSubgroup.map g (AddSubgroup.map f K) = AddSubgroup.map (g.comp f) K
Result.autoException ::
Auto failed to find proof

Testing || Filter.tendsto_const_sub_iff : âˆ€ {Î± : Type u} {G : Type u_1} [inst : AddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousSub G] (b : G)
  {c : G} {f : Î± â†’ G} {l : Filter Î±}, Filter.Tendsto (fun k => b - f k) l (nhds (b - c)) â†” Filter.Tendsto f l (nhds c)
Result.success

Testing || Homeomorph.piCongrRight_apply : âˆ€ {Î¹ : Type u_7} {Yâ‚ : Î¹ â†’ Type u_8} {Yâ‚‚ : Î¹ â†’ Type u_9} [inst : (i : Î¹) â†’ TopologicalSpace (Yâ‚ i)]
  [inst_1 : (i : Î¹) â†’ TopologicalSpace (Yâ‚‚ i)] (F : (i : Î¹) â†’ Yâ‚ i â‰ƒâ‚œ Yâ‚‚ i) (a : (i : Î¹) â†’ Yâ‚ i) (i : Î¹),
  (Homeomorph.piCongrRight F) a i = (F i) (a i)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || CanonicallyOrderedCommMonoid.le_self_mul : âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommMonoid Î±] (a b : Î±), a â‰¤ a * b
Result.autoException ::
Auto failed to find proof

Testing || iSup_iInf_le_iInf_iSup : âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Î¹' : Sort u_5} [inst : CompleteLattice Î±] (f : Î¹ â†’ Î¹' â†’ Î±),
  â¨† i, â¨… j, f i j â‰¤ â¨… j, â¨† i, f i j
Result.success

Testing || Filter.EventuallyLE.sup_le : âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeSup Î²] {l : Filter Î±} {f g h : Î± â†’ Î²},
  f â‰¤á¶ [l] h â†’ g â‰¤á¶ [l] h â†’ f âŠ” g â‰¤á¶ [l] h
Result.autoException ::
Auto failed to find proof

Testing || lowerBounds_Ioi : âˆ€ {Î³ : Type w} [inst : LinearOrder Î³] [inst_1 : DenselyOrdered Î³] {a : Î³}, lowerBounds (Set.Ioi a) = Set.Iic a
Result.success

Testing || NonUnitalSubring.coe_mk' : âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] {s : Set R} {sm : Subsemigroup R} (hm : â†‘sm = s) {sa : AddSubgroup R}
  (ha : â†‘sa = s), â†‘(NonUnitalSubring.mk' s sm sa hm ha) = s
Result.autoException ::
Auto failed to find proof

Testing || hasCompactMulSupport_def : âˆ€ {Î± : Type u_2} {Î² : Type u_4} [inst : TopologicalSpace Î±] [inst_1 : One Î²] {f : Î± â†’ Î²},
  HasCompactMulSupport f â†” IsCompact (closure (Function.mulSupport f))
Result.autoException ::
Auto failed to find proof

Testing || List.mem_diff_of_mem : âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] {a : Î±} {lâ‚ lâ‚‚ : List Î±}, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚ â†’ a âˆˆ lâ‚.diff lâ‚‚
Result.autoException ::
Auto failed to find proof

Testing || Order.Ioo_pred_left_of_not_isMin : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : PredOrder Î±] {a b : Î±},
  Â¬IsMin a â†’ Set.Ioo (Order.pred a) b = Set.Ico a b
Result.success

Testing || Subgroup.zpowers_one_eq_bot : âˆ€ {G : Type u_1} [inst : Group G], Subgroup.zpowers 1 = âŠ¥
Result.success

Testing || List.cyclicPermutations_inj : âˆ€ {Î± : Type u} {l l' : List Î±}, l.cyclicPermutations = l'.cyclicPermutations â†” l = l'
Result.success

Testing || OrderMonoidHom.coe_monoidHom : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : MulOneClass Î±]
  [inst_3 : MulOneClass Î²] (f : Î± â†’*o Î²), â‡‘â†‘f = â‡‘f
Result.autoException ::
Auto failed to find proof

Testing || Int.ModEq.add_right_cancel : âˆ€ {n a b c d : â„¤}, c â‰¡ d [ZMOD n] â†’ a + c â‰¡ b + d [ZMOD n] â†’ a â‰¡ b [ZMOD n]
Result.success

Testing || Char.isValidUInt32 : âˆ€ (n : â„•), Char.isValidCharNat n â†’ n < UInt32.size
Result.autoException ::
Auto failed to find proof

Testing || Finset.prod_le_prod_of_subset_of_one_le' : âˆ€ {Î¹ : Type u_1} {N : Type u_5} [inst : OrderedCommMonoid N] {f : Î¹ â†’ N} {s t : Finset Î¹},
  s âŠ† t â†’ (âˆ€ i âˆˆ t, i âˆ‰ s â†’ 1 â‰¤ f i) â†’ âˆ i âˆˆ s, f i â‰¤ âˆ i âˆˆ t, f i
Result.autoException ::
Auto failed to find proof

Testing || Set.Finite.pi : âˆ€ {Î¹ : Type u_1} [inst : Finite Î¹] {Îº : Î¹ â†’ Type u_2} {t : (i : Î¹) â†’ Set (Îº i)},
  (âˆ€ (i : Î
Auto failed to find proof

Testing || orderOf_inv : âˆ€ {G : Type u_1} [inst : Group G] (x : G), orderOf xâ»Â¹ = orderOf x
Result.success

Testing || Multiset.disjSum_lt_disjSum_of_le_of_lt : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {sâ‚ sâ‚‚ : Multiset Î±} {tâ‚ tâ‚‚ : Multiset Î²},
  sâ‚ â‰¤ sâ‚‚ â†’ tâ‚ < tâ‚‚ â†’ sâ‚.disjSum tâ‚ < sâ‚‚.disjSum tâ‚‚
Result.autoException ::
Auto failed to find proof

Testing || OrderMonoidHom.monotone' : âˆ€ {Î± : Type u_6} {Î² : Type u_7} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : MulOneClass Î±]
  [inst_3 : MulOneClass Î²] (self : Î± â†’*o Î²), Monotone (â†‘self.toMonoidHom).toFun
Result.autoException ::
Auto failed to find proof

Testing || LinearMap.applyâ‚—_apply_apply : âˆ€ {R : Type u_1} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid Mâ‚‚] [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] (v : M) (f : M â†’â‚—[R] Mâ‚‚),
  (LinearMap.applyâ‚— v) f = f v
Result.autoException ::
Auto failed to find proof

Testing || Filter.exists_antitone_seq : âˆ€ {Î± : Type u_1} (f : Filter Î±) [inst : f.IsCountablyGenerated], âˆƒ x, Antitone x âˆ§ âˆ€ {s : Set Î±}, s âˆˆ f â†” âˆƒ i, x i âŠ† s
Result.autoException ::
Auto failed to find proof

Testing || Nat.minFac_sq_le_self : âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ n.minFac ^ 2 â‰¤ n
Result.autoException ::
Auto failed to find proof

Testing || IsLocalExtr.elim : âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²} {a : Î±} {p : Prop},
  IsLocalExtr f a â†’ (IsLocalMin f a â†’ p) â†’ (IsLocalMax f a â†’ p) â†’ p
Result.autoException ::
Auto failed to find proof

Testing || List.head?_bind : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : List Î±} {f : Î± â†’ List Î²},
  (l.bind f).head? = List.findSome? (fun a => (f a).head?) l
Result.autoException ::
Auto failed to find proof

Testing || List.nodup_replicate : âˆ€ {Î± : Type u_1} {n : â„•} {a : Î±}, (List.replicate n a).Nodup â†” n â‰¤ 1
Result.autoException ::
Auto failed to find proof

Testing || Set.smul_univ : âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Group Î±] [inst_1 : MulAction Î± Î²] {s : Set Î±},
  s.Nonempty â†’ s â€¢ Set.univ = Set.univ
Result.autoException ::
Auto failed to find proof

Testing || RelEmbedding.isPreorder : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop},
  r â†ªr s â†’ âˆ€ [inst : IsPreorder Î² s], IsPreorder Î± r
Result.autoException ::
Auto failed to find proof

Testing || Set.empty_sub : âˆ€ {Î± : Type u_2} [inst : Sub Î±] {s : Set Î±}, âˆ… - s = âˆ…
Result.autoException ::
Auto failed to find proof

Testing || ENNReal.natCast_le_ofReal : âˆ€ {n : â„•} {p : â„}, n â‰  0 â†’ (â†‘n â‰¤ ENNReal.ofReal p â†” â†‘n â‰¤ p)
Result.success

Testing || Mathlib.Meta.Positivity.nz_of_isRat : âˆ€ {A : Type u_1} {e : A} {n : â„¤} {d : â„•} [inst : LinearOrderedRing A],
  Mathlib.Meta.NormNum.IsRat e n d â†’ decide (n < 0) = true â†’ e â‰  0
Result.autoException ::
Auto failed to find proof
_iff : âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y z : Î±}, IsCompl y z â†’ (Disjoint x y â†” x â‰¤ z)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Complex.abs_exp : âˆ€ (z : â„‚), Complex.abs (Complex.exp z) = Real.exp z.re
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Std.DHashMap.Internal.Rawâ‚€.getâ‚˜_eq_getValue : âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : BEq Î±] [inst_1 : Hashable Î±] [inst_2 : LawfulBEq Î±]
  {m : Std.DHashMap.Internal.Rawâ‚€ Î± Î²} (hm : Std.DHashMap.Internal.Raw.WFImp â†‘m) {a : Î±} {h : m.containsâ‚˜ a = true},
  m.getâ‚˜ a h = Std.DHashMap.Internal.List.getValueCast a (Std.DHashMap.Internal.toListModel (â†‘m).buckets) â‹¯
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ENat.recTopCoe_top : âˆ€ {C : â„•âˆ â†’ Sort u_2} (d : C âŠ¤) (f : (a : â„•) â†’ C â†‘a), ENat.recTopCoe d f âŠ¤ = d
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Fin.succ_mk : âˆ€ (n i : â„•) (h : i < n), âŸ¨i, hâŸ©.succ = âŸ¨i + 1, â‹¯âŸ©
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Matrix.conjTranspose_sub : âˆ€ {m : Type u_2} {n : Type u_3} {Î± : Type v} [inst : AddGroup Î±] [inst_1 : StarAddMonoid Î±] (M N : Matrix m n Î±),
  (M - N).conjTranspose = M.conjTranspose - N.conjTranspose
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LE.le.codisjoint_hnot_left : âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] {a b : Î±}, a â‰¤ b â†’ Codisjoint (ï¿¢a) b
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || iSup_nhds_le_uniformity : âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], â¨† x, nhds (x, x) â‰¤ uniformity Î±
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.pairwise_subtype_iff_pairwise_finset : âˆ€ {Î± : Type u_1} {s : Finset Î±} (r : Î± â†’ Î± â†’ Prop), Pairwise (r on fun x => â†‘x) â†” (â†‘s).Pairwise r
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || lift_nhds_left : âˆ€ {Î± : Type ua} {Î² : Type ub} [inst : UniformSpace Î±] {x : Î±} {g : Set Î± â†’ Filter Î²},
  Monotone g â†’ (nhds x).lift g = (uniformity Î±).lift fun s => g (UniformSpace.ball x s)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || op_smul_eq_mul : âˆ€ {Î± : Type u_3} [inst : Mul Î±] {a a' : Î±}, MulOpposite.op a â€¢ a' = a' * a
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.zero_width_append : âˆ€ {v : â„•} (x : BitVec 0) (y : BitVec v), x ++ y = BitVec.cast â‹¯ y
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || add_right_inj : âˆ€ {G : Type u_3} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b = a + c â†” b = c
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || antitone_of_succ_le : âˆ€ {Î± : Type u_3} {Î² : Type u_4} [inst : PartialOrder Î±] [inst_1 : Preorder Î²] [inst_2 : SuccOrder Î±]
  [inst_3 : IsSuccArchimedean Î±] {f : Î± â†’ Î²}, (âˆ€ (a : Î±), Â¬IsMax a â†’ f (Order.succ a) â‰¤ f a) â†’ Antitone f
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || CategoryTheory.ComposableArrows.ext‚ÇÉ : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {f g : CategoryTheory.ComposableArrows C 3}
  (h‚ÇÄ : f.obj' 0 ‚ãØ = g.obj' 0 ‚ãØ) (h‚ÇÅ : f.obj' 1 ‚ãØ = g.obj' 1 ‚ãØ) (h‚ÇÇ : f.obj' 2 ‚ãØ = g.obj' 2 ‚ãØ)
  (h‚ÇÉ : f.obj' 3 ‚ãØ = g.obj' 3 ‚ãØ),
  f.map' 0 1 ‚ãØ ‚ãØ =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÄ)
        (CategoryTheory.CategoryStruct.comp (g.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)) ‚Üí
    f.map' 1 2 ‚ãØ ‚ãØ =
        CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÅ)
          (CategoryTheory.CategoryStruct.comp (g.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)) ‚Üí
      f.map' 2 3 ‚ãØ ‚ãØ =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÇ)
            (CategoryTheory.CategoryStruct.comp (g.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)) ‚Üí
        f = g
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a => f.obj ‚ü®0, ‚ãØ‚ü© = g.obj ‚ü®0, ‚ãØ‚ü© is not type correct

Testing || OrderAddMonoidHom.monotone' : ‚àÄ {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (‚Üëself.toAddMonoidHom).toFun
Result.autoException ::
Auto failed to find proof

Testing || Matroid.Indep.restrict_eq_freeOn : ‚àÄ {Œ± : Type u_1} {M : Matroid Œ±} {I : Set Œ±}, M.Indep I ‚Üí M.restrict I = Matroid.freeOn I
Result.success

Testing || WithTop.coe_top_lt : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] {x : WithTop Œ±}, ‚Üë‚ä§ < x ‚Üî x = ‚ä§
Result.autoException ::
Auto failed to find proof

Testing || Rat.zero_add : ‚àÄ (a : ‚Ñö), 0 + a = a
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.den_nz`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || MeasureTheory.Measure.bind_zero_right' : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (m : MeasureTheory.Measure Œ±),
  (m.bind fun x => 0) = 0
Result.autoException ::
Auto failed to find proof

Testing || Dynamics.coverEntropyEntourage_univ : ‚àÄ {X : Type u_1} (T : X ‚Üí X) {F : Set X}, F.Nonempty ‚Üí Dynamics.coverEntropyEntourage T F Set.univ = 0
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.LaxMonoidalFunctor.mapMon_map_hom : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}
  [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] [inst_3 : CategoryTheory.MonoidalCategory D]
  (F : CategoryTheory.LaxMonoidalFunctor C D) {X Y : Mon_ C} (f : X ‚ü∂ Y), (F.mapMon.map f).hom = F.map f.hom
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.leftUnitor
  (cifvar_10 (cifvar_11 (cifvar_12 x_0)) x_1)`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Real.lt_sin : ‚àÄ {x : ‚Ñù}, x < 0 ‚Üí x < Real.sin x
Result.success

Testing || Prod.instSubtractionMonoid.proof_3 : ‚àÄ {G : Type u_1} {H : Type u_2} [inst : SubtractionMonoid G] [inst_1 : SubtractionMonoid H] (x x_1 : G √ó H),
  x + x_1 = 0 ‚Üí -x = x_1
Result.success

Testing || MeasureTheory.tendsto_integral_of_L1 : ‚àÄ {Œ± : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ‚Ñù G] {m : MeasurableSpace Œ±}
  {Œº : MeasureTheory.Measure Œ±} {Œπ : Type u_6} (f : Œ± ‚Üí G),
  MeasureTheory.Integrable f Œº ‚Üí
    ‚àÄ {F : Œπ ‚Üí Œ± ‚Üí G} {l : Filter Œπ},
      (‚àÄ·∂† (i : Œπ) in l, MeasureTheory.Integrable (F i) Œº) ‚Üí
        Filter.Tendsto (fun i => ‚à´‚Åª (x : Œ±), ‚Üë‚ÄñF i x - f x‚Äñ‚Çä ‚àÇŒº) l (nhds 0) ‚Üí
          Filter.Tendsto (fun i => ‚à´ (x : Œ±), F i x ‚àÇŒº) l (nhds (‚à´ (x : Œ±), f x ‚àÇŒº))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Classical.propDecidable
  (cifvar_0 x_1 x_0)`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || CategoryTheory.PreGaloisCategory.toAut_surjective_of_isPretransitive : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C] (F : CategoryTheory.Functor C FintypeCat) (G : Type u_1)
  [inst_1 : Group G] [inst_2 : (X : C) ‚Üí MulAction G ‚Üë(F.obj X)]
  [inst_3 : CategoryTheory.PreGaloisCategory.IsNaturalSMul F G] [inst_4 : CategoryTheory.GaloisCategory C]
  [inst_5 : CategoryTheory.PreGaloisCategory.FiberFunctor F] [inst_6 : TopologicalSpace G] [inst_7 : TopologicalGroup G]
  [inst_8 : CompactSpace G] [inst_9 : ‚àÄ (X : C), ContinuousSMul G ‚Üë(F.obj X)],
  (‚àÄ (X : C) [inst_10 : CategoryTheory.PreGaloisCategory.IsGalois X], MulAction.IsPretransitive G ‚Üë(F.obj X)) ‚Üí
    Function.Surjective ‚áë(CategoryTheory.PreGaloisCategory.toAut F G)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `inst‚úù‚Å∑ x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || AddSubgroup.addUnits_ofAddUnits_eq : ‚àÄ {M : Type u_1} [inst : AddMonoid M] (S : AddSubgroup (AddUnits M)), S.ofAddUnits.addUnits = S
Result.autoException ::
Auto failed to find proof

Testing || MvPolynomial.IsSymmetric.sub : ‚àÄ {œÉ : Type u_1} {R : Type u_3} [inst : CommRing R] {œÜ œà : MvPolynomial œÉ R},
  œÜ.IsSymmetric ‚Üí œà.IsSymmetric ‚Üí (œÜ - œà).IsSymmetric
Result.autoException ::
Auto failed to find proof

Testing || List.cons_head?_tail : ‚àÄ {Œ± : Type u} {l : List Œ±} {a : Œ±}, a ‚àà l.head? ‚Üí a :: l.tail = l
Result.autoException ::
Auto failed to find proof

Testing || Subring.center_toSubsemiring : ‚àÄ (R : Type u) [inst : Ring R], (Subring.center R).toSubsemiring = Subsemiring.center R
Result.autoException ::
Auto failed to find proof

Testing || FreeAddGroup.join_red_of_step : ‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)}, FreeAddGroup.Red.Step L‚ÇÅ L‚ÇÇ ‚Üí Relation.Join FreeAddGroup.Red L‚ÇÅ L‚ÇÇ
Result.autoException ::
Auto failed to find proof

Testing || Order.IsSuccLimit.succ_ne : ‚àÄ {Œ± : Type u_1} {a : Œ±} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : NoMaxOrder Œ±],
  Order.IsSuccLimit a ‚Üí ‚àÄ (b : Œ±), Order.succ b ‚â† a
Result.success

Testing || dite_pow : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Pow Œ± Œ≤] (p : Prop) [inst_1 : Decidable p] (a : p ‚Üí Œ±) (b : ¬¨p ‚Üí Œ±) (c : Œ≤),
  (if h : p then a h else b h) ^ c = if h : p then a h ^ c else b h ^ c
Result.autoException ::
Auto failed to find proof

Testing || Set.MapsTo.nonempty : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤}, Set.MapsTo f s t ‚Üí s.Nonempty ‚Üí t.Nonempty
Result.success

Testing || Finset.inter_insert_of_not_mem : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s‚ÇÅ s‚ÇÇ : Finset Œ±} {a : Œ±}, a ‚àâ s‚ÇÅ ‚Üí s‚ÇÅ ‚à© insert a s‚ÇÇ = s‚ÇÅ ‚à© s‚ÇÇ
Result.success

Testing || FirstOrder.Language.BoundedFormula.realize_liftAt_one_self : ‚àÄ {L : FirstOrder.Language} {M : Type w} [inst : L.Structure M] {Œ± : Type u'} {n : ‚Ñï} {œÜ : L.BoundedFormula Œ± n}
  {v : Œ± ‚Üí M} {xs : Fin (n + 1) ‚Üí M},
  (FirstOrder.Language.BoundedFormula.liftAt 1 n œÜ).Realize v xs ‚Üî œÜ.Realize v (xs ‚àò Fin.castSucc)
Result.autoException ::
Auto failed to find proof

Testing || Option.join_eq_some : ‚àÄ {Œ± : Type u_1} {a : Œ±} {x : Option (Option Œ±)}, x.join = some a ‚Üî x = some (some a)
Result.autoException ::
Auto failed to find proof

Testing || min_eq_iff : ‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, min a b = c ‚Üî a = c ‚àß a ‚â§ b ‚à® b = c ‚àß b ‚â§ a
Result.success

Testing || Auto.Embedding.Lam.LamTerm.maxEVarSucc_etaExpandWith : ‚àÄ {l : List Auto.Embedding.Lam.LamSort} {t : Auto.Embedding.Lam.LamTerm},
  (Auto.Embedding.Lam.LamTerm.etaExpandWith l t).maxEVarSucc = t.maxEVarSucc
Result.autoException ::
Auto failed to find proof

Testing || Nat.sInf_def : ‚àÄ {s : Set ‚Ñï} (h : s.Nonempty), sInf s = Nat.find h
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Meq.pullback_refine : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}
  [inst_1 : CategoryTheory.Category.{max v u, w} D] [inst_2 : CategoryTheory.ConcreteCategory D] {Y X : C}
  {P : CategoryTheory.Functor C·µí·µñ D} {S T : J.Cover X} (h : S ‚ü∂ T) (f : Y ‚ü∂ X) (x : CategoryTheory.Meq P T),
  (x.pullback f).refine ((J.pullback f).map h) = (x.refine h).pullback f
Result.autoException ::
Auto failed to find proof

Testing || OrderHom.gfp_le : ‚àÄ {Œ± : Type u} [inst : CompleteLattice Œ±] (f : Œ± ‚Üío Œ±) {a : Œ±}, (‚àÄ b ‚â§ f b, b ‚â§ a) ‚Üí OrderHom.gfp f ‚â§ a
Result.autoException ::
Auto failed to find proof

Testing || Sum.elim_mul_mul : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (a a' : Œ± ‚Üí Œ≥) (b b' : Œ≤ ‚Üí Œ≥) [inst : Mul Œ≥],
  Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'
Result.autoException ::
Auto failed to find proof

Testing || LinearMap.BilinForm.nondegenerate_congr_iff : ‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {M' : Type u_9}
  [inst_3 : AddCommMonoid M'] [inst_4 : Module R M'] {B : LinearMap.BilinForm R M} (e : M ‚âÉ‚Çó[R] M'),
  ((LinearMap.BilinForm.congr e) B).Nondegenerate ‚Üî B.Nondegenerate
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.punitExt_inv_app_down_down : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C]
  (F G : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{w + 1})) (X : C), ‚ãØ = ‚ãØ
Result.autoException ::
Auto failed to find proof

Testing || List.isSuffix_iff : ‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±},
  l‚ÇÅ <:+ l‚ÇÇ ‚Üî l‚ÇÅ.length ‚â§ l‚ÇÇ.length ‚àß ‚àÄ (i : ‚Ñï) (h : i < l‚ÇÅ.length), l‚ÇÇ[i + l‚ÇÇ.length - l‚ÇÅ.length]? = some l‚ÇÅ[i]
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_3[i‚úù]`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || SubMulAction.coe_copy : ‚àÄ {R : Type u} {M : Type v} [inst : SMul R M] (p : SubMulAction R M) (s : Set M) (hs : s = ‚Üëp), ‚Üë(p.copy s hs) = s
Result.autoException ::
Auto failed to find proof

Testing || UInt8.toNat_mul : ‚àÄ (x y : UInt8), (x * y).toNat = x.toNat * y.toNat % UInt8.size
Result.autoException ::
Auto failed to find proof

Testing || StieltjesFunction.const_apply : ‚àÄ (c x : ‚Ñù), ‚Üë(StieltjesFunction.const c) x = c
Result.autoException ::
Auto failed to find proof

Testing || HomologicalComplex.homologyFunctor_map : ‚àÄ (C : Type u_1) [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {Œπ : Type u_2} (c : ComplexShape Œπ) (i : Œπ) [inst_2 : CategoryTheory.CategoryWithHomology C]
  {X Y : HomologicalComplex C c} (f : X ‚ü∂ Y),
  (HomologicalComplex.homologyFunctor C c i).map f = HomologicalComplex.homologyMap f i
Result.autoException ::
Auto failed to find proof

Testing || Multiset.count_union : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±) (s t : Multiset Œ±),
  Multiset.count a (s ‚à™ t) = max (Multiset.count a s) (Multiset.count a t)
Result.autoException ::
Auto failed to find proof

Testing || Commute.ofNat_left : ‚àÄ {Œ± : Type u_1} [inst : NonAssocSemiring Œ±] (n : ‚Ñï) [inst_1 : n.AtLeastTwo] (x : Œ±), Commute (OfNat.ofNat n) x
Result.autoException ::
Auto failed to find proof

Testing || Std.Sat.AIG.toCNF_equisat : ‚àÄ (entry : Std.Sat.AIG.Entrypoint ‚Ñï), (Std.Sat.AIG.toCNF entry).Unsat ‚Üî entry.Unsat
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.ref`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Finsupp.lapply_comp_lsingle_same : ‚àÄ {Œ± : Type u_1} {M : Type u_2} {R : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  (a : Œ±), Finsupp.lapply a ‚àò‚Çó Finsupp.lsingle a = LinearMap.id
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.MonoidalCategory.leftUnitor_whiskerRight_assoc : ‚àÄ {C : Type u} [ùíû : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (X Y : C) {Z : C}
  (h : CategoryTheory.MonoidalCategory.tensorObj X Y ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp
      (CategoryTheory.MonoidalCategory.whiskerRight (CategoryTheory.MonoidalCategory.leftUnitor X).hom Y) h =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator (ùüô_ C) X Y).hom
      (CategoryTheory.CategoryStruct.comp
        (CategoryTheory.MonoidalCategory.leftUnitor (CategoryTheory.MonoidalCategory.tensorObj X Y)).hom h)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.associator
  x_0 cifvar_17 x_1`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || IsLocalization.mem_localizationLocalizationSubmodule : ‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]
  [inst_2 : Algebra R S] {N : Submonoid S} {x : R},
  x ‚àà IsLocalization.localizationLocalizationSubmodule M N ‚Üî ‚àÉ y z, (algebraMap R S) x = ‚Üëy * (algebraMap R S) ‚Üëz
Result.autoException ::
Auto failed to find proof

Testing || MulAction.isPeriodicPt_smul_iff : ‚àÄ {Œ± : Type v} {M : Type u} [inst : Monoid M] [inst_1 : MulAction M Œ±] {m : M} {a : Œ±} {n : ‚Ñï},
  Function.IsPeriodicPt (fun x => m ‚Ä¢ x) n a ‚Üî m ^ n ‚Ä¢ a = a
Result.success

Testing || IsometryEquiv.piCongrLeft'_invFun : ‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} [inst : Fintype Œπ] [inst_1 : Fintype Œπ'] {Y : Œπ ‚Üí Type u_3}
  [inst_2 : (j : Œπ) ‚Üí PseudoEMetricSpace (Y j)] (e : Œπ ‚âÉ Œπ') (f : (b : Œπ') ‚Üí Y (e.symm b)) (x : Œπ),
  (IsometryEquiv.piCongrLeft' e).invFun f x = ‚ãØ ‚ñ∏ f (e x)
Result.autoException ::
Auto failed to find proof

Testing || Monoid.subset_closure : ‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M}, s ‚äÜ Monoid.Closure s
Result.autoException ::
Auto failed to find proof

Testing || Set.Iic_diff_Iio : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, Set.Iic b \ Set.Iio a = Set.Icc a b
Result.success

Testing || Finset.insert_inj : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {a b : Œ±}, a ‚àâ s ‚Üí (insert a s = insert b s ‚Üî a = b)
Result.success

Testing || inf_covBy_of_covBy_sup_of_covBy_sup_right : ‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsWeakLowerModularLattice Œ±] {a b : Œ±}, a ‚ãñ a ‚äî b ‚Üí b ‚ãñ a ‚äî b ‚Üí a ‚äì b ‚ãñ b
Result.success

Testing || Interval.bot_div : ‚àÄ {Œ± : Type u_2} [inst : Preorder Œ±] [inst_1 : CommGroup Œ±] [inst_2 : MulLeftMono Œ±] (t : Interval Œ±), ‚ä• / t = ‚ä•
Result.autoException ::
Auto failed to find proof

Testing || Ordinal.principal_add_opow_of_principal_add : ‚àÄ {a : Ordinal.{u_1}},
  Ordinal.Principal (fun x1 x2 => x1 + x2) a ‚Üí ‚àÄ (b : Ordinal.{u_1}), Ordinal.Principal (fun x1 x2 => x1 + x2) (a ^ b)
Result.autoException ::
Auto failed to find proof

Testing || LieModuleHom.map_lie‚ÇÇ : ‚àÄ {R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} {P : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : LieRing L]
  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : AddCommGroup P] [inst_5 : Module R M]
  [inst_6 : Module R N] [inst_7 : Module R P] [inst_8 : LieRingModule L M] [inst_9 : LieRingModule L N]
  [inst_10 : LieRingModule L P] [inst_11 : LieAlgebra R L] [inst_12 : LieModule R L N] [inst_13 : LieModule R L P]
  (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N ‚Üí‚Çó[R] P) (x : L) (m : M) (n : N), ‚ÅÖx, (f m) n‚ÅÜ = (f ‚ÅÖx, m‚ÅÜ) n + (f m) ‚ÅÖx, n‚ÅÜ
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral : ‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f g : Œ± ‚Üí ENNReal},
  f ‚â§·µê[Œº] g ‚Üí AEMeasurable g Œº ‚Üí ‚àÄ (Œµ : ENNReal), ‚à´‚Åª (a : Œ±), f a ‚àÇŒº + Œµ * Œº {x | f x + Œµ ‚â§ g x} ‚â§ ‚à´‚Åª (a : Œ±), g a ‚àÇŒº
Result.autoException ::
Auto failed to find proof

Testing || isProperMap_iff_isClosedMap_and_compact_fibers : ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X ‚Üí Y},
  IsProperMap f ‚Üî Continuous f ‚àß IsClosedMap f ‚àß ‚àÄ (y : Y), IsCompact (f ‚Åª¬π' {y})
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.HomOrthogonal.eq_zero : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {Œπ : Type u_1} {s : Œπ ‚Üí C}
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C],
  CategoryTheory.HomOrthogonal s ‚Üí ‚àÄ {i j : Œπ}, i ‚â† j ‚Üí ‚àÄ (f : s i ‚ü∂ s j), f = 0
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.CommShift.ofIso_compatibility : ‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_5, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_6, u_2} D] {F G : CategoryTheory.Functor C D} (e : F ‚âÖ G) (A : Type u_4)
  [inst_2 : AddMonoid A] [inst_3 : CategoryTheory.HasShift C A] [inst_4 : CategoryTheory.HasShift D A]
  [inst_5 : F.CommShift A], CategoryTheory.NatTrans.CommShift e.hom A
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.CategoryStruct.id
  x_1`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || MvPolynomial.bind‚ÇÅ_monomial : ‚àÄ {œÉ : Type u_1} {œÑ : Type u_2} {R : Type u_3} [inst : CommSemiring R] (f : œÉ ‚Üí MvPolynomial œÑ R) (d : œÉ ‚Üí‚ÇÄ ‚Ñï) (r : R),
  (MvPolynomial.bind‚ÇÅ f) ((MvPolynomial.monomial d) r) = MvPolynomial.C r * ‚àè i ‚àà d.support, f i ^ d i
Result.autoException ::
Auto failed to find proof

Testing || Trunc.finChoice_eq : ‚àÄ {Œπ : Type u_1} [inst : DecidableEq Œπ] [inst_1 : Fintype Œπ] {Œ± : Œπ ‚Üí Type u_2} (f : (i : Œπ) ‚Üí Œ± i),
  (Trunc.finChoice fun i => Trunc.mk (f i)) = Trunc.mk f
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `f i`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Real.sqrt_lt : ‚àÄ {x y : ‚Ñù}, 0 ‚â§ x ‚Üí 0 ‚â§ y ‚Üí (‚àöx < y ‚Üî x < y ^ 2)
Result.success

Testing || WithBot.coe_addHom : ‚àÄ {Œ± : Type u} [inst : AddMonoid Œ±], ‚áëWithBot.addHom = WithBot.some
Result.autoException ::
Auto failed to find proof

Testing || MemHolder.nnHolderNorm_add_le : ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : NormedAddCommGroup Y] {r : NNReal} {f g : X ‚Üí Y},
  MemHolder r f ‚Üí MemHolder r g ‚Üí nnHolderNorm r (f + g) ‚â§ nnHolderNorm r f + nnHolderNorm r g
Result.success

Testing || tsum_mul_tsum_eq_tsum_sum_antidiagonal : ‚àÄ {Œ± : Type u_4} {A : Type u_5} [inst : AddCommMonoid A] [inst_1 : Finset.HasAntidiagonal A]
  [inst_2 : TopologicalSpace Œ±] [inst_3 : NonUnitalNonAssocSemiring Œ±] {f g : A ‚Üí Œ±} [inst_4 : T3Space Œ±]
  [inst_5 : TopologicalSemiring Œ±],
  Summable f ‚Üí
    Summable g ‚Üí
      (Summable fun x => f x.1 * g x.2) ‚Üí
        (‚àë' (n : A), f n) * ‚àë' (n : A), g n = ‚àë' (n : A), ‚àë kl ‚àà Finset.antidiagonal n, f kl.1 * g kl.2
Result.autoException ::
Auto failed to find proof

Testing || ProbabilityTheory.Kernel.iIndepFun.indepFun_finset_sum_of_not_mem : ‚àÄ {Œ± : Type u_1} {Œ© : Type u_2} {Œπ : Type u_3} {_mŒ± : MeasurableSpace Œ±} {_mŒ© : MeasurableSpace Œ©}
  {Œ∫ : ProbabilityTheory.Kernel Œ± Œ©} {Œº : MeasureTheory.Measure Œ±} {Œ≤ : Type u_8} {m : MeasurableSpace Œ≤}
  [inst : AddCommMonoid Œ≤] [inst_1 : MeasurableAdd‚ÇÇ Œ≤] {f : Œπ ‚Üí Œ© ‚Üí Œ≤},
  ProbabilityTheory.Kernel.iIndepFun (fun x => m) f Œ∫ Œº ‚Üí
    (‚àÄ (i : Œπ), Measurable (f i)) ‚Üí
      ‚àÄ {s : Finset Œπ} {i : Œπ}, i ‚àâ s ‚Üí ProbabilityTheory.Kernel.IndepFun (‚àë j ‚àà s, f j) (f i) Œ∫ Œº
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.Subtype.fintype x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || smooth_mul_left : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] {I : ModelWithCorners ùïú E H} {G : Type u_4}
  [inst_4 : Mul G] [inst_5 : TopologicalSpace G] [inst_6 : ChartedSpace H G] [inst_7 : SmoothMul I G] {a : G},
  Smooth I I fun b => a * b
Result.autoException ::
Auto failed to find proof

Testing || CompHausLike.precoherent : ‚àÄ {P : TopCat ‚Üí Prop} [inst : CompHausLike.HasExplicitPullbacks P] [inst : CompHausLike.HasExplicitFiniteCoproducts P],
  (‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : X ‚ü∂ Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf) ‚Üí
    CategoryTheory.Precoherent (CompHausLike P)
Result.autoException ::
Auto failed to find proof

Testing || smul_ne_zero_iff_ne : ‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_6} [inst : Group Œ±] [inst_1 : AddMonoid Œ≤] [inst_2 : DistribMulAction Œ± Œ≤] (a : Œ±) {x : Œ≤},
  a ‚Ä¢ x ‚â† 0 ‚Üî x ‚â† 0
Result.success

Testing || Basis.flag_succ : ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : ‚Ñï}
  (b : Basis (Fin n) R M) (k : Fin n), b.flag k.succ = Submodule.span R {b k} ‚äî b.flag k.castSucc
Result.autoException ::
Auto failed to find proof

Testing || Nat.cast_pow : ‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] (m n : ‚Ñï), ‚Üë(m ^ n) = ‚Üëm ^ n
Result.autoException ::
Auto failed to find proof

Testing || IsRegular.subsingleton : ‚àÄ {R : Type u_1} [inst : MulZeroClass R], IsRegular 0 ‚Üí Subsingleton R
Result.success

Testing || HasSum.int_rec : ‚àÄ {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : TopologicalSpace M] {m m' : M} [inst_2 : ContinuousAdd M]
  {f g : ‚Ñï ‚Üí M}, HasSum f m ‚Üí HasSum g m' ‚Üí HasSum (fun t => Int.rec f g t) (m + m')
Result.autoException ::
Auto failed to find proof

Testing || Polynomial.degree_cyclotomic : ‚àÄ (n : ‚Ñï) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], (Polynomial.cyclotomic n R).degree = ‚Üën.totient
Result.autoException ::
Auto failed to find proof

Testing || LocallyBoundedVariationOn.exists_monotoneOn_sub_monotoneOn : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : Œ± ‚Üí ‚Ñù} {s : Set Œ±},
  LocallyBoundedVariationOn f s ‚Üí ‚àÉ p q, MonotoneOn p s ‚àß MonotoneOn q s ‚àß f = p - q
Result.autoException ::
Auto failed to find proof

Testing || TopCat.Presheaf.stalkFunctor_map_germ_apply : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasColimits C] {X : TopCat}
  [inst_2 : CategoryTheory.ConcreteCategory C] {F G : TopCat.Presheaf C X} (U : TopologicalSpace.Opens ‚ÜëX) (x : ‚ÜëX)
  (hx : x ‚àà U) (f : F ‚ü∂ G) (s : (CategoryTheory.forget C).obj (F.obj (Opposite.op U))),
  ((TopCat.Presheaf.stalkFunctor C x).map f) ((F.germ U x hx) s) = (G.germ U x hx) ((f.app (Opposite.op U)) s)
Result.autoException ::
Auto failed to find proof

Testing || ENNReal.inv_three_add_inv_three : 3‚Åª¬π + 3‚Åª¬π + 3‚Åª¬π = 1
Result.autoException ::
Auto failed to find proof

Testing || connectedComponents_preimage_image : ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (U : Set Œ±),
  ConnectedComponents.mk ‚Åª¬π' (ConnectedComponents.mk '' U) = ‚ãÉ x ‚àà U, connectedComponent x
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ‚àà U of Œª binder contains bound variables

Testing || differentiable_add_const_iff : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}
  (c : F), (Differentiable ùïú fun y => f y + c) ‚Üî Differentiable ùïú f
Result.success

Testing || Filter.Tendsto.isBoundedUnder_le : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : BoundedLENhdsClass Œ±]
  {f : Filter Œπ} {u : Œπ ‚Üí Œ±} {a : Œ±}, Filter.Tendsto u f (nhds a) ‚Üí Filter.IsBoundedUnder (fun x1 x2 => x1 ‚â§ x2) f u
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.Measure.ae_pi_le_pi : ‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí MeasurableSpace (Œ± i)]
  {Œº : (i : Œπ) ‚Üí MeasureTheory.Measure (Œ± i)} [inst_2 : ‚àÄ (i : Œπ), MeasureTheory.SigmaFinite (Œº i)],
  MeasureTheory.ae (MeasureTheory.Measure.pi Œº) ‚â§ Filter.pi fun i => MeasureTheory.ae (Œº i)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `inst‚úù¬π x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || RatFunc.coe_div : ‚àÄ {F : Type u} [inst : Field F] (f g : RatFunc F), ‚Üë(f / g) = ‚Üëf / ‚Üëg
Result.autoException ::
Auto failed to find proof

Testing || Lagrange.nodal_eq_mul_nodal_erase : ‚àÄ {R : Type u_1} [inst : CommRing R] {Œπ : Type u_2} {s : Finset Œπ} {v : Œπ ‚Üí R} [inst_1 : DecidableEq Œπ] {i : Œπ},
  i ‚àà s ‚Üí Lagrange.nodal s v = (Polynomial.X - Polynomial.C (v i)) * Lagrange.nodal (s.erase i) v
Result.autoException ::
Auto failed to find proof

Testing || HomologicalComplex.mapBifunctor‚ÇÅ‚ÇÇ.Œπ_D‚ÇÉ : ‚àÄ {C‚ÇÅ : Type u_1} {C‚ÇÇ : Type u_2} {C‚ÇÅ‚ÇÇ : Type u_3} {C‚ÇÉ : Type u_5} {C‚ÇÑ : Type u_6}
  [inst : CategoryTheory.Category.{u_17, u_1} C‚ÇÅ] [inst_1 : CategoryTheory.Category.{u_16, u_2} C‚ÇÇ]
  [inst_2 : CategoryTheory.Category.{u_14, u_5} C‚ÇÉ] [inst_3 : CategoryTheory.Category.{u_13, u_6} C‚ÇÑ]
  [inst_4 : CategoryTheory.Category.{u_15, u_3} C‚ÇÅ‚ÇÇ] [inst_5 : CategoryTheory.Limits.HasZeroMorphisms C‚ÇÅ]
  [inst_6 : CategoryTheory.Limits.HasZeroMorphisms C‚ÇÇ] [inst_7 : CategoryTheory.Limits.HasZeroMorphisms C‚ÇÉ]
  [inst_8 : CategoryTheory.Preadditive C‚ÇÅ‚ÇÇ] [inst_9 : CategoryTheory.Preadditive C‚ÇÑ]
  (F‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ))
  (G : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)) [inst_10 : F‚ÇÅ‚ÇÇ.PreservesZeroMorphisms]
  [inst_11 : ‚àÄ (X‚ÇÅ : C‚ÇÅ), (F‚ÇÅ‚ÇÇ.obj X‚ÇÅ).PreservesZeroMorphisms] [inst_12 : G.Additive]
  [inst_13 : ‚àÄ (X‚ÇÅ‚ÇÇ : C‚ÇÅ‚ÇÇ), (G.obj X‚ÇÅ‚ÇÇ).PreservesZeroMorphisms] {Œπ‚ÇÅ : Type u_7} {Œπ‚ÇÇ : Type u_8} {Œπ‚ÇÉ : Type u_9}
  {Œπ‚ÇÅ‚ÇÇ : Type u_10} {Œπ‚ÇÑ : Type u_12} [inst_14 : DecidableEq Œπ‚ÇÅ‚ÇÇ] [inst_15 : DecidableEq Œπ‚ÇÑ] {c‚ÇÅ : ComplexShape Œπ‚ÇÅ}
  {c‚ÇÇ : ComplexShape Œπ‚ÇÇ} {c‚ÇÉ : ComplexShape Œπ‚ÇÉ} (K‚ÇÅ : HomologicalComplex C‚ÇÅ c‚ÇÅ) (K‚ÇÇ : HomologicalComplex C‚ÇÇ c‚ÇÇ)
  (K‚ÇÉ : HomologicalComplex C‚ÇÉ c‚ÇÉ) (c‚ÇÅ‚ÇÇ : ComplexShape Œπ‚ÇÅ‚ÇÇ) (c‚ÇÑ : ComplexShape Œπ‚ÇÑ)
  [inst_16 : TotalComplexShape c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ] [inst_17 : TotalComplexShape c‚ÇÅ‚ÇÇ c‚ÇÉ c‚ÇÑ]
  [inst_18 : K‚ÇÅ.HasMapBifunctor K‚ÇÇ F‚ÇÅ‚ÇÇ c‚ÇÅ‚ÇÇ] [inst_19 : (K‚ÇÅ.mapBifunctor K‚ÇÇ F‚ÇÅ‚ÇÇ c‚ÇÅ‚ÇÇ).HasMapBifunctor K‚ÇÉ G c‚ÇÑ] (i‚ÇÅ : Œπ‚ÇÅ)
  (i‚ÇÇ : Œπ‚ÇÇ) (i‚ÇÉ : Œπ‚ÇÉ) (j j' : Œπ‚ÇÑ) (h : c‚ÇÅ.r c‚ÇÇ c‚ÇÉ c‚ÇÅ‚ÇÇ c‚ÇÑ (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j),
  CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctor‚ÇÅ‚ÇÇ.Œπ F‚ÇÅ‚ÇÇ G K‚ÇÅ K‚ÇÇ K‚ÇÉ c‚ÇÅ‚ÇÇ c‚ÇÑ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h)
      (HomologicalComplex.mapBifunctor‚ÇÅ‚ÇÇ.D‚ÇÉ F‚ÇÅ‚ÇÇ G K‚ÇÅ K‚ÇÇ K‚ÇÉ c‚ÇÅ‚ÇÇ c‚ÇÑ j j') =
    HomologicalComplex.mapBifunctor‚ÇÅ‚ÇÇ.d‚ÇÉ F‚ÇÅ‚ÇÇ G K‚ÇÅ K‚ÇÇ K‚ÇÉ c‚ÇÅ‚ÇÇ c‚ÇÑ i‚ÇÅ i‚ÇÇ i‚ÇÉ j'
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.GradedObject (Œπ‚ÇÅ √ó Œπ‚ÇÇ) C‚ÇÅ‚ÇÇ is not a `‚àÄ`

Testing || CategoryTheory.evalEquiv_symm_apply : ‚àÄ (S : CategoryTheory.Functor Type u·µí·µñ (Type u))
  (hs : CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology S) (Œ± : Type u)
  (f : Œ± ‚Üí S.obj (Opposite.op PUnit.{u + 1})),
  (CategoryTheory.evalEquiv S hs Œ±).symm f = CategoryTheory.typesGlue S hs Œ± f
Result.autoException ::
Auto failed to find proof

Testing || Metric.mem_thickening_iff_exists_edist_lt : ‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} (E : Set Œ±) (x : Œ±),
  x ‚àà Metric.thickening Œ¥ E ‚Üî ‚àÉ z ‚àà E, edist x z < ENNReal.ofReal Œ¥
Result.autoException ::
Auto failed to find proof

Testing || List.get_take' : ‚àÄ {Œ± : Type u_1} (L : List Œ±) {j : ‚Ñï} {i : Fin (List.take j L).length}, (List.take j L).get i = L.get ‚ü®‚Üëi, ‚ãØ‚ü©
Result.autoException ::
Auto failed to find proof

Testing || FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_b_of_dvd_a_add_eta_mul_b : ‚àÄ {K : Type u_1} [inst : Field K] {Œ∂ : K} {hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3} (S : FermatLastTheoremForThreeGen.Solution hŒ∂)
  [inst_1 : NumberField K] [inst_2 : IsCyclotomicExtension {3} ‚Ñö K] {p : NumberField.RingOfIntegers K},
  Prime p ‚Üí p ‚à£ S.a + S.b ‚Üí p ‚à£ S.a + ‚Üë‚ãØ.unit * S.b ‚Üí Associated p (hŒ∂.toInteger - 1)
Result.autoException ::
Auto failed to find proof

Testing || Set.bounded_le_Ioc : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a b : Œ±), Set.Bounded (fun x1 x2 => x1 ‚â§ x2) (Set.Ioc a b)
Result.success

Testing || ciInf_sub : ‚àÄ {Œπ : Type u_1} {G : Type u_2} [inst : AddGroup G] [inst_1 : ConditionallyCompleteLattice G] [inst_2 : Nonempty Œπ]
  {f : Œπ ‚Üí G} [inst_3 : AddRightMono G], BddBelow (Set.range f) ‚Üí ‚àÄ (a : G), (‚®Ö i, f i) - a = ‚®Ö i, f i - a
Result.success

Testing || Matrix.trace_transpose : ‚àÄ {n : Type u_3} {R : Type u_6} [inst : Fintype n] [inst_1 : AddCommMonoid R] (A : Matrix n n R),
  A.transpose.trace = A.trace
Result.autoException ::
Auto failed to find proof

Testing || EReal.inv_nonneg_of_nonneg : ‚àÄ {a : EReal}, 0 ‚â§ a ‚Üí 0 ‚â§ a‚Åª¬π
Result.autoException ::
Auto failed to find proof

Testing || symmDiff_le : ‚àÄ {Œ± : Type u_2} [inst : GeneralizedCoheytingAlgebra Œ±] {a b c : Œ±}, a ‚â§ b ‚äî c ‚Üí b ‚â§ a ‚äî c ‚Üí symmDiff a b ‚â§ c
Result.autoException ::
Auto failed to find proof

Testing || InnerProductSpace.volume_closedBall : ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] [inst_5 : Nontrivial E] (x : E) (r : ‚Ñù),
  MeasureTheory.volume (Metric.closedBall x r) =
    ENNReal.ofReal r ^ Module.finrank ‚Ñù E *
      ENNReal.ofReal (‚àöReal.pi ^ Module.finrank ‚Ñù E / Real.Gamma (‚Üë(Module.finrank ‚Ñù E) / 2 + 1))
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.card_edgeFinset_sup_edge : ‚àÄ {V : Type u_1} (G : SimpleGraph V) {s t : V} [inst : Fintype V] [inst_1 : DecidableRel G.Adj]
  [inst_2 : Fintype ‚Üë(G ‚äî SimpleGraph.edge s t).edgeSet],
  ¬¨G.Adj s t ‚Üí s ‚â† t ‚Üí (G ‚äî SimpleGraph.edge s t).edgeFinset.card = G.edgeFinset.card + 1
Result.autoException ::
Auto failed to find proof

Testing || OrderedSemiring.zero_le_one : ‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±], 0 ‚â§ 1
Result.autoException ::
Auto failed to find proof

Testing || List.mem_pure : ‚àÄ {Œ± : Type u} (x y : Œ±), x ‚àà pure y ‚Üî x = y
Result.autoException ::
Auto failed to find proof

Testing || LinearMap.range_mkQ_comp : ‚àÄ {R : Type u_1} {M : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}
  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ), (LinearMap.range f).mkQ.comp f = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Submodule.Quotient.mk x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || List.foldr_ext : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f g : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (b : Œ≤) {l : List Œ±},
  (‚àÄ a ‚àà l, ‚àÄ (b : Œ≤), f a b = g a b) ‚Üí List.foldr f b l = List.foldr g b l
Result.autoException ::
Auto failed to find proof

Testing || Nat.div_le_of_le_mul' : ‚àÄ {m n k : ‚Ñï}, m ‚â§ k * n ‚Üí m / k ‚â§ n
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.Final.colimitCoconeOfComp_cocone : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]
  (F : CategoryTheory.Functor C D) [inst_2 : F.Final] {E : Type u‚ÇÉ} [inst_3 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E]
  {G : CategoryTheory.Functor D E} (t : CategoryTheory.Limits.ColimitCocone (F.comp G)),
  (CategoryTheory.Functor.Final.colimitCoconeOfComp F t).cocone = CategoryTheory.Functor.Final.extendCocone.obj t.cocone
Result.autoException ::
Auto failed to find proof

Testing || Pi.addAction.proof_2 : ‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (M : Type u_3) {m : AddMonoid M} [inst : (i : Œπ) ‚Üí AddAction M (Œ± i)] (x x_1 : M)
  (x_2 : (i : Œπ) ‚Üí Œ± i), x + x_1 +·µ• x_2 = x +·µ• (x_1 +·µ• x_2)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `inst‚úù i`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Multiset.powerset_aux'_perm : ‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ.Perm l‚ÇÇ ‚Üí (Multiset.powersetAux' l‚ÇÅ).Perm (Multiset.powersetAux' l‚ÇÇ)
Result.autoException ::
Auto failed to find proof

Testing || smul_mul' : ‚àÄ {M : Type u_1} {A : Type u_3} [inst : Monoid M] [inst_1 : Monoid A] [inst_2 : MulDistribMulAction M A] (a : M)
  (b‚ÇÅ b‚ÇÇ : A), a ‚Ä¢ (b‚ÇÅ * b‚ÇÇ) = a ‚Ä¢ b‚ÇÅ * a ‚Ä¢ b‚ÇÇ
Result.success

Testing || Finmap.lookup_insert : ‚àÄ {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [inst : DecidableEq Œ±] {a : Œ±} {b : Œ≤ a} (s : Finmap Œ≤),
  Finmap.lookup a (Finmap.insert a b s) = some b
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.OuterMeasureClass.measure_empty : ‚àÄ {F : Type u_2} {Œ± : outParam (Type u_3)} {inst : FunLike F (Set Œ±) ENNReal}
  [self : MeasureTheory.OuterMeasureClass F Œ±] (f : F), f ‚àÖ = 0
Result.autoException ::
Auto failed to find proof

Testing || Filter.rtendsto_def : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} (r : Rel Œ± Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤),
  Filter.RTendsto r l‚ÇÅ l‚ÇÇ ‚Üî ‚àÄ s ‚àà l‚ÇÇ, r.core s ‚àà l‚ÇÅ
Result.autoException ::
Auto failed to find proof

Testing || zpow_strictMono : ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±}, 1 < a ‚Üí StrictMono fun x => a ^ x
Result.success

Testing || Order.pred_eq_pred_iff : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] {a b : Œ±} [inst_2 : NoMinOrder Œ±],
  Order.pred a = Order.pred b ‚Üî a = b
Result.success

Testing || AddCommute.prod : ‚àÄ {M : Type u_3} {N : Type u_4} [inst : Add M] [inst_1 : Add N] {x y : M √ó N},
  AddCommute x.1 y.1 ‚Üí AddCommute x.2 y.2 ‚Üí AddCommute x y
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.regular_inv_iff : ‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : TopologicalSpace G] [inst_2 : BorelSpace G]
  {Œº : MeasureTheory.Measure G} [inst_3 : Group G] [inst_4 : TopologicalGroup G], Œº.inv.Regular ‚Üî Œº.Regular
Result.autoException ::
Auto failed to find proof

Testing || mul_div_cancel_of_invertible : ‚àÄ {Œ± : Type u} [inst : GroupWithZero Œ±] (a b : Œ±) [inst_1 : Invertible b], a * b / b = a
Result.autoException ::
Auto failed to find proof

Testing || Real.logb_pos : ‚àÄ {b x : ‚Ñù}, 1 < b ‚Üí 1 < x ‚Üí 0 < Real.logb b x
Result.success

Testing || continuousWithinAt_update_same : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±}
  {x : Œ±} [inst_2 : DecidableEq Œ±] {y : Œ≤},
  ContinuousWithinAt (Function.update f x y) s x ‚Üî Filter.Tendsto f (nhdsWithin x (s \ {x})) (nhds y)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : #0, (‚àÄ x1 : #2, (‚àÄ x2 : (#0 ‚Üí Prop), ((!12 (Œªx3 : #0, (x2 x3)) (!7 x0 x1)) ‚Üî (!12 (Œªx3 : #0, ((!13 x1 x3) ‚Üí (x2 x3))) (!14 x0)))))) is not type correct

Testing || CategoryTheory.prod.rightUnitor_obj : ‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] (X : C √ó CategoryTheory.Discrete PUnit.{w + 1}),
  (CategoryTheory.prod.rightUnitor C).obj X = X.1
Result.autoException ::
Auto failed to find proof

Testing || PowerSeries.ext : ‚àÄ {R : Type u_1} [inst : Semiring R] {œÜ œà : PowerSeries R},
  (‚àÄ (n : ‚Ñï), (PowerSeries.coeff R n) œÜ = (PowerSeries.coeff R n) œà) ‚Üí œÜ = œà
Result.success

Testing || AlgebraicGeometry.Scheme.GlueData.sheafValGluedMk_val : ‚àÄ (D : AlgebraicGeometry.Scheme.GlueData) {F : CategoryTheory.Sheaf AlgebraicGeometry.Scheme.zariskiTopology (Type v)}
  (s : (j : D.J) ‚Üí F.val.obj (Opposite.op (D.U j)))
  (h :
    ‚àÄ (i j : D.J),
      F.val.map (D.f i j).op (s i) = F.val.map (CategoryTheory.CategoryStruct.comp (D.f j i).op (D.t i j).op) (s j))
  (j : D.J), F.val.map (D.Œπ j).op (D.sheafValGluedMk s h) = s j
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.val.obj (Opposite.op D.glued) ‚ü∂
  F.val.obj (Opposite.op (D.U j)) is not a `‚àÄ`

Testing || Filter.disjoint_atBot_principal_Ici : ‚àÄ {Œ± : Type u_3} [inst : Preorder Œ±] [inst_1 : NoMinOrder Œ±] (x : Œ±),
  Disjoint Filter.atBot (Filter.principal (Set.Ici x))
Result.autoException ::
Auto failed to find proof

Testing || LinearAlgebra.FreeProduct.of_def : ‚àÄ {I : Type u_1} [inst : DecidableEq I] (R : Type u_2) [inst_1 : CommSemiring R] (A : I ‚Üí Type u_3)
  [inst_2 : (i : I) ‚Üí Semiring (A i)] [inst_3 : (i : I) ‚Üí Algebra R (A i)] {i : I},
  LinearAlgebra.FreeProduct.of R A = LinearAlgebra.FreeProduct.Œπ R A i
Result.autoException ::
Auto failed to find proof

Testing || differentiableOn_id' : ‚àÄ {K : Type u_1} [inst : NontriviallyNormedField K] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace K E] {s : Set E}, DifferentiableOn K (fun x => x) s
Result.autoException ::
Auto failed to find proof

Testing || Order.not_isMax_pred : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Nontrivial Œ±] (a : Œ±), ¬¨IsMax (Order.pred a)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.limitIsoOfIsRightKanExtension_hom_œÄ : ‚àÄ {C : Type u_1} {H : Type u_3} {D : Type u_4} [inst : CategoryTheory.Category.{u_8, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_6, u_3} H] [inst_2 : CategoryTheory.Category.{u_7, u_4} D]
  (F' : CategoryTheory.Functor D H) {L : CategoryTheory.Functor C D} {F : CategoryTheory.Functor C H}
  (Œ± : L.comp F' ‚ü∂ F) [inst_3 : F'.IsRightKanExtension Œ±] [inst_4 : CategoryTheory.Limits.HasLimit F]
  [inst_5 : CategoryTheory.Limits.HasLimit F'] (i : C),
  CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension Œ±).hom (CategoryTheory.Limits.limit.œÄ F i) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F' (L.obj i)) (Œ±.app i)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.limit.œÄ
  cifvar_5 (cifvar_24 (cifvar_25 cifvar_26) x_0)`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || continuous_coe_real_ereal : Continuous Real.toEReal
Result.success

Testing || SetTheory.PGame.LF.not_equiv : ‚àÄ {x y : SetTheory.PGame}, x.LF y ‚Üí ¬¨x ‚âà y
Result.autoException ::
Auto failed to find proof

Testing || Quot.lift‚ÇÇ_mk : ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_4} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
  (hr : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤), s b‚ÇÅ b‚ÇÇ ‚Üí f a b‚ÇÅ = f a b‚ÇÇ) (hs : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (b : Œ≤), r a‚ÇÅ a‚ÇÇ ‚Üí f a‚ÇÅ b = f a‚ÇÇ b)
  (a : Œ±) (b : Œ≤), Quot.lift‚ÇÇ f hr hs (Quot.mk r a) (Quot.mk s b) = f a b
Result.autoException ::
Auto failed to find proof

Testing || BialgHom.coe_toAlgHom : ‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : CoalgebraStruct R A] [inst_6 : CoalgebraStruct R B]
  (f : A ‚Üí‚Çêc[R] B), ‚áë‚Üëf = ‚áëf
Result.autoException ::
Auto failed to find proof

Testing || Finset.image_add_left_Ioc : ‚àÄ {Œ± : Type u_2} [inst : OrderedCancelAddCommMonoid Œ±] [inst_1 : ExistsAddOfLE Œ±] [inst_2 : LocallyFiniteOrder Œ±]
  [inst_3 : DecidableEq Œ±] (a b c : Œ±), Finset.image (fun x => c + x) (Finset.Ioc a b) = Finset.Ioc (c + a) (c + b)
Result.autoException ::
Auto failed to find proof

Testing || Int.dist_eq : ‚àÄ (x y : ‚Ñ§), dist x y = |‚Üëx - ‚Üëy|
Result.autoException ::
Auto failed to find proof

Testing || FiniteDimensional.of_locallyCompactSpace : ‚àÄ (ùïú : Type u) [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] [inst_4 : LocallyCompactSpace E], FiniteDimensional ùïú E
Result.success

Testing || WithZero.unzero_mul : ‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {x y : WithZero Œ±} (hxy : x * y ‚â† 0),
  WithZero.unzero hxy = WithZero.unzero ‚ãØ * WithZero.unzero ‚ãØ
Result.autoException ::
Auto failed to find proof

Testing || Subgroup.smul_normal : ‚àÄ {G : Type u_2} [inst : Group G] (g : G) (H : Subgroup G) [h : H.Normal], MulAut.conj g ‚Ä¢ H = H
Result.autoException ::
Auto failed to find proof

Testing || _private.Mathlib.Topology.MetricSpace.GromovHausdorffRealized.0.GromovHausdorff.candidates_lipschitz : ‚àÄ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : GromovHausdorff.ProdSpaceFun X Y},
  f ‚àà GromovHausdorff.candidates X Y ‚Üí LipschitzWith (2 * GromovHausdorff.maxVar X Y) f
Result.autoException ::
Auto failed to find proof
